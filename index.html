<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Microtonal Omnichord</title>
    <!-- Retro font (Oswald) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root { --retro-font: 'Oswald','Arial Narrow','Helvetica Neue',Arial,sans-serif; }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            font-family: var(--retro-font) !important;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        .instrument {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        .root-notes-area {
            height: 260px; /* sync with later override */
            background: rgba(0, 30, 60, 0.9);
            border-bottom: 2px solid #333;
            padding: 10px;
            display: flex;
            align-items: flex-start;
        }

        .strum-area {
            flex: 1 1 auto; /* fill remaining vertical space */
            position: relative;
            background: linear-gradient(180deg, #0f3460, #16537e);
            overflow: hidden;
            display: flex;
            padding: 0;
            border: 2px solid #4a6870;
            gap: 0;
            min-height: 200px;
        }

        .strum-area:hover {
            border-color: #8fb3d3;
        }



        .empty-hint {
            text-align: center;
            font-size: 12px;
        }

        .palette-column {
            min-height: 200px;
            max-height: 300px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .palette-chord-remove {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background: #e94560;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
            transition: all 0.2s;
        }

        .palette-chord-remove:hover {
            background: #c73650;
            transform: scale(1.1);
        }

        .palette-chord {
            flex: 1;
            max-width: 25%;
            min-width: 80px;
            background: linear-gradient(135deg, #2a4858, #3a5868);
            border: 2px solid #4a6870;
            border-radius: 8px;
            display: flex;
            flex-direction: row;
            align-items: stretch;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            padding: 0;
            overflow: hidden;
            gap: 2px;
            touch-action: none; /* Prevent default touch behaviors */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -webkit-touch-callout: none; /* Prevent iOS callout */
        }

        .palette-chord:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            border-color: #6aa0b0;
        }

        .palette-chord:active {
            transform: translateY(0px) scale(0.98);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .palette-chord.active {
            border-color: #e94560;
            box-shadow: 0 0 15px rgba(233, 69, 96, 0.5);
            background: linear-gradient(135deg, #4a2858, #5a3868);
        }

        /* Touch-specific feedback states for palette chords */
        .palette-chord.touch-pressed {
            transform: translateY(0px) scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #3a5868, #4a6878);
        }

        .palette-chord.touch-long-press {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 20px rgba(106, 160, 176, 0.6);
            border-color: #8ab0c0;
            background: linear-gradient(135deg, #4a6878, #5a7888);
        }

        .palette-chord-name {
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            height: 20px;
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }

        .palette-chord-root {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            height: 15px;
            font-size: 8px;
            color: #8fb3d3;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }

        .palette-chord-strings {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-evenly;
            padding: 25px 4px 20px 4px;
            position: relative;
        }

        .palette-string {
            height: 3px;
            background: linear-gradient(90deg, #34495e, #95a5a6, #34495e);
            border-radius: 1px;
            position: relative;
            cursor: pointer;
            transition: all 0.05s;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            margin: 1px 0;
            flex-shrink: 0;
            overflow: hidden;
        }

        .palette-string:hover {
            transform: scaleY(1.3);
            box-shadow: 0 0 8px rgba(149, 165, 166, 0.5);
        }

        .palette-string.active {
            background: linear-gradient(90deg, #e74c3c, #f39c12, #e74c3c);
            transform: scaleY(1.5);
            box-shadow: 0 0 12px rgba(231, 76, 60, 0.7);
        }

        .palette-string-wave {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.1s;
            background: repeating-linear-gradient(
                90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.3) 25%,
                transparent 50%,
                rgba(255, 255, 255, 0.3) 75%,
                transparent 100%
            );
            background-size: 15px 100%;
            animation: wave-flow 1s linear infinite;
        }

        .palette-string.active .palette-string-wave {
            opacity: 1;
        }

        .palette-chord-remove {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 16px;
            height: 16px;
            background: #e94560;
            border: 1px solid #c73650;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 8px;
            color: white;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .palette-chord:hover .palette-chord-remove {
            opacity: 1;
        }

        .root-notes-area {
            height: 260px; /* enlarged to fit circular keyboard + microtone lanes */
            flex: 0 0 260px; /* lock vertical allocation */
            background: rgba(0, 20, 40, 0.9);
            border-bottom: 1px solid #333;
            display: flex;
            align-items: flex-start; /* keep keyboard pinned to top to avoid jump when regenerating */
            justify-content: center; /* center horizontally */
            padding: 8px 8px 0 8px;
            position: relative;
        }

        .clear-triads-container {
            display: flex;
            align-items: center;
        }

        .clear-triads-btn {
            background: linear-gradient(135deg, #e94560, #c73650);
            border: 1px solid #c73650;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .clear-triads-btn:hover {
            background: linear-gradient(135deg, #c73650, #a52a42);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

        .clear-triads-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .notes-area {
            height: 18vh;
            background: rgba(0, 20, 40, 0.8);
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 6px;
        }

        .control-panel {
            height: calc(100vh - 90px - 28vh - 28vh);
            min-height: 35vh;
            padding: 10px;
            background: rgba(0, 20, 40, 0.9);
            overflow: visible;
            display: grid;
            grid-template-columns: 300px 200px 280px 1fr;
            gap: 15px;
            align-content: start;
            min-width: 0;
            width: 100%;
        }

        .tuning-buttons {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            align-items: center;
        }

        .tuning-btn {
            padding: 6px 8px;
            background: #2a4858;
            border: 1px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 10px;
            white-space: nowrap;
            font-weight: bold;
        }

        .tuning-btn.active {
            background: #4a8fa0;
            border-color: #6aa0b0;
            box-shadow: 0 0 10px rgba(74, 143, 160, 0.5);
        }

        .chord-section {
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 20px;
            margin-bottom: 15px;
            color: #8fb3d3;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        .chord-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 8px;
            margin-bottom: 15px;
        }

        .chord-btn {
            aspect-ratio: 1;
            background: #2a4858;
            border: 2px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            touch-action: none; /* Prevent default touch behaviors */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -webkit-touch-callout: none; /* Prevent iOS callout */
        }

        .chord-btn:hover {
            background: #3a5868;
            transform: scale(1.05);
        }

        .chord-btn:active {
            background: #4a7888;
            transform: scale(0.98);
        }

        .chord-btn.active {
            background: #e74c3c;
            border-color: #c0392b;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.5);
        }

        /* Touch-specific feedback states */
        .chord-btn.touch-pressed {
            background: #4a7888;
            transform: scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .chord-btn.touch-long-press {
            background: #5a8898;
            transform: scale(1.02);
            box-shadow: 0 0 20px rgba(90, 136, 152, 0.6);
            border-color: #6a98a8;
        }

        .quality-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .quality-btn {
            flex: 1;
            padding: 10px;
            background: #2a4858;
            border: 2px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s;
        }

        .quality-btn.active {
            background: #f39c12;
            border-color: #e67e22;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }

        .extension-columns {
            flex: 1;
            display: flex;
            height: 100%;
            min-height: 0; /* allow children to shrink vertically */
            gap: 0;
            padding: 0;
            justify-content: stretch;
        }

        .quality-section {
            display: flex;
            flex-direction: row;
            flex: 1;
            gap: 2px;
            padding: 0;
            border-radius: 0;
            min-width: 0; /* Allow shrinking */
            max-width: 33.33%; /* Ensure 3 equal sections */
        }

        .extension-column {
            position: relative;
            border-right: none;
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0; /* allow strings to shrink when header grows */
            min-width: 0;
            width: 100%;
            cursor: grab;
            transition: all 0.2s ease;
            height: 100%;
        }

        .extension-column:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .extension-column:active {
            cursor: grabbing;
        }

        /* Context menus removed for clean interface */

        .extension-column:last-child {
            border-right: none;
        }

        .extension-header {
            height: auto; /* allow header to grow when buttons wrap */
            min-height: 56px;
            max-height: none;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 13px;
            font-weight: bold;
            text-align: center;
            padding: 10px 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            position: relative;
            transition: background 0.2s, transform 0.1s;
            z-index: 100;
            user-select: none;
            border-radius: 4px 4px 0 0;
            margin: 2px 2px 0 2px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            flex-wrap: wrap;
            align-content: flex-start; /* stack rows from the top when wrapping */
        }

        .chord-name {
            flex: 1;
            text-align: center;
        }

        .lock-button {
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s;
            margin-left: 6px;
            flex-shrink: 0;
            z-index: 100;
            position: relative;
            pointer-events: auto;
            touch-action: manipulation;
        }

        .lock-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .lock-button.locked {
            background: #4CAF50;
            border-color: #45a049;
            color: #fff;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
        }

        .piano-lock-button {
            width: 40px;
            height: 40px;
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 6px;
            color: #666;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
            margin-left: 6px;
            flex-shrink: 0;
            z-index: 100;
            position: relative;
            pointer-events: auto;
            touch-action: manipulation;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .piano-lock-button:hover {
            background: #2a2a2a;
            border-color: #555;
            transform: scale(1.1);
            color: #999;
        }

        .piano-lock-button.locked {
            background: #8B5CF6;
            border-color: #7C3AED;
            color: #fff;
            box-shadow: 0 0 12px rgba(139, 92, 246, 0.8);
            transform: scale(1.05);
        }

        .piano-lock-button.locked:hover {
            background: #9F7AEA;
            border-color: #8B5CF6;
            box-shadow: 0 0 16px rgba(139, 92, 246, 1);
        }

        .chord-action-button {
            width: 34px;
            height: 34px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s;
            margin-left: 6px;
            flex-shrink: 0;
        }

        .chord-action-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .chord-action-button.edit {
            background: rgba(33, 150, 243, 0.2);
            border-color: rgba(33, 150, 243, 0.5);
        }

    /* delete button styling removed; delete is via upward drag */

        .chord-action-button.duplicate {
            background: rgba(156, 39, 176, 0.2);
            border-color: rgba(156, 39, 176, 0.5);
        }

        .header-buttons {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: auto;
            pointer-events: auto;
            z-index: 99;
            position: relative;
            flex-wrap: wrap;
            row-gap: 6px;
        }

        .extension-header:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

        .extension-header:active {
            transform: translateY(0);
            background: rgba(255, 255, 255, 0.2);
        }

        /* Touch feedback styles */
        .touch-pressed {
            background: rgba(233, 69, 96, 0.3) !important;
            transform: scale(0.98);
            transition: background 0.1s, transform 0.1s;
        }

        .touch-long-press {
            background: rgba(233, 69, 96, 0.5) !important;
            transform: scale(1.02);
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
            transition: background 0.2s, transform 0.2s, box-shadow 0.2s;
        }

        .strings-column {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            padding: 0; /* no inner gaps */
            overflow: hidden; /* Prevent scrollbars */
            min-height: 0; /* allow shrinking when header grows */
            box-sizing: border-box;
        }

        .note-label {
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7px;
            color: #8fb3d3;
            text-align: center;
            padding: 1px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Hit area fills the lane from string to string (no gaps) */
        .string {
            position: relative;
            cursor: pointer;
            display: flex;
            align-items: center; /* center the visible core */
            justify-content: stretch;
            flex: 1 1 0;
            margin: 0; /* no gaps */
            padding: 0; /* keep tight */
            overflow: visible; /* allow glow to bloom */
        }

        /* The actual visible 4px neon line lives inside the hit area */
        .string-core {
            position: relative;
            width: 100%;
            height: 4px; /* visual thickness */
            border-radius: 2px;
            transition: transform 0.08s ease, box-shadow 0.1s ease, opacity 0.1s ease, filter 0.1s ease;
            transform-origin: center;
            will-change: transform;
            pointer-events: none; /* events on the hit area (.string) */
        }

        .string:hover .string-core {
            transform: scaleY(1.2);
            filter: brightness(1.05);
        }

        .string.active .string-core {
            transform: scaleY(1.25);
            filter: brightness(1.15);
        }

    .string-wave {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.1s;
            background: repeating-linear-gradient(
                90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.3) 25%,
                transparent 50%,
                rgba(255, 255, 255, 0.3) 75%,
                transparent 100%
            );
            background-size: 20px 100%;
            animation: wave-flow 1s linear infinite;
        }

    .string.active .string-wave {
            opacity: 1;
        }

        @keyframes wave-flow {
            0% {
                background-position-x: 0;
            }
            100% {
                background-position-x: 20px;
            }
        }

        /* Subtle vertical vibration tied to frequency (period set via --vib-period) */
        @keyframes vibrate-y {
            0% { transform: translateY(0) scaleY(1); }
            25% { transform: translateY(-1px) scaleY(1.07); }
            50% { transform: translateY(0) scaleY(1); }
            75% { transform: translateY(1px) scaleY(1.07); }
            100% { transform: translateY(0) scaleY(1); }
        }

        .string-core.vibrating {
            animation: vibrate-y var(--vib-period, 60ms) ease-in-out infinite;
        }

        .note-labels {
            height: 30px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #8fb3d3;
            text-align: center;
            padding: 2px;
        }

        .frequency-display {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #bdc3c7;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .string:hover .frequency-display {
            opacity: 1;
        }

        .current-chord {
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 25px;
            border-radius: 12px;
            border: 2px solid #4a6870;
            z-index: 1000;
        }

        .current-chord h3 {
            color: #e74c3c;
            margin-bottom: 8px;
            font-size: 24px;
            text-align: center;
        }

        .current-chord div {
            font-size: 16px;
            text-align: center;
            color: #8fb3d3;
        }

        .root-notes-selector {
            display: flex;
            gap: 4px;
            align-items: center;
            justify-content: center;
            width: 100%;
            flex-wrap: wrap;
        }

        .root-notes-selector {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .root-notes-selector .section-title {
            font-size: 18px;
            color: #8fb3d3;
            margin-right: 20px;
            white-space: nowrap;
        }

        .root-chord-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(20px, 1fr));
            grid-template-rows: 1fr;
            gap: 1px;
            flex: 1;
            width: 100%;
            max-height: none !important;
            height: 100% !important;
            position: relative;
        }

        .root-btn {
            flex: 1;
            min-width: 20px;
            height: 45px;
            background: linear-gradient(145deg, #2c5aa0, #1e3a8a);
            border: 1px solid #4a90e2;
            border-radius: 6px;
            color: white;
            font-weight: bold;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            touch-action: none; /* Prevent default touch behaviors */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -webkit-touch-callout: none; /* Prevent iOS callout */
        }

        .root-btn:hover {
            background: linear-gradient(145deg, #3d6bb5, #2949a0);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .root-btn:active {
            background: linear-gradient(145deg, #1e3a8a, #1a2f70);
            transform: translateY(0px) scale(0.95);
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        /* Touch-specific feedback states for root buttons */
        .root-btn.touch-pressed {
            background: linear-gradient(145deg, #1e3a8a, #1a2f70);
            transform: translateY(0px) scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .root-btn.touch-long-press {
            background: linear-gradient(145deg, #4d7bc5, #3959b0);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(74, 144, 226, 0.6);
            border-color: #6aa0e2;
        }

        .root-btn.active {
            background: linear-gradient(145deg, #f59e0b, #d97706);
            border-color: #fbbf24;
            color: #000;
            font-weight: bold;
        }

        /* ================= Piano Keyboard Revamp (Top Row) ================ */
        .piano-keyboard {
            position: relative;
            width: 66.666vw; /* fixed 2/3 viewport width */
            max-width: 1500px; /* cap width on large screens */
            height: 200px; /* fixed height */
            margin: 12px auto 8px auto; /* centered near top */
            user-select: none;
            background: #4b0047; /* dark brown */
            border-radius: 8px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.7);
            overflow: hidden;
            /* scaling removed */
            padding-top: 4px; /* slight top padding so glow/outline never alters outer box */
        }
        /* Reserve vertical space inside for active glow so layout never shifts */
        .piano-keyboard .white-key.root-btn,
        .piano-keyboard .black-key.root-btn,
        .piano-keyboard .edo-dot { will-change: transform; }
        /* Neutralize any accidental layout influence from outlines */
        .piano-keyboard .white-key.root-btn.active,
        .piano-keyboard .black-key.root-btn.active,
        .piano-keyboard .edo-dot.active { outline-offset: 0; }
        /* Prevent reflow on hover/active transitions */
        .piano-keyboard .white-key.root-btn,
        .piano-keyboard .black-key.root-btn { position:absolute; }
        /* Hardware accelerate transforms for smoother glow without jitter */
    .piano-keyboard, .piano-keyboard * { backface-visibility:hidden; }
        /* ===== Branding ===== */
    .logo-inline { position:fixed; top:14px; left:20px; z-index:9500; font-family: var(--retro-font); font-weight:600; font-size:32px; letter-spacing:1px; line-height:1; display:flex; align-items:center; gap:6px; pointer-events:none; user-select:none; color:#ffffff; text-shadow:0 0 8px rgba(255,255,255,0.7), 0 0 16px rgba(120,180,255,0.4); animation: logoPulse 3.2s ease-in-out infinite; }
    .logo-inline span { color:#fff; }
    @keyframes logoPulse { 0%,100% { text-shadow:0 0 4px rgba(255,255,255,0.4),0 0 10px rgba(140,180,255,0.25); opacity:0.92; } 50% { text-shadow:0 0 10px rgba(255,255,255,0.9),0 0 24px rgba(140,180,255,0.55); opacity:1; } }
        .piano-keyboard .by-fastfast { position:absolute; top:10px; right:16px; font-family: var(--retro-font); font-size:16px; font-weight:600; color:#ffffff; text-shadow:0 0 6px rgba(255,255,255,0.35), 0 0 12px rgba(120,140,255,0.45); opacity:0.95; pointer-events:none; user-select:none; }
        @media (max-width: 900px){
            .logo-inline { font-size:26px; }
            .piano-keyboard .by-fastfast { font-size:13px; top:12px; }
        }
        /* Ensure retro font everywhere */
        button, .root-btn, .extension-header, .control-panel, input, select, .edo-dot { font-family: var(--retro-font) !important; }
        /* Base circle key */
        .piano-keyboard .white-key.root-btn,
        .piano-keyboard .black-key.root-btn {
            position:absolute;
            width:70px;
            height:70px;
            z-index:2; /* keep keys above micro dots so labels (like B) remain visible */
            border-radius:50%;
            display:flex;
            align-items:center;
            justify-content:center;
            font-size:14px;
            font-weight:bold;
            cursor:pointer;
            transform:translate(-50%, -50%);
            transition:filter .15s, transform .1s;
            box-shadow:0 4px 10px rgba(0,0,0,0.6), inset 0 -4px 6px rgba(0,0,0,0.4);
        }
        .piano-keyboard .white-key.root-btn {
            background:radial-gradient(circle at 30% 30%, #ffffff, #d9d9d9 60%, #bdbdbd);
            color:#222;
            top:78%; /* bring upward so full circle visible */
        }
        .piano-keyboard .white-key.root-btn.disabled { filter:grayscale(60%) brightness(0.8); opacity:.6; }
        .piano-keyboard .white-key.root-btn.active { outline:3px solid #ffd046; box-shadow:0 0 14px 4px rgba(255,208,70,0.7); }
        .piano-keyboard .black-key.root-btn {
            background:radial-gradient(circle at 30% 30%, #444, #111 65%, #000);
            color:#eee;
            top:26%; /* adjust for reduced height */
            width:68px;
            height:68px;
        }
        .piano-keyboard .black-key.root-btn.disabled { filter:grayscale(60%) brightness(0.6); opacity:.55; }
        .piano-keyboard .black-key.root-btn.active { outline:3px solid #9d6bff; box-shadow:0 0 16px 4px rgba(157,107,255,0.8); }
        .piano-keyboard .white-key.root-btn:active, .piano-keyboard .black-key.root-btn:active { transform:translate(-50%, -50%) scale(.94); }
        .piano-keyboard .white-key.root-btn:hover, .piano-keyboard .black-key.root-btn:hover { filter:brightness(1.15); }

        /* Legacy microtone overlay removal */
        .piano-keyboard .microtone-key.root-btn { display:none; }
        .piano-keyboard .microtone-key.root-btn span { pointer-events:none; }

        /* 96-EDO microtone dot system */
        .piano-keyboard .edo-dot {
            position:absolute;
            width:26px;
            height:26px;
            z-index:1; /* ensure dots don't obscure white/black key labels */
            border-radius:50%;
            transform:translateX(-50%);
            box-shadow:0 1px 3px rgba(0,0,0,0.6), inset 0 0 3px rgba(255,255,255,0.4);
            cursor:pointer;
            display:flex;
            align-items:center;
            justify-content:center;
            font-size:11px;
            font-weight:bold;
            color:#fff;
            text-shadow:0 1px 2px rgba(0,0,0,0.9);
            padding:2px;
            box-sizing:border-box;
        }
        .piano-keyboard .edo-dot.blue { background:radial-gradient(circle at 30% 30%, #6fa9ff, #2563eb 60%, #1e3a8a); }
        .piano-keyboard .edo-dot.green { background:radial-gradient(circle at 30% 30%, #5ef0b2, #0d9e6f 60%, #065f46); }
        .piano-keyboard .edo-dot.red { background:radial-gradient(circle at 30% 30%, #ff9a9a, #dc2626 60%, #7f1d1d); }
    .piano-keyboard .edo-dot.active { outline:2px solid #fff; box-shadow:0 0 10px 4px rgba(255,255,255,0.9); filter:brightness(1.2); }
    .piano-keyboard .edo-dot.red.active { box-shadow:0 0 12px 5px rgba(220,38,38,0.9),0 0 6px 3px rgba(255,255,255,0.8); }
    .piano-keyboard .edo-dot.green.active { box-shadow:0 0 12px 5px rgba(13,158,111,0.9),0 0 6px 3px rgba(255,255,255,0.8); }
    .piano-keyboard .edo-dot.blue.active { box-shadow:0 0 12px 5px rgba(37,99,235,0.9),0 0 6px 3px rgba(255,255,255,0.8); }
    /* Chord-builder selection glow (non-root) */
    .piano-keyboard .edo-dot.selected { outline:3px solid #f39c12; box-shadow:0 0 14px 5px rgba(243,156,18,0.85),0 0 6px 3px rgba(255,255,255,0.5); filter:brightness(1.15); }
        /* Vertical lanes (percent from top of keyboard height) */
    /* Updated vertical lane centers to match reference image (from top to bottom: black, blue, green, red, white) */
    .piano-keyboard .edo-lane-blue  { top:39%; }
    .piano-keyboard .edo-lane-green { top:52%; }
    .piano-keyboard .edo-lane-red   { top:65%; }

        /* ================================================================== */

        /* Chord creation mode styles */
        .chord-creation-mode .root-notes-area {
            background: rgba(0, 60, 30, 0.9);
            border-color: #2E8B57;
        }

        .chord-creation-mode .root-notes-area::before {
            content: "?? Select intervals for your chord - Click root buttons to add/remove notes";
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #90EE90;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 8px;
            border-radius: 4px;
            z-index: 10;
        }

        .chord-creation-mode .root-btn {
            background: #2a4858;
            border-color: #4a6870;
        }

        .chord-creation-mode .root-btn:hover {
            background: #3a5868;
            border-color: #5a7880;
        }

        .chord-creation-mode .root-btn.selected {
            background: #e74c3c;
            border-color: #c0392b;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.7);
        }

        .chord-creation-mode .root-btn.preview {
            background: #f39c12;
            border-color: #e67e22;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }

        .chord-types-selector {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .chord-types-selector .section-title {
            font-size: 12px;
            color: #8fb3d3;
            margin-right: 10px;
        }

        .quality-selector {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .quality-selector .section-title {
            font-size: 12px;
            color: #8fb3d3;
            margin-right: 10px;
        }

        .volume-control {
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #4a6870;
            display: flex;
            flex-direction: column;
            gap: 12px;
            font-size: 11px;
        }

        .synth-section {
            border: 1px solid rgba(74, 104, 112, 0.5);
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 8px;
            min-width: 0;
            overflow: hidden;
        }

        .synth-section h4 {
            color: #8fb3d3;
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        .envelope-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .envelope-group {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .envelope-group label {
            font-size: 12px;
            color: #8fb3d3;
            font-weight: bold;
        }

        .envelope-slider, .synth-slider {
            width: 100%;
            height: 25px;
            background: #1a1a2e;
            border-radius: 12px;
            outline: none;
            cursor: pointer;
        }

        .envelope-slider::-webkit-slider-thumb, .synth-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4a8fa0;
            cursor: pointer;
            border: 2px solid #6aa0b0;
        }

        .oscillator-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            margin-top: 6px;
        }

        .osc-btn {
            padding: 10px;
            background: #2a4858;
            border: 2px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 6px;
            font-size: 11px;
            transition: all 0.2s;
            text-align: center;
            font-weight: bold;
        }

        .osc-btn.active {
            background: #27ae60;
            border-color: #2ecc71;
            box-shadow: 0 0 8px rgba(39, 174, 96, 0.5);
        }

        .multi-osc-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 6px;
        }

        .osc-group {
            border: 1px solid rgba(74, 104, 112, 0.3);
            border-radius: 4px;
            padding: 6px;
        }

        .osc-group h5 {
            font-size: 8px;
            color: #8fb3d3;
            margin-bottom: 4px;
        }

        .osc-mix-controls {
            display: flex;
            gap: 4px;
            margin-top: 4px;
        }

        .effects-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .effect-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .effect-group label {
            font-size: 8px;
            color: #8fb3d3;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .slider-value {
            font-size: 7px;
            color: #bdc3c7;
            text-align: center;
        }

        @media (max-width: 768px) {
            .control-panel {
                height: 60px;
                padding: 5px;
                gap: 8px;
            }
            
            .tuning-btn {
                padding: 4px 6px;
                font-size: 10px;
            }
            
            .chord-header {
                height: 30px;
                font-size: 8px;
            }
            
            .string {
                margin: 0.2px 0;
                height: 1px;
            }
            
            .note-labels {
                height: 25px;
                font-size: 7px;
            }
            
            .volume-control {
                min-width: 120px;
                max-width: 140px;
                padding: 6px;
            }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .control-panel {
                height: 50px;
                padding: 3px;
            }
            
            .chord-header {
                height: 25px;
                font-size: 7px;
            }
            
            .note-labels {
                height: 20px;
                font-size: 6px;
            }
            
            .string {
                margin: 0.2px 0;
                height: 1px;
            }
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: #2a2a2a;
            color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid #666;
        }

        .add-column-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .add-chord-btn {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .add-chord-btn:hover {
            background: linear-gradient(135deg, #357abd, #2868a3);
            transform: translateY(-2px);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        /* Tutorial System Styles */
        .tutorial-highlight {
            box-shadow: 0 0 20px #8fb3d3, 0 0 40px #8fb3d3, 0 0 60px #8fb3d3 !important;
            border: 3px solid #8fb3d3 !important;
            filter: brightness(1.5) contrast(1.2) !important;
            position: relative !important;
            z-index: 9500 !important;
            background: rgba(143, 179, 211, 0.15) !important;
            border-radius: 8px !important;
        }

        #tutorialOverlay {
            backdrop-filter: blur(2px);
        }

        #tutorialBox {
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-height: 80vh;
            overflow-y: auto;
            position: fixed !important;
            top: 50px !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            z-index: 2010 !important;
        }

        #tutorialButton, #randomDiceButton {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        #tutorialButton:hover, #randomDiceButton:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        #randomDiceButton {
            transition: transform 0.6s ease;
        }

        /* Add pulsing animation for tutorial and dice buttons */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(143, 179, 211, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(143, 179, 211, 0); }
            100% { box-shadow: 0 0 0 0 rgba(143, 179, 211, 0); }
        }

        #tutorialButton {
            animation: pulse 2s infinite;
        }

        @keyframes diceRoll {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(720deg); }
        }

        /* Drag & drop chord boxes */
        .extension-column.dragging {
            opacity: 0.98;
            cursor: grabbing;
        }
        .extension-column.placeholder {
            background: rgba(255,255,255,0.06);
        }
        .extension-column.delete-intent .extension-header {
            background: #8b1e1e !important;
            border-color: #ef4444 !important;
        }
    </style>
</head>
<body>
    <!-- Global Logo (fixed on blue background) -->
    <div class="logo-inline"><span class="omg">OMG</span><span class="nichord">- nichord</span></div>
    <!-- Bottom control bar -->
    <div id="bottomBar" style="position:fixed;bottom:0;left:0;right:0;height:50px;display:flex;align-items:center;justify-content:flex-start;gap:14px;padding:0 18px;background:#081a28;border-top:2px solid #123447;z-index:600;font-family:var(--retro-font);">
        <button class="panel-btn" data-panel="tuning">TUNING</button>
        <button class="panel-btn" data-panel="osc">OSCILLATORS</button>
        <button class="panel-btn" data-panel="fx">EFFECTS</button>
        <div style="margin-left:auto;display:flex;align-items:center;gap:8px;">
            <label for="masterVolume" style="font-size:11px;color:#9db6c8;">MASTER</label>
            <input type="range" id="masterVolume" min="0" max="10" value="10" style="width:140px; accent-color:#2d9c5d;">
            <span id="masterVolumeValue" style="font-size:11px; color:#b7d4e6; width:38px; text-align:right;">100%</span>
        </div>
    </div>
    <div id="panelHost" style="position:fixed;bottom:54px;left:12px;width:380px;max-height:55vh;background:#0b2536;border:2px solid #15506a;border-radius:10px;box-shadow:0 -6px 22px rgba(0,0,0,0.55);padding:18px 20px;display:none;overflow-y:auto;z-index:650;font-family:var(--retro-font);">
        <!-- Control Panels migrated here -->
        <div class="panel-content" data-panel="tuning" style="display:none; gap:15px; grid-template-columns:300px;">
            <div class="synth-section" id="tuningSelector" style="padding:8px;">
                <h4 style="font-size:15px; margin-bottom:8px;">EDO Configuration</h4>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:10px;">
                    <div class="slider-container">
                        <label style="font-size:11px;">Divisions</label>
                        <input type="number" id="edoDivisions" min="5" max="200" value="12" style="width:100%; padding:4px; background:#2a4858; color:#fff; border:1px solid #4a6870; border-radius:4px; font-size:11px;">
                    </div>
                    <div class="slider-container">
                        <label style="font-size:11px;">Interval Ratio</label>
                        <select id="intervalRatio" style="width:100%; padding:4px; background:#2a4858; color:#fff; border:1px solid #4a6870; border-radius:4px; font-size:11px;">
                            <option value="2/1">2/1 (Octave)</option>
                            <option value="3/1">3/1 (Tritave)</option>
                            <option value="5/4">5/4 (Major Third)</option>
                            <option value="3/2">3/2 (Perfect Fifth)</option>
                        </select>
                    </div>
                </div>
                <div style="margin-bottom:10px;">
                    <button id="createNewChordBtn" class="osc-btn" style="width:100%; font-size:14px; padding:12px; background:#2E8B57; border-color:#3CB371; margin-bottom:8px;">New Chord</button>
                    <button id="createBasicChordsBtn" class="osc-btn" style="width:100%; font-size:14px; padding:12px; background:#3498db; border-color:#2980b9;">Load Basic Chords</button>
                    <button id="resetChordsBtn" class="osc-btn" style="width:100%; font-size:12px; padding:8px; background:#e74c3c; border-color:#c0392b; margin-top:5px;">Clear Unlocked</button>
                </div>
                <div style="margin-bottom:10px; display:flex; gap:5px;">
                    <button id="saveSessionBtn" class="osc-btn" style="flex:1; font-size:11px; padding:6px; background:#3498db; border-color:#2980b9;">💾</button>
                    <button id="loadSessionBtn" class="osc-btn" style="flex:1; font-size:11px; padding:6px; background:#9b59b6; border-color:#8e44ad;">📂</button>
                    <input type="file" id="loadSessionInput" accept=".omg" style="display:none;">
                </div>
            </div>
        </div>
    <!-- Master panel removed; single master slider now on bar -->
        <div class="panel-content" data-panel="fx" style="display:none;">
            <div class="synth-section" id="effectsSection" style="padding:8px;">
                <h4 style="font-size:15px; margin-bottom:8px; color:#9b59b6;">Effects</h4>
                <div style="margin-bottom:10px;">
                    <label style="font-size:13px; color:#9b59b6;">Reverb</label>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                        <div class="slider-container">
                            <label style="font-size:10px;">Wet</label>
                            <input type="range" class="synth-slider" id="reverbWet" min="0" max="10" value="1" style="height:20px;">
                            <div class="slider-value" id="reverbWetValue" style="font-size:9px;">10%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Room</label>
                            <input type="range" class="synth-slider" id="reverbRoom" min="0" max="10" value="5" style="height:20px;">
                            <div class="slider-value" id="reverbRoomValue" style="font-size:9px;">50%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Decay</label>
                            <input type="range" class="synth-slider" id="reverbDecay" min="0" max="100" value="20" style="height:20px;">
                            <div class="slider-value" id="reverbDecayValue" style="font-size:9px;">2.0s</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Cut</label>
                            <input type="range" class="synth-slider" id="reverbFilterCutoff" min="200" max="20000" value="8000" style="height:20px;">
                            <div class="slider-value" id="reverbFilterCutoffValue" style="font-size:9px;">8kHz</div>
                        </div>
                    </div>
                </div>
                <div>
                    <label style="font-size:13px; color:#e74c3c;">Panning</label>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                        <div class="slider-container">
                            <label style="font-size:10px;">Mode</label>
                            <select id="panningMode" style="width:100%; padding:3px; background:#2a4858; color:#fff; border:1px solid #4a6870; border-radius:3px; font-size:10px; height:24px;">
                                <option value="center">Center</option>
                                <option value="frequency">Freq</option>
                                <option value="random">Random</option>
                                <option value="rotating">Rotate</option>
                                <option value="alternating">Alt</option>
                            </select>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Width</label>
                            <input type="range" class="synth-slider" id="panningWidth" min="0" max="100" value="80" style="height:20px;">
                            <div class="slider-value" id="panningWidthValue" style="font-size:9px;">80%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Speed</label>
                            <input type="range" class="synth-slider" id="panningSpeed" min="200" max="10000" value="2000" style="height:20px;">
                            <div class="slider-value" id="panningSpeedValue" style="font-size:9px;">2.0s</div>
                        </div>
                        <div style="display:flex; align-items:center; justify-content:center;">
                            <div class="mix-btn" id="panningReset" style="font-size:9px; padding:4px; cursor:pointer;">Reset</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="panel-content" data-panel="osc" style="display:none;">
            <div class="synth-section" id="oscillatorsSection" style="padding:8px;">
                <h4 style="font-size:15px; margin-bottom:8px;">Oscillators</h4>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
                    <div style="border:1px solid #4a6870; border-radius:4px; padding:8px; background:rgba(42,72,88,0.2);">
                        <h5 style="font-size:12px; margin-bottom:6px; color:#8fb3d3;">OSC 1</h5>
                        <div class="oscillator-controls" style="grid-template-columns:repeat(5,1fr); gap:2px; margin-bottom:6px;">
                            <div class="osc-btn active" data-wave="sine" data-osc="1" style="font-size:9px; padding:3px;">Sin</div>
                            <div class="osc-btn" data-wave="sawtooth" data-osc="1" style="font-size:9px; padding:3px;">Saw</div>
                            <div class="osc-btn" data-wave="square" data-osc="1" style="font-size:9px; padding:3px;">Sqr</div>
                            <div class="osc-btn" data-wave="triangle" data-osc="1" style="font-size:9px; padding:3px;">Tri</div>
                            <div class="osc-btn" data-wave="noise" data-osc="1" style="font-size:9px; padding:3px;">Nse</div>
                        </div>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px; margin-bottom:8px;">
                            <div class="slider-container">
                                <label style="font-size:9px;">Level</label>
                                <input type="range" class="synth-slider" id="osc1Level" min="0" max="10" value="5" style="height:20px;">
                                <div class="slider-value" id="osc1LevelValue" style="font-size:9px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Detune</label>
                                <input type="range" class="synth-slider" id="osc1Detune" min="-50" max="50" value="0" style="height:20px;">
                                <div class="slider-value" id="osc1DetuneValue" style="font-size:9px;">0¢</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Octave</label>
                                <input type="range" class="synth-slider" id="osc1Octave" min="-3" max="3" value="0" style="height:20px;">
                                <div class="slider-value" id="osc1OctaveValue" style="font-size:9px;">0</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Coarse</label>
                                <input type="range" class="synth-slider" id="osc1Coarse" min="-24" max="24" value="0" step="1" style="height:20px;">
                                <div class="slider-value" id="osc1CoarseValue" style="font-size:9px;">0 steps</div>
                            </div>
                        </div>
                        <h6 style="font-size:10px; margin:6px 0 4px 0; color:#f39c12;">ADSR 1</h6>
                        <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:3px;">
                            <div class="slider-container">
                                <label style="font-size:8px;">Attack</label>
                                <input type="range" class="envelope-slider" id="attackSlider" min="3" max="1000" value="5" style="height:18px;">
                                <div class="slider-value" id="attackValue" style="font-size:8px;">5ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Decay</label>
                                <input type="range" class="envelope-slider" id="decaySlider" min="1" max="200" value="30" style="height:18px;">
                                <div class="slider-value" id="decayValue" style="font-size:8px;">30ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Sustain</label>
                                <input type="range" class="envelope-slider" id="sustainSlider" min="0" max="10" value="5" style="height:18px;">
                                <div class="slider-value" id="sustainValue" style="font-size:8px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Release</label>
                                <input type="range" class="envelope-slider" id="releaseSlider" min="0" max="3000" value="1000" style="height:18px;">
                                <div class="slider-value" id="releaseValue" style="font-size:8px;">1000ms</div>
                            </div>
                        </div>
                    </div>
                    <div style="border:1px solid #4a6870; border-radius:4px; padding:8px; background:rgba(42,72,88,0.2);">
                        <h5 style="font-size:12px; margin-bottom:6px; color:#8fb3d3;">OSC 2</h5>
                        <div class="oscillator-controls" style="grid-template-columns:repeat(5,1fr); gap:2px; margin-bottom:6px;">
                            <div class="osc-btn active" data-wave="sine" data-osc="2" style="font-size:9px; padding:3px;">Sin</div>
                            <div class="osc-btn" data-wave="sawtooth" data-osc="2" style="font-size:9px; padding:3px;">Saw</div>
                            <div class="osc-btn" data-wave="square" data-osc="2" style="font-size:9px; padding:3px;">Sqr</div>
                            <div class="osc-btn" data-wave="triangle" data-osc="2" style="font-size:9px; padding:3px;">Tri</div>
                            <div class="osc-btn" data-wave="noise" data-osc="2" style="font-size:9px; padding:3px;">Nse</div>
                        </div>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px; margin-bottom:8px;">
                            <div class="slider-container">
                                <label style="font-size:9px;">Level</label>
                                <input type="range" class="synth-slider" id="osc2Level" min="0" max="10" value="5" style="height:20px;">
                                <div class="slider-value" id="osc2LevelValue" style="font-size:9px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Detune</label>
                                <input type="range" class="synth-slider" id="osc2Detune" min="-50" max="50" value="-7" style="height:20px;">
                                <div class="slider-value" id="osc2DetuneValue" style="font-size:9px;">-7¢</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Octave</label>
                                <input type="range" class="synth-slider" id="osc2Octave" min="-3" max="3" value="0" style="height:20px;">
                                <div class="slider-value" id="osc2OctaveValue" style="font-size:9px;">0</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Coarse</label>
                                <input type="range" class="synth-slider" id="osc2Coarse" min="-24" max="24" value="0" step="1" style="height:20px;">
                                <div class="slider-value" id="osc2CoarseValue" style="font-size:9px;">0 steps</div>
                            </div>
                        </div>
                        <h6 style="font-size:10px; margin:6px 0 4px 0; color:#f39c12;">ADSR 2</h6>
                        <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:3px;">
                            <div class="slider-container">
                                <label style="font-size:8px;">Attack</label>
                                <input type="range" class="envelope-slider" id="osc2AttackSlider" min="3" max="100" value="5" style="height:18px;">
                                <div class="slider-value" id="osc2AttackValue" style="font-size:8px;">5ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Decay</label>
                                <input type="range" class="envelope-slider" id="osc2DecaySlider" min="1" max="200" value="30" style="height:18px;">
                                <div class="slider-value" id="osc2DecayValue" style="font-size:8px;">30ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Sustain</label>
                                <input type="range" class="envelope-slider" id="osc2SustainSlider" min="0" max="10" value="5" style="height:18px;">
                                <div class="slider-value" id="osc2SustainValue" style="font-size:8px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Release</label>
                                <input type="range" class="envelope-slider" id="osc2ReleaseSlider" min="0" max="3000" value="1000" style="height:18px;">
                                <div class="slider-value" id="osc2ReleaseValue" style="font-size:8px;">1000ms</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="instrument">
        <!-- Root Notes at Top -->
        <div class="root-notes-area">
            <div class="root-notes-selector">
                <!-- Logo moved inside keyboard -->
                <div class="root-chord-grid" id="rootGrid"></div>
            </div>
        </div>

        <!-- Fretboard/Strings -->
        <div class="strum-area">
            <div class="extension-columns" id="extensionColumns"></div>
        </div>

    <!-- (Old control panel removed; controls moved into panelHost) -->

    <!-- Unified Chord Builder Modal -->
    <div id="chordBuilderModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 20px; border-radius: 10px; max-width: 95%; max-height: 95%; overflow-y: auto; width: 800px;">
            <h3 id="chordBuilderTitle">Enhanced Chord Builder</h3>
            
            <!-- Chord Name Input -->
            <div style="margin: 20px 0;">
                <label>Chord Name (flavor only, no root):</label>
                <input type="text" id="chordBuilderName" placeholder="e.g. maj7#11, min9, sus2add6" style="width: 300px; padding: 8px; margin-left: 10px; background: #2a4858; color: #fff; border: 1px solid #4a6870; border-radius: 4px;">
            </div>
            
            <!-- Chord Extensions Checkboxes -->
            <div style="margin: 20px 0;">
                <h4 style="margin: 0 0 10px 0; color: #4a90e2;">🎵 Diatonic Extensions (Select Multiple)</h4>
                <div id="chordExtensionsCheckboxes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 8px; margin-bottom: 15px; padding: 15px; border: 2px solid #4a6870; border-radius: 8px; background: rgba(0, 20, 40, 0.3);">
                    <!-- Extension checkboxes will be populated here -->
                </div>
            </div>
            
            <!-- Microtonal Intervals Section -->
            <div id="microtonalSection" style="margin: 20px 0;">
                <h4 style="margin: 0 0 10px 0; color: #27ae60;">🔍 Microtonal Intervals</h4>
                <div style="font-size: 12px; color: #8fb3d3; margin-bottom: 8px;">
                    <span style="color: #4a90e2;">�</span> Diatonic approximations &nbsp;
                    <span style="color: #27ae60;">�</span> Neutral/Xenharmonic &nbsp;
                    <span style="color: #f39c12;">�</span> Quarter-tone regions &nbsp;
                    <span style="color: #e74c3c;">�</span> Chromatic equivalents
                </div>
                <div id="microtonalCheckboxes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 6px; max-height: 300px; overflow-y: auto; padding: 15px; border: 2px solid #4a6870; border-radius: 8px; background: rgba(0, 20, 40, 0.3);">
                    <!-- Microtonal interval checkboxes will be populated here -->
                </div>
            </div>
            
            <!-- Preview Section -->
            <div style="margin: 20px 0; padding: 15px; border: 2px solid #8e44ad; border-radius: 8px; background: rgba(142, 68, 173, 0.1);">
                <h4 style="margin: 0 0 10px 0; color: #8e44ad;">🎧 Chord Preview</h4>
                <div id="chordPreviewDisplay" style="font-family: var(--retro-font); font-size: 14px; color: #8fb3d3; min-height: 40px; padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 4px;">
                    No intervals selected
                </div>
            </div>
            
            <!-- Favorites Section -->
            <div id="favoritesSection" style="margin: 20px 0; padding: 15px; border: 1px solid #4a6870; border-radius: 8px; background: rgba(42, 72, 88, 0.3);">
                <h4 style="margin: 0 0 10px 0; color: #f39c12;">? Favorite Chords</h4>
                <div id="chordBuilderFavoritesList" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 10px; min-height: 60px;">
                    <!-- Favorite chords will be populated here -->
                </div>
                <div style="font-size: 12px; color: #8fb3d3;">
                    Click any favorite to load its pattern into the builder
                </div>
            </div>
            
            <!-- Actions -->
            <div style="margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="osc-btn" id="closeChordBuilder">Close</button>
                <button class="osc-btn" id="saveChordBuilder" style="background: #27ae60;">✅ Save Chord</button>
                <button class="osc-btn" id="addToFavoritesBuilder" style="background: #f39c12;">★ Add to Favorites</button>
                <button class="osc-btn" id="previewChordBuilder" style="background: #8e44ad;">🔊 Preview</button>
                <button class="osc-btn" id="clearChordBuilder" style="background: #e74c3c;">❌ Clear</button>
            </div>
        </div>
    </div>

    <!-- Context menus removed for clean interface -->

    <!-- Edit Pattern Modal -->
    <div id="editPatternModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 20px; border-radius: 10px; max-width: 80%; max-height: 80%; overflow-y: auto;">
            <h3 id="editPatternTitle">Edit Note Pattern</h3>
            <div style="margin: 20px 0;">
                <label>Pattern Name:</label>
                <input type="text" id="editPatternName" style="width: 200px; padding: 5px; margin-left: 10px; background: #2a4858; color: #fff; border: 1px solid #4a6870; border-radius: 4px;">
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 10px;">Intervals from Root (semitones):</label>
                <div id="intervalEditor" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; margin-top: 10px;"></div>
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 10px;">Quick Patterns:</label>
                <div style="display: flex; gap: 5px; margin-top: 5px; flex-wrap: wrap;">
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7])">Major</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 3, 7])">Minor</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7, 10])">Dom7</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7, 11])">Maj7</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 3, 7, 10])">m7</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 2, 7])">Sus2</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 5, 7])">Sus4</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7, 9])">6th</button>
                </div>
            </div>
            <div style="margin-top: 20px;">
                <button class="osc-btn" id="closeEditPatternModal">Close</button>
                <button class="osc-btn" id="saveEditPattern">Save Pattern</button>
            </div>
        </div>
    </div>

    <!-- Chord Name Modal -->
    <div id="chordNameModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 30px; border-radius: 10px; min-width: 400px;">
            <h3 style="color: #8fb3d3; margin-bottom: 20px; text-align: center;">💾 Save Your Chord</h3>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: #8fb3d3;">Chord Name:</label>
                <input type="text" id="chordNameInput" placeholder="e.g. C, Dm, F?7, etc." style="width: 100%; padding: 10px; background: #2a4858; color: #fff; border: 2px solid #4a6870; border-radius: 6px; font-size: 16px;">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: #8fb3d3;">Selected Intervals:</label>
                <div id="selectedIntervalsDisplay" style="background: #2a4858; padding: 10px; border-radius: 6px; color: #fff; font-family: var(--retro-font);"></div>
            </div>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="osc-btn" id="cancelChordName" style="background: #666; border-color: #888;">Cancel</button>
                <button class="osc-btn" id="saveChordName" style="background: #2E8B57; border-color: #3CB371;">✅ Save Chord</button>
            </div>
        </div>
    </div>

    <!-- Tutorial Overlay -->
    <div id="tutorialOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999;">
        <div id="tutorialBox" style="position: fixed; top: 60px; left: 50%; transform: translateX(-50%); background: #1a1a2e; border: 2px solid #4a6870; border-radius: 10px; padding: 20px; max-width: 600px; max-height: 70vh; overflow-y: auto; z-index: 10000; box-shadow: 0 10px 30px rgba(0,0,0,0.8);">
            <h3 id="tutorialTitle" style="color: #8fb3d3; margin-top: 0;">Welcome to OMGnichord By James Mulvale / FASTFAST</h3>
            <p id="tutorialText" style="color: #fff; line-height: 1.5;">Click Next to start the tutorial.</p>
            <div style="margin-top: 15px; text-align: center; font-size: 12px; color: #8fb3d3; opacity: 0.9; background: rgba(74, 104, 112, 0.2); padding: 8px; border-radius: 5px;">
                💡 Press ESC, click outside, or use Skip Tutorial to exit anytime
            </div>
            <div style="margin-top: 20px; text-align: right;">
                <button id="tutorialPrev" class="osc-btn" style="margin-right: 10px;">Previous</button>
                <button id="tutorialNext" class="osc-btn">Next</button>
                <button id="tutorialSkip" class="osc-btn" style="margin-left: 10px; background: #dc2626;">Skip Tutorial</button>
            </div>
        </div>
    </div>

    <!-- Tutorial & Random Dice Buttons (moved top-right) -->
    <button id="tutorialButton" style="position: fixed; top: 12px; right: 14px; z-index: 9000; background: #4a6870; color: #fff; border: 2px solid #8fb3d3; border-radius: 50%; width: 56px; height: 56px; font-size: 24px; cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.4); font-weight: bold;" title="Start Tutorial">?</button>
    <button id="randomDiceButton" style="position: fixed; top: 82px; right: 14px; z-index: 9000; background: #6366f1; color: #fff; border: 2px solid #8b5cf6; border-radius: 50%; width: 56px; height: 56px; font-size: 24px; cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.45);" title="Randomize Settings">🎲</button>

    <script>
        // Disable all console output in production to improve performance
        (function(){
            try {
                var methods = ['log','info','debug','warn','error','trace','group','groupCollapsed','groupEnd','time','timeEnd','table'];
                if (typeof window !== 'undefined' && window.console) {
                    methods.forEach(function(m){ if (typeof window.console[m] === 'function') window.console[m] = function(){}; });
                }
            } catch(_) {}
        })();
        class MicrotonalOmnichord { 
            constructor() {
                this.audioContext = null;
                this.gainNode = null;
                this.activeOscillators = new Map();
                this.currentTuning = 12;
                this.intervalRatio = [2, 1]; // Default octave ratio
                this.currentRoot = 0;
                this.currentQuality = 'major';
                this.volume = 0.75; // Max volume at -9dB (matches slider at 100%)
                this.masterVolume = 0.708; // Max at -3dB (0.708 linear gain) instead of -6dB
                this.isPlayingStrings = false;
                this.triggeredStrings = new Set();
                this.activeTouches = new Map();
                this.gamelanMode = false;
                // Editing flow flags
                this.isEditingChord = false;
                this.editingOriginalIndex = null;
                
                // ADSR envelope settings
                this.envelope = {
                    attack: 0.01,
                    decay: 0.2,
                    sustain: 0.7,
                    release: 0.8
                };
                
                // OSC 2 ADSR envelope settings
                this.osc2Envelope = {
                    attack: 0.005,
                    decay: 0.03,
                    sustain: 0.5,
                    release: 1.0
                };
                
                this.oscillatorType = 'sawtooth';
                
                // Dual oscillator settings with proper dB scaling
                this.oscillators = {
                    osc1: { type: 'sine', detune: 0, level: 5 * 0.125 / 10, octave: 0, coarse: 0 }, // 50% slider = -18dB max
                    osc2: { type: 'sine', detune: -7, level: 5 * 0.125 / 10, octave: 0, coarse: 0 } // 50% slider = -18dB max
                };
                
                // Mix mode functionality removed
                
                // Store original UI state for piano lock system
                this.originalUIState = null;
                
                // Panning settings
                this.panning = {
                    mode: 'center', // 'center', 'frequency', 'random', 'rotating', 'alternating'
                    width: 0.8, // How wide the stereo field is
                    speed: 2000, // Speed for rotating/alternating modes (ms)
                    rotationAngle: 0, // Current rotation angle
                    alternateState: false // Current side for alternating
                };
                
                // Simple reverb settings
                this.reverb = {
                    wet: 0.01, // 1% reverb by default
                    decay: 2.0, // 2 seconds decay
                    roomSize: 0.5,
                    filterCutoff: 8000
                };
                
                // Audio nodes
                this.reverbNode = null;
                this.wetGainNode = null;
                this.dryGainNode = null;
                this.reverbFilterNode = null;
                
                // No default chord extensions - start completely empty unless locked chords exist
                this.defaultChordExtensions = [];
                
                // Load user's chord configuration and locked chords
                const savedChords = this.loadChordConfiguration();
                const lockedChords = this.loadLockedChords();
                
                // Clear unlocked chords from memory on first start - only load pre-locked chords
                console.log('?? Clearing unlocked chords from memory on startup');
                
                // Start with only locked chords (if any exist)
                if (lockedChords && lockedChords.length > 0) {
                    console.log('?? Loading only pre-locked chords from previous session:', lockedChords.length, 'chords');
                    this.chordExtensions = lockedChords.map(locked => ({
                        name: locked.chordName,
                        intervals: locked.intervals,
                        extensions: locked.extensions || [],
                        quality: locked.quality || 'custom',
                        isCustom: true,
                        isLocked: true,
                        lockedData: locked,
                        position: locked.originalPosition || 0
                    }));
                } else {
                    // No locked chords - start with basic Major chord for immediate use
                    console.log('?? No locked chords found - starting with basic Major chord');
                    this.chordExtensions = [{
                        name: 'Major',
                        intervals: [0, 4, 7], // Major triad: C-E-G in 12TET
                        description: 'Major triad',
                        symbol: '',
                        isCustom: false,
                        position: 0,
                        isPianoLocked: false,
                        pianoLockedData: null
                    }];
                }
                
                console.log('?? Loaded chord extensions:', this.chordExtensions.length, 'chords:', this.chordExtensions.map(c => c.name));
                
                // Custom chords storage - no localStorage, will use OMG files
                this.customChords = [];
                this.favoriteChords = [];
                
                // Initialize palette chords array - no localStorage
                this.paletteChords = [];
                
                // Initialize locked sonic chords array - stores complete snapshots - no localStorage
                this.lockedSonicChords = [];
                
                // Hidden columns for UI management - no localStorage
                this.hiddenColumns = [];
                
                // Initialize standard chord symbols for proper notation
                this.standardChordTypes = this.initializeStandardChordTypes();
                
                // Session data tracking
                this.sessionData = {
                    customChords: [],
                    favoriteChords: [],
                    paletteChords: [],
                    lockedSonicChords: [],
                    hiddenColumns: [],
                    chordExtensions: [],
                    lockedChords: [],
                    pianoLockedChords: [], // Piano lock system for oscillator settings
                    currentTuning: 12,
                    gamelanMode: false
                };
                
                // Initialize piano locked chords map with unique preset system
                this.pianoLockedChords = new Map();
                this.pianoLockPresetCounter = 0; // Incremental ID counter (ID001, ID002, etc.)
                this.preloadedPresets = new Map(); // Cache for instant preset switching
                
                // Migrate existing piano locks to new key format (without root)
                this.migratePianoLocksToNewFormat();
                
                // Chord creation mode
                this.chordCreationMode = false;
                this.selectedIntervals = [0]; // Root is always selected
                this.previewInterval = null;
                this.tempChordAudio = new Map(); // For preview audio
                
                // Clean up corrupted palette data
                this.cleanupPaletteData();
                
                this.initAudio();
                this.initEventListeners();
                this.generateRootButtons();
                this.generateExtensionColumns();
                
                // Ready for chord creation with New Chord button, but don't auto-enter chord mode
                console.log('?? Ready for chord creation - tuning and root can be changed freely');
                // DO NOT auto-enter chord creation mode - let user click "New Chord" when ready
                
                this.updateChordDisplay();
                this.setupSonicChords();
                this.initChordBuilder();
            }

            // Compute a subtle vibration period in ms for a given frequency and step index
            // Uses audio period (1/f) clamped to sensible range and snaps roots to wavelength series 1,2,4,8,16,32,64,128 as slower pulses
            computeVibrationPeriod(freq, stepIndex = 0) {
                const baseMs = Math.max(12, Math.min(90, 1000 / Math.max(1, freq))); // 12–90ms
                // Treat exact roots (interval 0) specially if the EDO step index equals currentRoot
                // We can't know the interval reliably here in all contexts; as a proxy: if stepIndex % currentTuning == currentRoot treat as root
                try {
                    const isRootish = ((stepIndex % this.currentTuning) === (this.currentRoot % this.currentTuning));
                    if (isRootish) {
                        // Map to one of 1..128 multipliers but cap to a gentle 32x to avoid too slow visuals
                        const multipliers = [1,2,4,8,16,32];
                        const idx = Math.min(multipliers.length - 1, Math.floor((freq || 1) / 110));
                        return Math.round(baseMs * multipliers[idx]);
                    }
                } catch {}
                return Math.round(baseMs);
            }

            // Initialize standard chord types with proper musical symbols
            initializeStandardChordTypes() {
                return [
                    // Triads
                    { name: '', symbol: '', intervals: [0, 4, 7], description: 'Major triad' },
                    { name: 'm', symbol: 'm', intervals: [0, 3, 7], description: 'Minor triad' },
                    { name: '°', symbol: '°', intervals: [0, 3, 6], description: 'Diminished triad' },
                    { name: '+', symbol: '+', intervals: [0, 4, 8], description: 'Augmented triad' },
                    { name: 'sus2', symbol: 'sus2', intervals: [0, 2, 7], description: 'Suspended 2nd' },
                    { name: 'sus4', symbol: 'sus4', intervals: [0, 5, 7], description: 'Suspended 4th' },
                    
                    // Seventh chords
                    { name: '7', symbol: '7', intervals: [0, 4, 7, 10], description: 'Dominant 7th' },
                    { name: 'M7', symbol: 'Δ7', intervals: [0, 4, 7, 11], description: 'Major 7th' },
                    { name: 'm7', symbol: 'm7', intervals: [0, 3, 7, 10], description: 'Minor 7th' },
                    { name: 'mM7', symbol: 'mΔ7', intervals: [0, 3, 7, 11], description: 'Minor major 7th' },
                    { name: '°7', symbol: '°7', intervals: [0, 3, 6, 9], description: 'Diminished 7th' },
                    { name: 'ø7', symbol: 'ø7', intervals: [0, 3, 6, 10], description: 'Half-diminished 7th' },
                    { name: '+7', symbol: '+7', intervals: [0, 4, 8, 10], description: 'Augmented 7th' },
                    
                    // Extended chords
                    { name: '9', symbol: '9', intervals: [0, 4, 7, 10, 14], description: 'Dominant 9th' },
                    { name: 'M9', symbol: 'Δ9', intervals: [0, 4, 7, 11, 14], description: 'Major 9th' },
                    { name: 'm9', symbol: 'm9', intervals: [0, 3, 7, 10, 14], description: 'Minor 9th' },
                    { name: '11', symbol: '11', intervals: [0, 4, 7, 10, 14, 17], description: 'Dominant 11th' },
                    { name: 'M11', symbol: 'Δ11', intervals: [0, 4, 7, 11, 14, 17], description: 'Major 11th' },
                    { name: 'm11', symbol: 'm11', intervals: [0, 3, 7, 10, 14, 17], description: 'Minor 11th' },
                    { name: '13', symbol: '13', intervals: [0, 4, 7, 10, 14, 17, 21], description: 'Dominant 13th' },
                    { name: 'M13', symbol: 'Δ13', intervals: [0, 4, 7, 11, 14, 17, 21], description: 'Major 13th' },
                    { name: 'm13', symbol: 'm13', intervals: [0, 3, 7, 10, 14, 17, 21], description: 'Minor 13th' },
                    
                    // Altered dominants
                    { name: '7♭5', symbol: '7♭5', intervals: [0, 4, 6, 10], description: 'Dominant 7 flat 5' },
                    { name: '7#5', symbol: '7♯5', intervals: [0, 4, 8, 10], description: 'Dominant 7 sharp 5' },
                    { name: '7♭9', symbol: '7♭9', intervals: [0, 4, 7, 10, 13], description: 'Dominant 7 flat 9' },
                    { name: '7#9', symbol: '7♯9', intervals: [0, 4, 7, 10, 15], description: 'Dominant 7 sharp 9' },
                    { name: '7♭5♭9', symbol: '7♭5♭9', intervals: [0, 4, 6, 10, 13], description: 'Dominant 7 flat 5 flat 9' },
                    { name: '7#5#9', symbol: '7♯5♯9', intervals: [0, 4, 8, 10, 15], description: 'Dominant 7 sharp 5 sharp 9' },
                    
                    // Add chords (no 3rd)
                    { name: 'add9', symbol: 'add9', intervals: [0, 4, 7, 14], description: 'Major add 9' },
                    { name: 'madd9', symbol: 'madd9', intervals: [0, 3, 7, 14], description: 'Minor add 9' },
                    { name: 'add11', symbol: 'add11', intervals: [0, 4, 7, 17], description: 'Major add 11' },
                    { name: 'madd11', symbol: 'madd11', intervals: [0, 3, 7, 17], description: 'Minor add 11' },
                    
                    // Slash chords (bass notes)
                    { name: '/3', symbol: '/3', intervals: [4, 0, 7], description: 'Major first inversion' },
                    { name: '/5', symbol: '/5', intervals: [7, 0, 4], description: 'Major second inversion' },
                    { name: 'm/♭3', symbol: 'm/♭3', intervals: [3, 0, 7], description: 'Minor first inversion' },
                    { name: 'm/5', symbol: 'm/5', intervals: [7, 0, 3], description: 'Minor second inversion' }
                ];
            }
            
            // Generate standard chord progressions for practice
            generateStandardChordProgression(rootNote = 'C', progressionType = 'ii-V-I') {
                const progressions = {
                    'ii-V-I': ['m7', '7', 'M7'],
                    'vi-IV-I-V': ['m', '', '', '7'],
                    'I-vi-IV-V': ['', 'm', '', '7'],
                    'blues': ['7', '7', '7', '7', '7', '7', '7', '7', '7', '7', '7', '7'],
                    'jazz-blues': ['M7', '7', 'M7', 'M7', '7', '7', 'M7', 'm7', 'm7', '7', 'M7', '7']
                };
                
                const progression = progressions[progressionType] || progressions['ii-V-I'];
                const chords = [];
                
                progression.forEach((chordSymbol, index) => {
                    const chordType = this.standardChordTypes.find(type => type.symbol === chordSymbol);
                    if (chordType) {
                        chords.push({
                            root: rootNote,
                            type: chordType,
                            symbol: rootNote + chordSymbol
                        });
                    }
                });
                
                return chords;
            }
            
            // Create basic chord set for beginners
            createBasicChordSet() {
                // User-requested basic chord set (only these, no others)
                const basicChords = [
                    { name: 'Major',        symbol: '',   intervals: [0,4,7],          description: 'Major triad' },
                    { name: 'Minor',        symbol: 'm',  intervals: [0,3,7],          description: 'Minor triad' },
                    { name: '7th',          symbol: '7',  intervals: [0,4,7,10],       description: 'Dominant 7th' },
                    { name: 'minor 7th',    symbol: 'm7', intervals: [0,3,7,10],       description: 'Minor 7th' },
                    { name: 'Major 7th',    symbol: 'M7', intervals: [0,4,7,11],       description: 'Major 7th' },
                    { name: '6th',          symbol: '6',  intervals: [0,4,7,9],        description: 'Major 6th' },
                    { name: '9th',          symbol: '9',  intervals: [0,4,7,10,14],    description: 'Dominant 9th' },
                    { name: 'sus4',         symbol: 'sus4', intervals:[0,5,7],         description: 'Suspended 4th' },
                    { name: 'sus2',         symbol: 'sus2', intervals:[0,2,7],         description: 'Suspended 2nd' },
                    { name: 'Diminished',   symbol: 'dim', intervals:[0,3,6],          description: 'Diminished triad' },
                    { name: 'Augmented',    symbol: 'aug', intervals:[0,4,8],          description: 'Augmented triad' }
                ];

                this.chordExtensions = basicChords.map(chord => ({
                    name: chord.name,
                    intervals: chord.intervals,
                    description: chord.description,
                    symbol: chord.symbol,
                    isCustom: false
                }));

                console.log('✓ Created requested basic chord set:', this.chordExtensions.length, 'chords');
                this.updateChordDisplay();
                this.generateExtensionColumns();
            }

            cleanupPaletteData() {
                // Clean up any corrupted palette chord data
                if (this.paletteChords && Array.isArray(this.paletteChords)) {
                    const originalLength = this.paletteChords.length;
                    this.paletteChords = this.paletteChords.filter(chord => {
                        return chord && typeof chord === 'object' && chord.name && chord.intervals;
                    });
                    
                    if (this.paletteChords.length !== originalLength) {
                        console.log('?? Cleaned up corrupted palette data:', originalLength, '->', this.paletteChords.length);
                        // localStorage removed - no longer saving palette chords
                    }
                } else {
                    console.log('?? Resetting corrupted palette data');
                    this.paletteChords = [];
                    // localStorage removed - no longer saving palette chords
                }
            }

            getTuningDisplayName() {
                if (this.gamelanMode) return 'Gamelan';
                switch(this.currentTuning) {
                    case 5: return '5-EDO';
                    case 7: return '7-EDO';
                    case 11: return 'C.Gamma';
                    case 12: return '12-TET';
                    case 15: return '15-EDO';
                    case 17: return '17-EDO';
                    case 19: return '19-TET';
                    case 22: return '22-TET';
                    case 24: return '24-TET';
                    case 31: return '31-TET';
                    case 34: return '34-TET';
                    case 53: return '53-TET';
                    default: return `${this.currentTuning}-TET`;
                }
            }

            // =============================================================================
            // UNIFIED CHORD BUILDER MODULE - Single source of truth for all chord creation
            // =============================================================================
            
            initChordBuilder() {
                // Simple chord builder initialization (removed custom patterns button)
                
                // New chord creation button
                document.getElementById('createNewChordBtn').addEventListener('click', () => {
                    if (this.chordCreationMode) {
                        // Save mode - automatically save with generated name
                        this.saveNewChordAutomatic();
                    } else {
                        // Create mode - enter creation mode
                        this.enterChordCreationMode();
                    }
                });
                
                // Basic chords creation button
                document.getElementById('createBasicChordsBtn').addEventListener('click', () => {
                    if (confirm('Load basic chord set? This will replace any existing unlocked chords.')) {
                        this.createBasicChordSet();
                    }
                });
                
                // Reset chords button
                document.getElementById('resetChordsBtn').addEventListener('click', () => {
                    if (confirm('Clear all unlocked chords? This will remove only unlocked chords, preserving all locked chords.')) {
                        this.clearUnlockedChords();
                    }
                });
                
                // Save session button
                document.getElementById('saveSessionBtn').addEventListener('click', () => {
                    this.saveSessionToFile();
                });
                
                // Load session button
                document.getElementById('loadSessionBtn').addEventListener('click', () => {
                    document.getElementById('loadSessionInput').click();
                });
                
                // File input for loading sessions
                document.getElementById('loadSessionInput').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.loadSessionFromFile(file)
                            .then(() => {
                                alert('Session loaded successfully!');
                            })
                            .catch((error) => {
                                alert('Error loading session: ' + error.message);
                            });
                    }
                });
                
                document.getElementById('edoDivisions').addEventListener('change', (e) => {
                    this.updateTuningSystem(parseInt(e.target.value));
                });
                
                document.getElementById('intervalRatio').addEventListener('change', (e) => {
                    this.updateIntervalRatio(e.target.value);
                });
            }
            
            // ============= NEW CHORD CREATION SYSTEM =============
            
            enterChordCreationMode() {
                console.log('?? Entering chord creation mode');
                this.chordCreationMode = true;
                // When entering fresh creation mode (not from edit), clear edit flags
                if (!this.isEditingChord) {
                    this.editingOriginalIndex = null;
                }
                // Always ensure root (0) present
                this.selectedIntervals = [0];
                this.previewInterval = null;
                
                // Change UI to creation mode
                document.body.classList.add('chord-creation-mode');
                
                // Add a preview chord column immediately
                this.addPreviewChordColumn();
                
                // Update create button to save mode
                const createBtn = document.getElementById('createNewChordBtn');
                createBtn.textContent = 'Save Chord';
                createBtn.style.background = '#e74c3c';
                createBtn.style.borderColor = '#c0392b';
                
                // Update root button behavior for interval selection
                if (typeof this.closeBottomPanel === 'function') this.closeBottomPanel();
                this.setupIntervalSelection();
            }
            
            exitChordCreationMode() {
                console.log('?? Exiting chord creation mode');
                this.chordCreationMode = false;
                this.isEditingChord = false;
                this.editingOriginalIndex = null;
                this.selectedIntervals = [0];
                this.previewInterval = null;
                
                // Stop any preview audio
                this.stopPreviewAudio();
                
                // Remove preview column if it exists
                this.removePreviewChordColumn();
                
                // Restore UI
                document.body.classList.remove('chord-creation-mode');
                
                // Restore create button
                const createBtn = document.getElementById('createNewChordBtn');
                createBtn.textContent = 'New Chord';
                createBtn.style.background = '#2E8B57';
                createBtn.style.borderColor = '#3CB371';
                
                // Restore normal root button behavior
                this.restoreNormalRootButtons();
            }
            
            setupIntervalSelection() {
                // Target all elements with data-step (keys + micro dots)
                const interactive = document.querySelectorAll('#rootGrid [data-step]');
                interactive.forEach(el => {
                    const step = parseInt(el.dataset.step,10);
                    // Replace node to remove previous listeners (root selection)
                    const clone = el.cloneNode(true);
                    el.parentNode.replaceChild(clone, el);
                    clone.classList.remove('preview');
                    // Maintain root highlight separately (active) but allow selection highlighting (selected)
                    if (this.selectedIntervals.includes(step)) clone.classList.add('selected'); else clone.classList.remove('selected');
                    clone.addEventListener('click', (e)=>{
                        e.stopPropagation();
                        this.toggleInterval(step);
                    });
                    clone.addEventListener('mouseenter', ()=> this.previewInterval(step));
                    clone.addEventListener('mouseleave', ()=> this.clearPreview());
                });
            }
            
            toggleInterval(interval) {
                if (interval === 0) return; // Root is always selected
                
                // In chord creation mode, button indices directly represent microtonal steps
                // No conversion needed since generateRootButtons() creates buttons for currentTuning
                const microtonalInterval = interval;
                
                const index = this.selectedIntervals.indexOf(microtonalInterval);
                if (index > -1) {
                    // Remove interval
                    this.selectedIntervals.splice(index, 1);
                } else {
                    // Add interval
                    this.selectedIntervals.push(microtonalInterval);
                    this.selectedIntervals.sort((a, b) => a - b);
                }
                
                // Update button states
                this.updateIntervalButtons();

                // Safety: ensure root still exists
                if(!this.selectedIntervals.includes(0)){
                    this.selectedIntervals.unshift(0);
                }
                
                // Update the preview chord column immediately
                this.updatePreviewChordColumn();
                
                console.log('🎵 Selected intervals (microtonal):', this.selectedIntervals);
                console.log('🎵 Button clicked (direct microtonal step):', interval);
            }
            
            previewInterval(interval) {
                // In chord creation mode, intervals are direct microtonal steps
                if (this.selectedIntervals.includes(interval)) return;
                
                this.previewInterval = interval;
                this.updateIntervalButtons();
                
                // Play single note preview using microtonal interval
                this.playNotePreview(interval);
            }
            
            clearPreview() {
                this.previewInterval = null;
                this.updateIntervalButtons();
                this.stopPreviewAudio();
            }
            
            updateIntervalButtons() {
                const all = document.querySelectorAll('#rootGrid [data-step]');
                all.forEach(el=>{
                    const step = parseInt(el.dataset.step,10);
                    el.classList.remove('selected','preview');
                    if (this.selectedIntervals.includes(step)) {
                        el.classList.add('selected');
                    } else if (this.previewInterval === step) {
                        el.classList.add('preview');
                    }
                });
            }
            
            playNotePreview(interval) {
                this.stopPreviewAudio();
                
                if (!this.audioContext) return;
                
                const frequency = this.getFrequency(interval, 0, this.currentTuning); // Use current root and explicitly pass currentTuning
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.1, this.audioContext.currentTime + 0.05);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.3);
                
                this.tempChordAudio.set('preview', { oscillator, gainNode });
            }
            
            playChordPreview() {
                this.stopPreviewAudio();
                
                if (!this.audioContext || this.selectedIntervals.length === 0) return;
                
                // Play all selected intervals as a chord
                this.selectedIntervals.forEach((interval, index) => {
                    const frequency = this.getFrequency(interval, 0, this.currentTuning);
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.05, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 1.0);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 1.0);
                    
                    this.tempChordAudio.set(`chord-${index}`, { oscillator, gainNode });
                });
            }
            
            stopPreviewAudio() {
                this.tempChordAudio.forEach(({ oscillator, gainNode }) => {
                    try {
                        gainNode.gain.setValueAtTime(gainNode.gain.value, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.05);
                        oscillator.stop(this.audioContext.currentTime + 0.05);
                    } catch (e) {
                        // Oscillator might already be stopped
                    }
                });
                this.tempChordAudio.clear();
            }
            
            saveNewChordAutomatic() {
                if (this.selectedIntervals.length < 2) {
                    alert('Please select at least 2 intervals (including root)');
                    return;
                }
                
                // Generate chord name automatically from the preview (quality only, no root)
                let chordName = this.generateChordName(this.selectedIntervals);
                
                // Ensure no root note prefix is included (just in case)
                chordName = chordName.replace(/^[A-G][#b]?\s*/, '');
                
                console.log(`?? Auto-saving chord quality (no root): "${chordName}" with intervals:`, this.selectedIntervals);
                
                // Convert the preview column to a permanent chord
                this.finalizePreviewChord(chordName);
                
                console.log(`?? Auto-saved new chord: ${chordName}`, this.selectedIntervals);
                
                // Exit creation mode
                this.exitChordCreationMode();
            }
            
            saveNewChord() {
                let chordName = document.getElementById('chordNameInput').value.trim();
                
                if (!chordName) {
                    alert('Please enter a chord name');
                    return;
                }
                
                if (this.selectedIntervals.length < 2) {
                    alert('Please select at least 2 intervals (including root)');
                    return;
                }
                
                // Remove any root note prefix from the chord name (e.g., "Cm6" becomes "m6")
                // This ensures we save only the quality/extension part
                chordName = chordName.replace(/^[A-G][#b]?\s*/, '');
                
                // If the name becomes empty after removing root, use generated name
                if (!chordName) {
                    chordName = this.generateChordName(this.selectedIntervals);
                }
                
                console.log(`?? Saving chord quality (no root): "${chordName}" with intervals:`, this.selectedIntervals);
                
                // Convert the preview column to a permanent chord
                this.finalizePreviewChord(chordName);
                
                console.log(`?? Saved new chord: ${chordName}`, this.selectedIntervals);
                alert(`Chord "${chordName}" saved successfully! Root will be added when locked.`);
                
                // Exit creation mode
                this.exitChordCreationMode();
            }
            
            addPreviewChordColumn() {
                // Create a temporary preview chord column at the end
                const extensionColumns = document.getElementById('extensionColumns');
                if (!extensionColumns) return;
                
                const previewColumn = document.createElement('div');
                previewColumn.className = 'extension-column preview-chord-column';
                previewColumn.id = 'previewChordColumn';
                previewColumn.style.border = '3px dashed #2E8B57';
                previewColumn.style.background = 'rgba(46, 139, 87, 0.1)';
                
                // Add header
                const header = document.createElement('div');
                header.className = 'extension-header';
                header.style.background = 'rgba(46, 139, 87, 0.8)';
                header.innerHTML = '<span class="chord-name">New Chord</span>';
                previewColumn.appendChild(header);
                
                // Add strings container
                const stringsContainer = document.createElement('div');
                stringsContainer.className = 'strings-column';
                stringsContainer.id = 'previewStringsContainer';
                previewColumn.appendChild(stringsContainer);
                
                // Add note labels
                const noteLabels = document.createElement('div');
                noteLabels.className = 'note-labels';
                noteLabels.id = 'previewNoteLabels';
                previewColumn.appendChild(noteLabels);
                
                extensionColumns.appendChild(previewColumn);
                
                // Add touch gesture support for strumming the preview chord
                this.addTouchGestureToElement(previewColumn, 'chord');
                this.addClickGestureToElement(previewColumn, 'chord');
                
                // Initial update with root note
                this.updatePreviewChordColumn();
            }
            
            updatePreviewChordColumn() {
                const stringsContainer = document.getElementById('previewStringsContainer');
                const noteLabels = document.getElementById('previewNoteLabels');
                const header = document.querySelector('#previewChordColumn .chord-name');
                
                if (!stringsContainer || !noteLabels || !header) return;
                
                // Clear existing strings
                stringsContainer.innerHTML = '';
                
                // Generate chord name based on intervals
                const chordName = this.generateChordName(this.selectedIntervals);
                header.textContent = chordName;
                
                // Use the same string generation as the main fretboard
                this.generateStringsForPreviewColumn(stringsContainer, this.selectedIntervals);
                
                // Update note labels
                const noteNames = this.selectedIntervals.map(interval => {
                    return this.getMicrotonalNoteName((this.currentRoot + interval) % this.currentTuning);
                });
                noteLabels.textContent = noteNames.join(' ');
            }
            
            generateStringsForPreviewColumn(container, intervals) {
                // Clear any existing content
                container.innerHTML = '';
                
                // Use the EXACT same system as generateStringsForColumn 
                const noteNames = this.getNoteNames();
                const tuningSize = this.currentTuning || this.getTuningStepsPerOctave();
                
                // Generate string frequencies for full C1-C8 octave range (8 full octaves)
                const stringFreqs = [];
                for (let octave = 1; octave <= 8; octave++) {
                    intervals.forEach(interval => {
                        // Intervals are already in microtonal format (EDO steps), use directly
                        const step = (this.currentRoot + interval) % tuningSize;
                        const freq = this.getFrequency(step, octave, this.currentTuning);
                        stringFreqs.push({ freq, step, octave, interval });
                    });
                }
                
                // Sort by frequency to ensure proper ordering
                stringFreqs.sort((a, b) => a.freq - b.freq);
                
                // Calculate string sizing to MATCH main column behavior (fill height uniformly)
                const previewColumn = document.getElementById('previewChordColumn');
                const availableHeight = (previewColumn ? previewColumn.offsetHeight : 500);
                const headerHeight = 40;
                const stringsHeight = availableHeight - headerHeight - 2; // minimal padding
                const numStrings = stringFreqs.length || 1;
                const stringHeight = Math.max(1, Math.floor(stringsHeight / numStrings) - 0.5);
                const stringMargin = 0.2; // minimal margin for tight packing
                
                // Style the container exactly like main columns
                container.style.cssText = `
                    flex: 1;
                    overflow: hidden;
                    padding: 1px;
                    height: calc(100% - ${headerHeight}px);
                    display: flex;
                    flex-direction: column;
                    justify-content: space-evenly;
                `;
                
                stringFreqs.forEach((stringData, stringIndex) => {
                    const stringEl = document.createElement('div');
                    stringEl.className = 'string';
                    stringEl.dataset.index = stringIndex;
                    stringEl.dataset.column = 'preview';
                    stringEl.dataset.frequency = stringData.freq;
                    stringEl.dataset.noteIndex = stringData.step;

                    // Interval color and glow
                    const intervalColor = this.getIntervalColor(stringData.interval);
                    const baseColor = intervalColor.color;
                    const glowColor = (baseColor && baseColor.toLowerCase() === '#000000') ? '#555555' : baseColor;
                    stringEl.dataset.glowColor = glowColor;

                    // Visible core
                    const core = document.createElement('div');
                    core.className = 'string-core';
                    core.style.background = baseColor;
                    core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;

                    // Tooltip
                    stringEl.title = `${intervalColor.name} - ${noteNames[stringData.step] || `Note ${stringData.step}`} - Oct${stringData.octave} - ${stringData.freq.toFixed(1)}Hz`;

                    // Hover effects
                    stringEl.addEventListener('mouseenter', () => {
                        core.style.transform = 'scaleY(1.25)';
                        core.style.boxShadow = `0 0 6px ${glowColor}, 0 0 14px ${glowColor}CC, 0 0 28px ${glowColor}88`;
                    });
                    stringEl.addEventListener('mouseleave', () => {
                        core.style.transform = 'scaleY(1)';
                        core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;
                    });

                    // Click handlers
                    stringEl.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        this.playPreviewString(stringEl, stringData.freq, stringData.interval);
                    });
                    stringEl.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.playPreviewString(stringEl, stringData.freq, stringData.interval);
                    });

                    // Attach core and row
                    stringEl.appendChild(core);
                    container.appendChild(stringEl);

                    // Precompute vibration period and store on core
                    const period = this.computeVibrationPeriod(stringData.freq, stringData.step);
                    core.style.setProperty('--vib-period', period + 'ms');
                });
                // Ensure all generated octave strings fit within visible area (rescale heights if needed)
                this.ensureStringsFullyVisible(container);
            }
            
            playPreviewString(stringElement, frequency, interval) {
                // Neon active feedback using per-string glow color
                const glow = stringElement.dataset.glowColor || this.getIntervalColor(interval).color || '#FFFFFF';
                const core = stringElement.querySelector('.string-core');
                if (core) {
                    core.style.transform = 'scaleY(1.3)';
                    core.style.boxShadow = `0 0 6px ${glow}, 0 0 16px ${glow}B3, 0 0 24px ${glow}80`;
                    core.style.filter = 'brightness(1.15)';
                    // Start vibration briefly for preview
                    const period = this.computeVibrationPeriod(frequency, parseInt(stringElement.dataset.noteIndex||'0',10));
                    core.style.setProperty('--vib-period', period + 'ms');
                    core.classList.add('vibrating');
                    setTimeout(()=> core.classList.remove('vibrating'), 220);
                }

                // Play the note using the same system as main strings
                this.playStringNote(frequency, interval);

                // Reset visual state after a delay
                setTimeout(() => {
                    if (core) {
                        core.style.transform = 'scaleY(1)';
                        core.style.boxShadow = `0 0 4px ${glow}, 0 0 10px ${glow}AA, 0 0 18px ${glow}66`;
                        core.style.filter = 'brightness(1)';
                    }
                }, 200);
            }
            
            playStringNote(frequency, interval) {
                if (!this.audioContext) return;
                
                // Use the current oscillator and envelope settings
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                // Apply current oscillator settings
                oscillator.type = this.oscillators.osc1.type;
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                
                // Apply current ADSR envelope
                const now = this.audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(this.volume * this.masterVolume, now + this.envelope.attack);
                gainNode.gain.exponentialRampToValueAtTime(this.volume * this.masterVolume * this.envelope.sustain, now + this.envelope.attack + this.envelope.decay);
                
                // Connect through reverb if enabled
                oscillator.connect(gainNode);
                if (this.reverb.wet > 0) {
                    gainNode.connect(this.reverbNode || this.gainNode);
                } else {
                    gainNode.connect(this.gainNode);
                }
                
                oscillator.start();
                oscillator.stop(now + this.envelope.attack + this.envelope.decay + this.envelope.release);
                
                // Store for cleanup
                this.tempChordAudio.set(`preview-${Date.now()}`, { oscillator, gainNode });
            }
            
            removePreviewChordColumn() {
                const previewColumn = document.getElementById('previewChordColumn');
                if (previewColumn) {
                    previewColumn.remove();
                }
            }
            
            finalizePreviewChord(chordName) {
                // Remove the preview column
                this.removePreviewChordColumn();
                
                // Generate proper chord name with current root if not provided
                if (!chordName || chordName.trim() === '') {
                    const baseChordName = this.generateChordName(this.selectedIntervals);
                    const rootNote = this.getNoteNames()[this.currentRoot];
                    chordName = `${rootNote}${baseChordName}`;
                }
                
                // Decide target position
                const replacing = !!this.isEditingChord && typeof this.editingOriginalIndex === 'number' && this.editingOriginalIndex >= 0;
                const position = replacing ? this.editingOriginalIndex : this.chordExtensions.length;

                // Decide a persistent header accent color for this chord (per-chord color)
                // Use the current root neon color as the chord's header accent, with a safe fallback
                let headerAccentColor = '#14b8a6';
                try {
                    const c = this.getIntervalColor(0)?.color;
                    headerAccentColor = (!c || c.toLowerCase() === '#000000') ? '#333333' : c;
                } catch {}
                
                // Preserve existing chord metadata if editing in place
                let preserved = {};
                if (replacing && this.chordExtensions[position]) {
                    const oldChord = this.chordExtensions[position];
                    preserved = {
                        id: oldChord.id,
                        createdAt: oldChord.createdAt,
                        headerColor: oldChord.headerColor,
                        originalTuning: oldChord.originalTuning,
                        originalGamelanMode: oldChord.originalGamelanMode,
                        lastTuning: oldChord.lastTuning
                    };
                }

                // Create new chord extension with exact intervals and position tracking
                const newChord = {
                    name: chordName,
                    extensions: [],
                    intervals: [...this.selectedIntervals],
                    isCustom: true,
                    id: preserved.id || ('custom_' + Date.now()),
                    createdAt: preserved.createdAt || Date.now(),
                    position: position, // Track exact position in array
                    // Keep the original root for reference but don't auto-lock
                    originalRoot: this.currentRoot,
                    // Track tuning metadata to support future remaps between EDOs
                    originalTuning: preserved.originalTuning || this.currentTuning,
                    originalGamelanMode: preserved.originalGamelanMode ?? this.gamelanMode,
                    lastTuning: this.currentTuning,
                    // Persist a header color so saved chords can keep distinct colors
                    headerColor: preserved.headerColor || headerAccentColor
                };
                
                console.log('🔧 finalizePreviewChord - saving chord:', {
                    name: chordName,
                    intervals: [...this.selectedIntervals],
                    isCustom: true,
                    currentTuning: this.currentTuning,
                    selectedIntervals: this.selectedIntervals
                });
                
                // Add to chord extensions: replace original index when editing, else append
                if (replacing) {
                    // Replace in place to preserve column position and identity
                    this.chordExtensions.splice(position, 1, newChord);
                } else {
                    this.chordExtensions.push(newChord);
                }

                // Normalize positions to keep exact ordering stable
                this.normalizeChordPositions();
                
                // Save and regenerate without creating variants
                this.saveChordConfiguration();
                this.regenerateColumnsWithoutVariants();
                
                // Clear selection and exit chord creation mode
                this.selectedIntervals = [];
                this.isChordCreationMode = false;
                this.isEditingChord = false;
                this.editingOriginalIndex = null;
                
                // Restore normal root button functionality
                this.restoreNormalRootButtons();
                
                console.log(`? Created chord: ${chordName} at position ${position} with intervals:`, this.selectedIntervals);
            }

            // Keep chord.position fields in sync with array order
            normalizeChordPositions() {
                if (!Array.isArray(this.chordExtensions)) return;
                for (let i = 0; i < this.chordExtensions.length; i++) {
                    const c = this.chordExtensions[i];
                    if (c && c.position !== i) c.position = i;
                }
            }
            
            regenerateColumnsWithoutVariants() {
                // Regenerate only the exact chords without creating maj/min/neu variants
                this.generateExactChordColumns();
                this.updateChordDisplay();
            }
            
            generateExactChordColumns() {
                console.log('Generating exact chord columns (no variants)');
                const container = document.getElementById('extensionColumns');
                
                // Clear container completely to remove any leftover columns
                container.innerHTML = '';
                container.style.display = 'flex';
                container.style.gap = '0px';
                container.style.width = '100%';
                container.style.height = '100%';
                
                // Initialize hiddenColumns if not exists
                if (!this.hiddenColumns) {
                    this.hiddenColumns = [];
                }
                
                // Sort chordExtensions by position to maintain exact order
                const sortedExtensions = [...this.chordExtensions].sort((a, b) => {
                    const posA = a.position !== undefined ? a.position : this.chordExtensions.indexOf(a);
                    const posB = b.position !== undefined ? b.position : this.chordExtensions.indexOf(b);
                    return posA - posB;
                });
                
                // Map chord extensions to identifiers for hiding
                const chordIds = sortedExtensions.map((chord, index) => {
                    const id = chord.name.toLowerCase().replace(/\s+/g, '_');
                    return id;
                });
                
                // Filter visible chord extensions (maintain original order)
                const visibleExtensions = sortedExtensions.filter((chordExt, index) => {
                    const chordId = chordIds[index];
                    const isVisible = !this.hiddenColumns.includes(chordId);
                    return isVisible;
                });
                
                console.log('Creating exact chord columns:', visibleExtensions.length);
                
                // Create ONE column per chord extension (no variants) - maintain exact order
                visibleExtensions.forEach((chordExt, extensionIndex) => {
                    const column = document.createElement('div');
                    column.className = 'extension-column';
                    column.dataset.chordType = chordIds[extensionIndex];
                    // Persist absolute index back to the original array for precise operations
                    const absoluteIndex = (typeof chordExt.position === 'number') ? chordExt.position : (this.findChordIndex ? this.findChordIndex(chordExt) : extensionIndex);
                    column.dataset.originalPosition = absoluteIndex;
                    column.dataset.chordId = chordExt.id || chordIds[extensionIndex];
                    column.style.flex = '1'; // Each column takes equal width
                    column.style.height = '100%';
                    column.style.border = 'none';
                    column.style.borderRadius = '0';
                    column.style.margin = '0';
                    column.style.padding = '0';
                    
                    // Create header with chord name and lock button
                    const header = document.createElement('div');
                    header.className = 'extension-header';
                    
                    // Create chord name span
                    const chordName = document.createElement('span');
                    chordName.className = 'chord-name';
                    
                    // Check if this chord extension is locked and preserve its locked name
                    if (chordExt.isLocked && chordExt.lockedData) {
                        const lockedData = chordExt.lockedData;
                        const rootName = this.getNoteNames()[lockedData.lockedRoot] || lockedData.lockedRoot;
                        
                        // Use the locked name exactly as it was when locked
                        if (lockedData.chordName.match(/^[A-G][#b]?/)) {
                            chordName.textContent = lockedData.chordName;
                        } else {
                            chordName.textContent = `${rootName}${lockedData.chordName}`;
                        }
                        
                        chordName.style.color = '#4CAF50';
                        chordName.style.fontWeight = 'bold';
                        chordName.dataset.isLocked = 'true';
                        chordName.dataset.lockedName = chordName.textContent;
                        chordName.title = `?? LOCKED: ${rootName} root, ${lockedData.lockedTuning}TET, ${lockedData.lockedOsc1.type}/${lockedData.lockedOsc2.type} waves`;
                    } else {
                        // Regular unlocked chord - use current name
                        chordName.textContent = chordExt.name;
                    }
                    
                    // Create lock button
                    const lockButton = document.createElement('button');
                    lockButton.className = 'lock-button';
                    
                    // Set lock button state based on whether chord is locked
                    if (chordExt.isLocked && chordExt.lockedData) {
                        lockButton.innerHTML = '🔒';
                        lockButton.classList.add('locked');
                        const rootName = this.getNoteNames()[chordExt.lockedData.lockedRoot] || chordExt.lockedData.lockedRoot;
                        lockButton.title = `LOCKED to ${rootName} root with all settings - click to unlock`;
                    } else {
                        lockButton.innerHTML = '🔓';
                        lockButton.title = 'Lock complete sonic snapshot';
                    }
                    
                    // Add lock button functionality
                    lockButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.lockSonicChord(chordExt, column);
                    });
                    
                    // Add touchstart for mobile compatibility
                    lockButton.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.lockSonicChord(chordExt, column);
                    });
                    
                    // Create piano lock button for oscillator/effect settings
                    const pianoLockButton = document.createElement('button');
                    pianoLockButton.className = 'piano-lock-button';
                    
                    // Set piano lock button state based on whether oscillator settings are locked
                    if (chordExt.isPianoLocked && chordExt.pianoLockedData) {
                        pianoLockButton.innerHTML = '🎹';
                        pianoLockButton.classList.add('locked');
                        pianoLockButton.title = 'LOCKED oscillator & effect settings - click to unlock';
                    } else {
                        pianoLockButton.innerHTML = '🎹';
                        pianoLockButton.title = 'Lock oscillator & effect settings only';
                    }
                    
                    // Add piano lock button functionality
                    pianoLockButton.addEventListener('click', (e) => {
                        console.log('🎹 Piano lock button CLICKED!', 'chordExt:', chordExt, 'column:', column);
                        console.log('🎹 this.lockPianoSettings:', typeof this.lockPianoSettings);
                        e.preventDefault();
                        e.stopPropagation();
                        try {
                            // If column is undefined, find the closest column element
                            const actualColumn = column || e.target.closest('.extension-column');
                            this.lockPianoSettings(chordExt, actualColumn);
                        } catch (error) {
                            console.error('🎹 Error calling lockPianoSettings:', error);
                        }
                    });
                    
                    // Add touchstart for mobile compatibility
                    pianoLockButton.addEventListener('touchstart', (e) => {
                        console.log('🎹 Piano lock button TOUCHED!', 'chordExt:', chordExt, 'column:', column);
                        console.log('🎹 this.lockPianoSettings:', typeof this.lockPianoSettings);
                        e.preventDefault();
                        e.stopPropagation();
                        try {
                            // If column is undefined, find the closest column element
                            const actualColumn = column || e.target.closest('.extension-column');
                            this.lockPianoSettings(chordExt, actualColumn);
                        } catch (error) {
                            console.error('🎹 Error calling lockPianoSettings:', error);
                        }
                    });
                    
                    // Create buttons container
                    const buttonsContainer = document.createElement('div');
                    buttonsContainer.className = 'header-buttons';
                    
                    // Create action buttons (always visible) with unique IDs
                    const editButton = document.createElement('button');
                    editButton.className = 'chord-action-button edit';
                    editButton.id = `edit-btn-${chordExt.id || chordExt.name.replace(/\s+/g, '_')}-${extensionIndex}`;
                    editButton.innerHTML = '✏️';
                    editButton.title = 'Edit chord intervals';
                    editButton.style.display = 'flex';
                    
                    // Delete button removed — delete via upward drag
                    
                    const duplicateButton = document.createElement('button');
                    duplicateButton.className = 'chord-action-button duplicate';
                    duplicateButton.id = `duplicate-btn-${chordExt.id || chordExt.name.replace(/\s+/g, '_')}-${extensionIndex}`;
                    duplicateButton.innerHTML = '📋';
                    duplicateButton.title = 'Duplicate and edit';
                    duplicateButton.style.display = 'flex';
                    
                    // Add button event listeners with proper chord data closure
                    editButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('🔧 Edit button clicked for chord:', chordExt.name, 'Button ID:', editButton.id);
                        console.log('🔧 Full chordExt object:', chordExt);
                        
                        // Create a deep copy of chord data to ensure it's preserved
                        const chordDataForEdit = {
                            name: chordExt.name,
                            intervals: chordExt.intervals || this.getBaseTriadForQuality(this.stripRootFromName(chordExt.name).toLowerCase()),
                            isCustom: chordExt.isCustom || false,
                            id: chordExt.id || `${chordExt.name}_${extensionIndex}`,
                            originalChord: chordExt
                        };
                        
                        console.log('🔧 Complete chord data for editing:', chordDataForEdit);
                        this.editChordFromButton(chordDataForEdit, column);
                    });
                    
                    editButton.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('🔧 Edit button touched for chord:', chordExt.name, 'Button ID:', editButton.id);
                        
                        // Create a deep copy of chord data to ensure it's preserved
                        const chordDataForEdit = {
                            name: chordExt.name,
                            intervals: chordExt.intervals || this.getBaseTriadForQuality(this.stripRootFromName(chordExt.name).toLowerCase()),
                            isCustom: chordExt.isCustom || false,
                            id: chordExt.id || `${chordExt.name}_${extensionIndex}`,
                            originalChord: chordExt
                        };
                        
                        this.editChordFromButton(chordDataForEdit, column);
                    });
                    
                    
                    duplicateButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const chordDataForDupe = {
                            name: chordExt.name,
                            intervals: chordExt.intervals || this.getBaseTriadForQuality(this.stripRootFromName(chordExt.name).toLowerCase()),
                            isCustom: chordExt.isCustom || false,
                            id: chordExt.id || `${chordExt.name}_${extensionIndex}`,
                            originalChord: chordExt
                        };
                        
                        this.duplicateChordFromButton(chordDataForDupe, column);
                    });
                    
                    duplicateButton.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const chordDataForDupe = {
                            name: chordExt.name,
                            intervals: chordExt.intervals || this.getBaseTriadForQuality(this.stripRootFromName(chordExt.name).toLowerCase()),
                            isCustom: chordExt.isCustom || false,
                            id: chordExt.id || `${chordExt.name}_${extensionIndex}`,
                            originalChord: chordExt
                        };
                        
                        this.duplicateChordFromButton(chordDataForDupe, column);
                    });
                    
                    // Add buttons to container
                    buttonsContainer.appendChild(editButton);
                    buttonsContainer.appendChild(duplicateButton);
                    buttonsContainer.appendChild(lockButton);
                    buttonsContainer.appendChild(pianoLockButton);
                    
                    header.appendChild(chordName);
                    header.appendChild(buttonsContainer);
                    
                    // Color coding based on chord type
                    let qualityColor;
                    if (chordExt.name === 'Major') {
                        qualityColor = { bg: '#1e40af', border: '#3b82f6' };
                    } else if (chordExt.name === 'Neutral') {
                        qualityColor = { bg: '#059669', border: '#10b981' };
                    } else if (chordExt.name === 'Minor') {
                        qualityColor = { bg: '#dc2626', border: '#ef4444' };
                    } else if (chordExt.isCustom) {
                        // Custom chords get purple coloring
                        qualityColor = { bg: '#7c3aed', border: '#8b5cf6' };
                    } else {
                        // Default coloring for other chord types
                        qualityColor = { bg: '#374151', border: '#6b7280' };
                    }
                    
                    header.style.backgroundColor = qualityColor.bg;
                    header.style.borderColor = qualityColor.border;
                    header.style.color = 'white';
                    header.style.border = `1px solid ${qualityColor.border}`;

                    // Then apply root-based accent per chromatic palette (locked uses locked root)
                    try {
                        const isLocked = !!chordExt.isLocked && !!chordExt.lockedData;
                        const rootStep = isLocked ? (chordExt.lockedData.lockedRoot ?? 0) : (this.currentRoot ?? 0);
                        const semi = this.stepToSemitone(rootStep, this.currentTuning || 12);
                        const accent = this.getChromaticColorForSemitone(semi);
                        const text = this.pickTextColor(accent);
                        header.style.background = accent;
                        header.style.borderBottom = `2px solid ${accent}`;
                        header.style.boxShadow = `0 0 10px ${accent}55`;
                        header.style.color = text;
                    } catch {}
                    
                    // Add context menu handlers - REMOVED for clean interface
                    header.addEventListener('click', (e) => {
                        // Don't interfere with lock button clicks
                        if (e.target.classList.contains('lock-button')) {
                            return; // Let the lock button handle its own click
                        }
                        
                        console.log('?? Chord header clicked:', chordExt.name);
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Context menus removed - no action taken
                    });
                    
                    // Color the header per fixed chromatic palette: unlocked follows current root; locked uses locked root
                    try {
                        const isLocked = !!chordExt.isLocked && !!chordExt.lockedData;
                        const rootStep = isLocked ? (chordExt.lockedData.lockedRoot ?? 0) : (this.currentRoot ?? 0);
                        const semi = this.stepToSemitone(rootStep, this.currentTuning || 12);
                        const accent = this.getChromaticColorForSemitone(semi);
                        const text = this.pickTextColor(accent);
                        header.style.background = accent;
                        header.style.borderBottom = `2px solid ${accent}`;
                        header.style.boxShadow = `0 0 10px ${accent}55`;
                        header.style.color = text;
                    } catch {}

                    column.appendChild(header);
                    
                    // Generate chord intervals and strings
                    const intervals = chordExt.intervals || this.getBaseTriadForQuality(chordExt.name.toLowerCase());
                    
                    // If this chord is locked, generate strings using its locked settings
                    if (chordExt.isLocked && chordExt.lockedData) {
                        console.log('?? Generating strings with locked settings for:', chordExt.name);
                        this.generateStringsForColumnWithLockedSettings(column, intervals, chordExt.lockedData);
                    } else {
                        // Regular chord - use current global settings
                        this.generateStringsForColumn(column, intervals, chordExt.isCustom);
                    }
                    
                    // Ensure columns generated via the exact path are draggable
                    if (this.attachColumnDragHandlers) {
                        this.attachColumnDragHandlers(column);
                    }
                    container.appendChild(column);
                });
                
                // Add click handlers and restore locked chord states after rendering
                setTimeout(() => {
                    console.log('?? generateExactChordColumns finished, adding click handlers and restoring locked states...');
                    this.addSimpleClickHandlers();
                    this.restoreLockedChordStates(); // Restore locked chord states
                    console.log('?? Exact chord columns: click handlers and locked states restored!');
                }, 100);
            }
            
            generateStringsForColumnWithLockedSettings(column, intervals, lockedData) {
                console.log('?? Generating strings with locked settings:', lockedData.chordName, 'locked root:', lockedData.lockedRoot);
                
                // Check if we have exact frequencies captured - use those for perfect reproduction
                if (lockedData.exactFrequencies && lockedData.exactFrequencies.length > 0) {
                    console.log(`?? Using ${lockedData.exactFrequencies.length} exact captured frequencies for perfect reproduction`);
                    this.generateStringsWithExactFrequencies(column, lockedData);
                    return; // Skip the rest of this method
                }
                
                console.log('?? No exact frequencies found, falling back to tuning-based generation');
                
                // Store current settings to restore later
                const originalSettings = {
                    currentRoot: this.currentRoot,
                    currentTuning: this.currentTuning,
                    gamelanMode: this.gamelanMode,
                    volume: this.volume,
                    masterVolume: this.masterVolume
                };
                
                // Temporarily apply locked settings for string generation
                this.currentRoot = lockedData.lockedRoot;
                this.currentTuning = lockedData.lockedTuning;
                this.gamelanMode = lockedData.lockedGamelanMode;
                this.volume = lockedData.lockedVolume.main;
                this.masterVolume = lockedData.lockedVolume.master;
                
                // Generate strings with locked settings
                this.generateStringsForColumn(column, intervals, lockedData.isCustom);
                
                // Store the locked root in the column's data attribute for reference during playback
                column.dataset.lockedRoot = lockedData.lockedRoot;
                
                // Add a visual indicator that this column is locked to a specific root
                const header = column.querySelector('.extension-header');
                if (header) {
                    const rootName = this.getNoteNames()[lockedData.lockedRoot] || lockedData.lockedRoot;
                    const chordName = header.querySelector('.chord-name');
                    if (chordName) {
                        // Update the header to show it's locked to a specific root
                        chordName.textContent = `${rootName}${lockedData.chordName.replace(/^[A-G][#b]?\s*/, '')}`;
                        chordName.style.color = '#ffcc00'; // Make it gold to indicate locked root
                        chordName.title = `LOCKED: ${rootName} root, ${lockedData.lockedTuning}TET tuning`;
                    }
                }
                
                // Restore original global settings
                this.currentRoot = originalSettings.currentRoot;
                this.currentTuning = originalSettings.currentTuning;
                this.gamelanMode = originalSettings.gamelanMode;
                this.volume = originalSettings.volume;
                this.masterVolume = originalSettings.masterVolume;
                
                console.log('?? Generated strings with locked settings and restored global settings');
                
                // Find the lock button and ensure it shows the correct state
                const lockButton = column.querySelector('.lock-button');
                if (lockButton) {
                    lockButton.innerHTML = '🔒';
                    lockButton.classList.add('locked');
                    lockButton.title = `Locked to ${this.getNoteNames()[lockedData.lockedRoot] || lockedData.lockedRoot} root with all settings`;
                }
            }
            
            generateChordName(intervals) {
                if (!intervals || intervals.length === 0) return '';
                if (intervals.length === 1) return '';
                
                // Use the new proper chord symbol system
                return this.getProperChordSymbol(intervals);
            }
            
            // Helper function to check if intervals match (accounting for octave wrapping)
            intervalsMatch(intervals1, intervals2) {
                if (intervals1.length !== intervals2.length) return false;
                
                // Normalize intervals to within one octave
                const normalize = (intervals) => intervals.map(i => i % 12).sort((a, b) => a - b);
                const norm1 = normalize(intervals1);
                const norm2 = normalize(intervals2);
                
                return norm1.every((interval, index) => interval === norm2[index]);
            }
            
            playStringPreview(interval) {
                if (!this.audioContext) return;
                
                const frequency = this.getFrequency(interval, this.currentRoot, this.currentTuning);
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.2, this.audioContext.currentTime + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.8);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.8);
            }
            
            restoreNormalRootButtons() {
                // Restore original root button functionality
                this.generateRootButtons();
            }
            
            // ============= CHORD BUILDER SETUP =============
            
            showSimpleChordBuilder() {
                // Create a simple modal for custom chord building
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                `;
                
                const tuningSize = this.getTuningStepsPerOctave();
                const noteNames = this.getNoteNames();
                
                // Create note selector grid
                let notesGrid = '';
                for (let i = 0; i < tuningSize; i++) {
                    const isDiatonic = this.isDiatonicNote(i);
                    const noteClass = isDiatonic ? 'note-btn diatonic' : 'note-btn';
                    notesGrid += `
                        <button class="${noteClass}" data-note="${i}" style="
                            background: ${isDiatonic ? '#1e40af' : '#374151'};
                            color: white;
                            border: 1px solid ${isDiatonic ? '#3b82f6' : '#6b7280'};
                            padding: 8px;
                            margin: 2px;
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 12px;
                            min-width: 40px;
                        ">${noteNames[i] || i}</button>
                    `;
                }
                
                modal.innerHTML = `
                    <div style="
                        background: #1f2937;
                        border-radius: 12px;
                        padding: 20px;
                        max-width: 600px;
                        width: 90%;
                        max-height: 80vh;
                        overflow-y: auto;
                        color: white;
                    ">
                        <h2 style="margin: 0 0 20px 0; color: #f3f4f6;">Create Custom Chord</h2>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Chord Name:</label>
                            <input type="text" id="simpleChordName" placeholder="Enter chord name" style="
                                width: 100%;
                                padding: 8px;
                                border: 1px solid #6b7280;
                                border-radius: 4px;
                                background: #374151;
                                color: white;
                                font-size: 14px;
                            ">
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">
                                Select Notes (Blue = Diatonic):
                            </label>
                            <div style="
                                display: grid;
                                grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
                                gap: 4px;
                                max-height: 200px;
                                overflow-y: auto;
                                border: 1px solid #6b7280;
                                padding: 10px;
                                border-radius: 4px;
                                background: #2d3748;
                            " id="simpleNotesGrid">
                                ${notesGrid}
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <button id="previewSimpleChord" style="
                                background: #059669;
                                color: white;
                                border: none;
                                padding: 8px 16px;
                                border-radius: 4px;
                                cursor: pointer;
                                margin-right: 10px;
                            ">?? Preview</button>
                            <button id="clearSimpleChord" style="
                                background: #dc2626;
                                color: white;
                                border: none;
                                padding: 8px 16px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">Clear</button>
                        </div>
                        
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button id="cancelSimpleChord" style="
                                background: #6b7280;
                                color: white;
                                border: none;
                                padding: 10px 20px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">Cancel</button>
                            <button id="saveSimpleChord" style="
                                background: #1e40af;
                                color: white;
                                border: none;
                                padding: 10px 20px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">Save Chord</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Add event listeners
                this.setupSimpleChordBuilderEvents(modal);
            }
            
            setupSimpleChordBuilderEvents(modal) {
                // Note selection
                modal.querySelectorAll('.note-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        btn.classList.toggle('selected');
                        if (btn.classList.contains('selected')) {
                            btn.style.background = btn.classList.contains('diatonic') ? '#3b82f6' : '#6b7280';
                            btn.style.boxShadow = '0 0 8px rgba(59, 130, 246, 0.5)';
                        } else {
                            btn.style.background = btn.classList.contains('diatonic') ? '#1e40af' : '#374151';
                            btn.style.boxShadow = 'none';
                        }
                    });
                });
                
                // Preview chord
                modal.querySelector('#previewSimpleChord').addEventListener('click', () => {
                    const selectedNotes = this.getSelectedNotesFromModal(modal);
                    if (selectedNotes.length === 0) {
                        alert('Please select at least one note!');
                        return;
                    }
                    this.previewCustomChord(selectedNotes);
                });
                
                // Clear selection
                modal.querySelector('#clearSimpleChord').addEventListener('click', () => {
                    modal.querySelectorAll('.note-btn.selected').forEach(btn => {
                        btn.classList.remove('selected');
                        btn.style.background = btn.classList.contains('diatonic') ? '#1e40af' : '#374151';
                        btn.style.boxShadow = 'none';
                    });
                });
                
                // Save chord
                modal.querySelector('#saveSimpleChord').addEventListener('click', () => {
                    const chordName = modal.querySelector('#simpleChordName').value.trim();
                    const selectedNotes = this.getSelectedNotesFromModal(modal);
                    
                    if (!chordName) {
                        alert('Please enter a chord name!');
                        return;
                    }
                    
                    if (selectedNotes.length === 0) {
                        alert('Please select at least one note!');
                        return;
                    }
                    
                    this.saveSimpleCustomChord(chordName, selectedNotes);
                    modal.remove();
                    if (typeof this.closeBottomPanel === 'function') this.closeBottomPanel();
                });
                
                // Cancel
                modal.querySelector('#cancelSimpleChord').addEventListener('click', () => {
                    modal.remove();
                });
                
                // Close on ESC
                const closeOnEsc = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', closeOnEsc);
                    }
                };
                document.addEventListener('keydown', closeOnEsc);
            }
            
            isDiatonicNote(noteIndex) {
                // Check if note is diatonic (major scale intervals in current tuning)
                const tuningSize = this.getTuningStepsPerOctave();
                const diatonicIntervals = [0, 2, 4, 5, 7, 9, 11]; // Major scale in semitones
                
                // Map to current tuning
                const diatonicSteps = diatonicIntervals.map(interval => 
                    Math.round((interval * tuningSize) / 12)
                );
                
                return diatonicSteps.includes(noteIndex);
            }
            
            getSelectedNotesFromModal(modal) {
                const selectedButtons = modal.querySelectorAll('.note-btn.selected');
                return Array.from(selectedButtons).map(btn => parseInt(btn.dataset.note));
            }
            
            previewCustomChord(selectedNotes) {
                // Play the selected notes as a chord
                const baseOctave = 4;
                selectedNotes.forEach(noteStep => {
                    const freq = this.getFrequency(noteStep, baseOctave, this.currentTuning);
                    this.playFrequency(freq, null);
                });
                
                // Stop after 1 second
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 1000);
            }
            
            saveSimpleCustomChord(chordName, selectedNotes) {
                // Create a single chord extension that will auto-generate all 3 qualities
                const chordExtension = {
                    name: chordName,
                    intervals: selectedNotes,
                    isCustom: true,
                    id: chordName.toLowerCase().replace(/\s+/g, '_')
                };
                
                // ADD to existing chords instead of replacing them
                this.chordExtensions.push(chordExtension);
                
                // Save and regenerate
                this.saveChordConfiguration();
                this.preserveLockedChordsAndRegenerate();
                
                console.log(`Added custom chord: ${chordName} with notes:`, selectedNotes);
            }

            getTuningDisplayName() {
                if (this.gamelanMode) return 'Gamelan';
                switch(this.currentTuning) {
                    case 5: return '5-EDO';
                    case 7: return '7-EDO';
                    case 11: return 'C.Gamma';
                    case 12: return '12-TET';
                    case 15: return '15-EDO';
                    case 17: return '17-EDO';
                    case 19: return '19-TET';
                    case 22: return '22-TET';
                    case 24: return '24-TET';
                    case 31: return '31-TET';
                    case 34: return '34-TET';
                    case 53: return '53-TET';
                    default: return `${this.currentTuning}-TET`;
                }
            }
            
            updateFavoritesDisplay() {
                // This method appears to be unused/orphaned - keeping as placeholder
            }
            
            populateChordBuilderNoteSelector() {
                const selector = document.getElementById('chordBuilderNoteSelector');
                selector.innerHTML = '';
                
                const edoSize = this.gamelanMode ? 7 : this.currentTuning;
                
                for (let i = 0; i < edoSize; i++) {
                    const button = document.createElement('div');
                    button.className = 'note-btn';
                    button.dataset.note = i;
                    button.textContent = this.getMicrotonalNoteName(i);
                    
                    // Color coding for diatonic highlighting
                    button.style.cssText = `
                        padding: 8px 4px;
                        background: ${this.getDiatonicNoteColor(i)};
                        border: 2px solid ${this.getDiatonicNoteBorderColor(i)};
                        color: white;
                        cursor: pointer;
                        border-radius: 6px;
                        font-size: 11px;
                        font-weight: bold;
                        text-align: center;
                        transition: all 0.2s;
                        user-select: none;
                    `;
                    
                    button.addEventListener('click', () => {
                        button.classList.toggle('selected');
                        if (button.classList.contains('selected')) {
                            button.style.borderColor = '#f39c12';
                            button.style.boxShadow = '0 0 8px rgba(243, 156, 18, 0.6)';
                        } else {
                            button.style.borderColor = this.getDiatonicNoteBorderColor(i);
                            button.style.boxShadow = 'none';
                        }
                    });
                    
                    selector.appendChild(button);
                }
            }
            
            populateChordExtensions() {
                const checkboxContainer = document.getElementById('chordExtensionsCheckboxes');
                checkboxContainer.innerHTML = '';
                
                const extensions = [
                    { name: 'Major', intervals: [0, 4, 7], base: true },
                    { name: 'Minor', intervals: [0, 3, 7], base: true },
                    { name: 'Neutral', intervals: [0, 3.5, 7], base: true },
                    { name: 'Diminished', intervals: [0, 3, 6] },
                    { name: 'Augmented', intervals: [0, 4, 8] },
                    { name: 'sus2', intervals: [0, 2, 7] },
                    { name: 'sus4', intervals: [0, 5, 7] },
                    { name: 'maj7', intervals: [11] },
                    { name: '7th', intervals: [10] },
                    { name: '6th', intervals: [9] },
                    { name: '9th', intervals: [14] },
                    { name: 'add9', intervals: [2] },
                    { name: '11th', intervals: [17] },
                    { name: '13th', intervals: [21] },
                    { name: '?9', intervals: [13] },
                    { name: '?9', intervals: [15] },
                    { name: '?11', intervals: [18] },
                    { name: '?13', intervals: [20] },
                    { name: '?13', intervals: [22] }
                ];
                
                extensions.forEach((ext, index) => {
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.style.display = 'flex';
                    checkboxDiv.style.alignItems = 'center';
                    checkboxDiv.style.gap = '6px';
                    checkboxDiv.style.padding = '4px 8px';
                    checkboxDiv.style.borderRadius = '4px';
                    checkboxDiv.style.background = ext.base ? 'rgba(74, 144, 226, 0.2)' : 'rgba(255, 255, 255, 0.1)';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `ext_${index}`;
                    checkbox.dataset.intervals = JSON.stringify(ext.intervals);
                    checkbox.style.cursor = 'pointer';
                    
                    const label = document.createElement('label');
                    label.htmlFor = `ext_${index}`;
                    label.textContent = ext.name;
                    label.style.fontSize = '12px';
                    label.style.cursor = 'pointer';
                    label.style.color = ext.base ? '#4a90e2' : '#8fb3d3';
                    label.style.fontWeight = ext.base ? 'bold' : 'normal';
                    
                    checkbox.addEventListener('change', () => {
                        this.updateChordPreview();
                    });
                    
                    // Add hover preview for extensions
                    checkboxDiv.addEventListener('mouseenter', () => {
                        this.previewIntervals(ext.intervals);
                    });
                    
                    checkboxDiv.addEventListener('mouseleave', () => {
                        this.stopPreview();
                    });
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(label);
                    checkboxContainer.appendChild(checkboxDiv);
                });
            }
            
            populateMicrotonalIntervals() {
                const checkboxContainer = document.getElementById('microtonalCheckboxes');
                checkboxContainer.innerHTML = '';
                
                // Generate all intervals in the current EDO
                for (let step = 1; step < this.currentTuning; step++) {
                    const semitones = (step * 12) / this.currentTuning;
                    const cents = semitones * 100;
                    
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.style.display = 'flex';
                    checkboxDiv.style.alignItems = 'center';
                    checkboxDiv.style.gap = '4px';
                    checkboxDiv.style.padding = '3px 6px';
                    checkboxDiv.style.borderRadius = '3px';
                    checkboxDiv.style.fontSize = '11px';
                    
                    // Color coding based on interval type
                    const color = this.getDiatonicNoteColor(step);
                    checkboxDiv.style.background = color + '20'; // Add transparency
                    checkboxDiv.style.borderLeft = `3px solid ${color}`;
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `micro_${step}`;
                    checkbox.dataset.semitones = semitones.toString();
                    checkbox.dataset.step = step.toString();
                    checkbox.style.cursor = 'pointer';
                    checkbox.style.transform = 'scale(0.8)';
                    
                    const label = document.createElement('label');
                    label.htmlFor = `micro_${step}`;
                    label.style.fontSize = '10px';
                    label.style.cursor = 'pointer';
                    label.style.color = '#fff';
                    label.style.fontFamily = 'monospace';
                    
                    // Create descriptive label
                    const noteName = this.getMicrotonalNoteName(step);
                    const centsStr = cents >= 0 ? `+${cents.toFixed(0)}�` : `${cents.toFixed(0)}�`;
                    label.textContent = `${noteName} (${centsStr})`;
                    
                    checkbox.addEventListener('change', () => {
                        this.updateChordPreview();
                    });
                    
                    // Add hover preview for microtonal intervals
                    checkboxDiv.addEventListener('mouseenter', () => {
                        this.previewIntervals([semitones]);
                    });
                    
                    checkboxDiv.addEventListener('mouseleave', () => {
                        this.stopPreview();
                    });
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(label);
                    checkboxContainer.appendChild(checkboxDiv);
                }
            }
            
            updateChordPreview() {
                const previewDisplay = document.getElementById('chordPreviewDisplay');
                if (!previewDisplay) return;
                
                const selectedIntervals = this.getSelectedChordIntervals();
                
                if (selectedIntervals.length === 0) {
                    previewDisplay.textContent = 'No intervals selected';
                    previewDisplay.style.color = '#8fb3d3';
                    return;
                }
                
                // Sort intervals
                selectedIntervals.sort((a, b) => a - b);
                
                // Create preview text
                let previewText = 'Selected intervals: ';
                previewText += selectedIntervals.map(interval => {
                    if (interval === 0) return 'Root';
                    const semitones = interval;
                    const cents = Math.round(semitones * 100);
                    return `${semitones.toFixed(1)}? (${cents}�)`;
                }).join(', ');
                
                previewDisplay.textContent = previewText;
                previewDisplay.style.color = '#27ae60';
            }
            
            getSelectedChordIntervals() {
                const intervals = [0]; // Always include root
                
                // Get selected diatonic extensions
                const extensionCheckboxes = document.querySelectorAll('#chordExtensionsCheckboxes input[type="checkbox"]:checked');
                extensionCheckboxes.forEach(checkbox => {
                    const extIntervals = JSON.parse(checkbox.dataset.intervals);
                    intervals.push(...extIntervals);
                });
                
                // Get selected microtonal intervals
                const microCheckboxes = document.querySelectorAll('#microtonalCheckboxes input[type="checkbox"]:checked');
                microCheckboxes.forEach(checkbox => {
                    const semitones = parseFloat(checkbox.dataset.semitones);
                    intervals.push(semitones);
                });
                
                // Remove duplicates and sort
                return [...new Set(intervals)].sort((a, b) => a - b);
            }
            
            previewIntervals(intervals) {
                // Stop any existing preview
                this.stopPreview();
                
                // Start preview timeout to avoid too many rapid previews
                this.previewTimeout = setTimeout(() => {
                    if (!intervals || intervals.length === 0) return;
                    
                    // Play the intervals as a chord
                    const baseOctave = 4;
                    intervals.forEach((interval, index) => {
                        setTimeout(() => {
                            const step = this.semitoneToEDOStep(interval);
                            const frequency = this.getFrequency(step, baseOctave, this.currentTuning);
                            const mockElement = { classList: { add: () => {}, remove: () => {} } };
                            this.playFrequency(frequency, mockElement);
                            
                            // Store the frequency for later cleanup
                            if (!this.previewFrequencies) this.previewFrequencies = [];
                            this.previewFrequencies.push(frequency);
                        }, index * 30); // Slight arpeggiation
                    });
                    
                    // Auto-stop preview after 800ms
                    this.previewStopTimeout = setTimeout(() => {
                        this.stopPreview();
                    }, 800);
                }, 100); // 100ms delay to avoid rapid firing
            }
            
            stopPreview() {
                // Clear timeouts
                if (this.previewTimeout) {
                    clearTimeout(this.previewTimeout);
                    this.previewTimeout = null;
                }
                if (this.previewStopTimeout) {
                    clearTimeout(this.previewStopTimeout);
                    this.previewStopTimeout = null;
                }
                
                // Stop all preview frequencies
                if (this.previewFrequencies) {
                    this.previewFrequencies.forEach(frequency => {
                        const mockElement = { classList: { add: () => {}, remove: () => {} } };
                        this.stopFrequency(frequency, mockElement);
                    });
                    this.previewFrequencies = [];
                }
            }
            
            updateChordBuilderFromExtensions() {
                // Get selected extensions
                const activeExtensions = Array.from(document.querySelectorAll('#chordExtensionsGrid .osc-btn.active'))
                    .map(btn => btn.textContent);
                
                // Convert extensions to intervals
                const intervals = this.convertExtensionsToIntervals(activeExtensions);
                
                // Update note selector to reflect these intervals
                this.loadChordPatternIntoBuilder(intervals);
            }
            
            convertExtensionsToIntervals(extensions) {
                const intervals = [0]; // Always include root
                const baseTriad = this.getBaseTriadForQuality();
                intervals.push(...baseTriad.slice(1)); // Add 3rd and 5th
                
                extensions.forEach(ext => {
                    switch(ext) {
                        case '6th': intervals.push(9); break;
                        case '7th': intervals.push(10); break;
                        case 'maj7': intervals.push(11); break;
                        case '9th': intervals.push(14); break;
                        case '?9': intervals.push(13); break;
                        case '?9': intervals.push(15); break;
                        case '11th': intervals.push(17); break;
                        case '?11': intervals.push(16); break;
                        case '?11': intervals.push(18); break;
                        case '13th': intervals.push(21); break;
                        case '?13': intervals.push(20); break;
                        case '?13': intervals.push(22); break;
                        case 'sus2': 
                            intervals.splice(intervals.indexOf(baseTriad[1]), 1); // Remove 3rd
                            intervals.push(2); 
                            break;
                        case 'sus4': 
                            intervals.splice(intervals.indexOf(baseTriad[1]), 1); // Remove 3rd
                            intervals.push(5); 
                            break;
                        case 'add9': intervals.push(14); break;
                        case 'dim': 
                            intervals[intervals.indexOf(baseTriad[1])] = 3; // ?3
                            intervals[intervals.indexOf(baseTriad[2])] = 6; // ?5
                            break;
                        case 'aug': 
                            intervals[intervals.indexOf(baseTriad[2])] = 8; // ?5
                            break;
                    }
                });
                
                return [...new Set(intervals)].sort((a, b) => a - b);
            }
            
            getBaseTriadForQuality() {
                switch(this.currentQuality) {
                    case 'major': return [0, 4, 7];
                    case 'minor': return [0, 3, 7];
                    case 'neutral': return [0, 3.5, 7];
                    default: return [0, 4, 7];
                }
            }
            
            loadChordPatternIntoBuilder(intervals) {
                // Clear all selections first
                document.querySelectorAll('#chordBuilderNoteSelector .note-btn').forEach(btn => {
                    btn.classList.remove('selected');
                    btn.style.borderColor = this.getDiatonicNoteBorderColor(parseInt(btn.dataset.note));
                    btn.style.boxShadow = 'none';
                });
                
                // Convert 12-TET intervals to current EDO
                intervals.forEach(interval => {
                    const edoStep = this.semitoneToEDOStep(interval);
                    const button = document.querySelector(`#chordBuilderNoteSelector .note-btn[data-note="${edoStep}"]`);
                    if (button) {
                        button.classList.add('selected');
                        button.style.borderColor = '#f39c12';
                        button.style.boxShadow = '0 0 8px rgba(243, 156, 18, 0.6)';
                    }
                });
            }
            
            semitoneToEDOStep(semitones) {
                // Convert 12-TET semitones to current EDO step
                const exactStep = (semitones / 12) * this.currentTuning;
                return Math.round(exactStep) % this.currentTuning;
            }
            
            getMicrotonalNoteName(step) {
                // Base note letters
                const baseLetters = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
                
                // Unicode accidental symbols
                const accidentals = {
                    doubleFlat: '𝄫',      // -2 semitones
                    flat: '♭',            // -1 semitone
                    quarterFlat: '𝄳',     // -0.5 semitone (24EDO)
                    flatUp: '𝄬',          // slightly > -1 (31EDO, 22EDO)
                    flatDown: '𝄭',        // slightly < -1 (31EDO, 22EDO)
                    natural: '♮',         // 0 semitones (when needed for clarity)
                    naturalUp: '𝄮',       // slightly > 0 (31EDO, 22EDO)
                    naturalDown: '𝄯',     // slightly < 0 (31EDO, 22EDO)
                    quarterSharp: '𝄲',    // +0.5 semitone (24EDO)
                    sharp: '♯',           // +1 semitone
                    sharpUp: '𝄰',         // slightly > +1 (31EDO, 22EDO)
                    sharpDown: '𝄱',       // slightly < +1 (31EDO, 22EDO)
                    doubleSharp: '𝄪'      // +2 semitones
                };
                
                // Calculate cents and closest diatonic note
                const centsPerStep = 1200 / this.currentTuning;
                const totalCents = step * centsPerStep;
                
                // Map to closest diatonic note (C=0, D=2, E=4, F=5, G=7, A=9, B=11)
                const diatonicSteps = [0, 2, 4, 5, 7, 9, 11];
                const semitonePosition = totalCents / 100;
                
                // Find closest diatonic note
                let closestDiatonic = 0;
                let minDistance = Infinity;
                let diatonicIndex = 0;
                
                for (let i = 0; i < diatonicSteps.length; i++) {
                    const distance = Math.abs(semitonePosition - diatonicSteps[i]);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestDiatonic = diatonicSteps[i];
                        diatonicIndex = i;
                    }
                }
                
                // Get base note letter
                let noteLetter = baseLetters[diatonicIndex];
                let accidental = '';
                let arrows = '';
                
                // Calculate deviation from closest diatonic note in cents
                const deviation = totalCents - (closestDiatonic * 100);
                
                // Apply EDO-specific accidental rules
                if (this.currentTuning === 12) {
                    // 12 EDO - standard notation
                    if (Math.abs(deviation) < 25) {
                        accidental = ''; // Natural
                    } else if (deviation >= 75) {
                        accidental = accidentals.sharp;
                    } else if (deviation <= -75) {
                        accidental = accidentals.flat;
                    }
                } else if (this.currentTuning === 24) {
                    // 24 EDO - quarter-tone system
                    if (Math.abs(deviation) < 12.5) {
                        accidental = ''; // Natural
                    } else if (deviation >= 37.5 && deviation < 62.5) {
                        accidental = accidentals.quarterSharp;
                    } else if (deviation >= 62.5) {
                        accidental = accidentals.sharp;
                    } else if (deviation <= -37.5 && deviation > -62.5) {
                        accidental = accidentals.quarterFlat;
                    } else if (deviation <= -62.5) {
                        accidental = accidentals.flat;
                    }
                } else if (this.currentTuning === 31 || this.currentTuning === 22) {
                    // 31 EDO or 22 EDO - fine-tuned accidentals
                    const threshold = 1200 / (this.currentTuning * 4); // Quarter of a step
                    
                    if (Math.abs(deviation) < threshold) {
                        accidental = ''; // Natural
                    } else if (deviation > 75 && deviation < 125) {
                        accidental = accidentals.sharpDown; // Sharp down
                    } else if (deviation >= 125) {
                        accidental = accidentals.sharp;
                    } else if (deviation < -75 && deviation > -125) {
                        accidental = accidentals.flatUp; // Flat up
                    } else if (deviation <= -125) {
                        accidental = accidentals.flat;
                    } else if (deviation > 0 && deviation <= 75) {
                        accidental = accidentals.naturalUp; // Natural up
                    } else if (deviation < 0 && deviation >= -75) {
                        accidental = accidentals.naturalDown; // Natural down
                    }
                } else {
                    // Higher resolution EDOs (>31) - use base accidentals + arrows
                    const stepSize = 1200 / this.currentTuning;
                    
                    // Determine base accidental
                    if (Math.abs(deviation) < stepSize / 4) {
                        accidental = ''; // Natural
                    } else if (deviation >= 87.5) {
                        accidental = accidentals.sharp;
                    } else if (deviation <= -87.5) {
                        accidental = accidentals.flat;
                    } else if (deviation > 37.5 && deviation < 87.5) {
                        accidental = accidentals.quarterSharp;
                    } else if (deviation < -37.5 && deviation > -87.5) {
                        accidental = accidentals.quarterFlat;
                    } else if (deviation > 0) {
                        accidental = accidentals.naturalUp;
                    } else {
                        accidental = accidentals.naturalDown;
                    }
                    
                    // Add ^ or v arrows for fine-tuning in high-resolution EDOs
                    const fineDeviation = Math.abs(deviation) % stepSize;
                    const arrowThreshold = stepSize / 8;
                    
                    if (fineDeviation > arrowThreshold && fineDeviation < stepSize - arrowThreshold) {
                        const numArrows = Math.floor(fineDeviation / arrowThreshold);
                        if (deviation > 0) {
                            arrows = '^'.repeat(Math.min(numArrows, 3));
                        } else {
                            arrows = 'v'.repeat(Math.min(numArrows, 3));
                        }
                    }
                }
                
                // Construct final note name: [Note][Accidental(s)][Arrows]
                let finalName = noteLetter + accidental + arrows;
                
                return finalName;
            }
            
            getDiatonicNoteColor(step) {
                // Color-code notes based on their relationship to diatonic scale
                const semitoneEquivalent = (step * 12) / this.currentTuning;
                const baseSemitone = Math.round(semitoneEquivalent) % 12;
                
                // Diatonic notes (C D E F G A B)
                if ([0, 2, 4, 5, 7, 9, 11].includes(baseSemitone)) {
                    return '#4a90e2'; // Blue for diatonic
                }
                // Neutral/microtonal
                if (Math.abs(semitoneEquivalent - Math.round(semitoneEquivalent)) > 0.3) {
                    return '#27ae60'; // Green for neutral
                }
                // Chromatic
                return '#e74c3c'; // Red for chromatic
            }
            
            getDiatonicNoteBorderColor(step) {
                const semitoneEquivalent = (step * 12) / this.currentTuning;
                const baseSemitone = Math.round(semitoneEquivalent) % 12;
                
                if ([0, 2, 4, 5, 7, 9, 11].includes(baseSemitone)) {
                    return '#6bb6ff'; // Lighter blue for diatonic
                }
                if (Math.abs(semitoneEquivalent - Math.round(semitoneEquivalent)) > 0.3) {
                    return '#2ecc71'; // Lighter green for neutral
                }
                return '#ff6b6b'; // Lighter red for chromatic
            }
            
            updateBuilderFavoritesDisplay() {
                const favoritesList = document.getElementById('chordBuilderFavoritesList');
                favoritesList.innerHTML = '';
                
                if (!this.favoriteChords || this.favoriteChords.length === 0) {
                    favoritesList.innerHTML = '<div style="color: #8fb3d3; font-style: italic; text-align: center; padding: 20px;">No favorite chords yet</div>';
                    return;
                }
                
                this.favoriteChords.forEach((chord, index) => {
                    const chordElement = document.createElement('div');
                    chordElement.className = 'favorite-chord-item';
                    chordElement.style.cssText = `
                        background: rgba(0, 30, 60, 0.6);
                        border: 1px solid #4a6870;
                        border-radius: 6px;
                        padding: 8px;
                        cursor: pointer;
                        transition: all 0.2s;
                        text-align: center;
                    `;
                    
                    chordElement.innerHTML = `
                        <div style="font-weight: bold; color: #f39c12;">${chord.name}</div>
                        <div style="font-size: 10px; opacity: 0.8;">${chord.intervals ? chord.intervals.join(' ') : 'Custom'}</div>
                        <div style="font-size: 8px; opacity: 0.6; margin-top: 4px;">Click to load</div>
                    `;
                    
                    chordElement.addEventListener('click', () => {
                        this.loadFavoriteIntoBuilder(chord);
                    });
                    
                    chordElement.addEventListener('mouseenter', () => {
                        chordElement.style.borderColor = '#8fb3d3';
                        chordElement.style.background = 'rgba(0, 40, 80, 0.8)';
                    });
                    
                    chordElement.addEventListener('mouseleave', () => {
                        chordElement.style.borderColor = '#4a6870';
                        chordElement.style.background = 'rgba(0, 30, 60, 0.6)';
                    });
                    
                    favoritesList.appendChild(chordElement);
                });
            }
            
            loadFavoriteIntoBuilder(favoriteChord) {
                // Load name
                document.getElementById('chordBuilderName').value = favoriteChord.name;
                
                // Load pattern
                if (favoriteChord.intervals) {
                    this.loadChordPatternIntoBuilder(favoriteChord.intervals);
                }
            }
            
            saveChordFromBuilder() {
                const name = document.getElementById('chordBuilderName').value.trim();
                const selectedIntervals = this.getSelectedChordIntervals();
                
                if (!name || selectedIntervals.length <= 1) {
                    alert('Please enter a chord name and select at least one interval beyond the root.');
                    return;
                }
                
                const newChord = {
                    name: name,
                    intervals: selectedIntervals,
                    isCustom: true,
                    id: Date.now() // Unique ID
                };
                
                if (this.currentEditingChord) {
                    // Update existing chord
                    this.updateExistingChord(newChord);
                } else {
                    // Use addChordColumn to automatically generate 3 chord qualities
                    this.addChordColumn(newChord);
                }
                
                // Custom chords are automatically added to extensions, no separate dropdown needed
                
                this.closeChordBuilder();
                
                console.log(`Saved custom chord: ${name} with auto-generated 3 qualities`);
            }
            
            getSelectedBuilderNotes() {
                // For backward compatibility, use the new checkbox system
                return this.getSelectedChordIntervals();
            }
            
            addBuilderChordToFavorites() {
                const name = document.getElementById('chordBuilderName').value.trim();
                const selectedNotes = this.getSelectedBuilderNotes();
                
                if (!name || selectedNotes.length === 0) {
                    alert('Please enter a chord name and select notes first.');
                    return;
                }
                
                const favoriteChord = {
                    name: name,
                    intervals: selectedNotes,
                    quality: this.currentQuality,
                    root: this.currentRoot,
                    tuning: this.currentTuning
                };
                
                // Check if already in favorites
                const exists = this.favoriteChords.some(fav => 
                    fav.name === favoriteChord.name && 
                    JSON.stringify(fav.intervals) === JSON.stringify(favoriteChord.intervals)
                );
                
                if (!exists) {
                    this.favoriteChords.push(favoriteChord);
                    // localStorage removed - no longer saving favorite chords
                    this.updateBuilderFavoritesDisplay();
                    alert(`Added "${favoriteChord.name}" to favorites!`);
                } else {
                    alert('This chord is already in your favorites.');
                }
            }
            
            previewBuilderChord() {
                const selectedNotes = this.getSelectedBuilderNotes();
                if (selectedNotes.length === 0) {
                    alert('Please select some notes first.');
                    return;
                }
                
                // Play the chord
                selectedNotes.forEach((interval, index) => {
                    setTimeout(() => {
                        const frequency = this.getFrequency(this.semitoneToEDOStep(interval), 4);
                        const mockElement = { classList: { add: () => {}, remove: () => {} } };
                        this.playFrequency(frequency, mockElement);
                        
                        // Stop after a short duration
                        setTimeout(() => {
                            this.stopFrequency(frequency, mockElement);
                        }, 1000);
                    }, index * 50); // Slight arpeggiation
                });
            }
            
            clearChordBuilder() {
                // Stop any active previews
                this.stopPreview();
                
                document.getElementById('chordBuilderName').value = '';
                
                // Uncheck all extension checkboxes
                document.querySelectorAll('#chordExtensionsCheckboxes input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                // Uncheck all microtonal checkboxes
                document.querySelectorAll('#microtonalCheckboxes input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                // Update preview
                this.updateChordPreview();
            }
            
            closeChordBuilder() {
                // Stop any active previews
                this.stopPreview();
                
                document.getElementById('chordBuilderModal').style.display = 'none';
                this.currentEditingChord = null;
                // Autosave on tap-out: if we were editing via selectedIntervals, commit in place
                if (this.isChordCreationMode && this.selectedIntervals && this.selectedIntervals.length > 1) {
                    const pendingName = this.generateChordName(this.selectedIntervals);
                    this.finalizePreviewChord(pendingName);
                }
                this.isChordCreationMode = false;
            }
            
            updateTuningSystem(divisions) {
                const previousTuning = this.currentTuning;
                this.currentTuning = divisions;
                this.gamelanMode = false;
                this.generateRootButtons();
                // Remap custom chords to nearest neighbors in new tuning
                try {
                    this.remapCustomChordsToNearestNeighbors(previousTuning, this.currentTuning);
                } catch (e) { console.warn('Remap skipped:', e); }
                this.preserveLockedChordsAndRegenerate();
                
                // Update note selector if chord builder is open
                if (document.getElementById('chordBuilderModal').style.display === 'block') {
                    this.populateChordBuilderNoteSelector();
                }
                
                console.log(`Updated to ${divisions}-EDO tuning system`);
                // Auto-close the TUNING popup/panel after applying
                if (typeof this.closeBottomPanel === 'function') this.closeBottomPanel();
            }

            // Remap custom-chord intervals from an old EDO to the nearest neighbors in a new EDO
            remapCustomChordsToNearestNeighbors(fromEdo, toEdo) {
                if (!Array.isArray(this.chordExtensions) || !fromEdo || !toEdo || fromEdo === toEdo) return;
                // Helper: map a step value in fromEdo to nearest step in toEdo by preserving cents
                const mapStep = (step) => {
                    // Preserve pitch-class modulo octave while keeping absolute step differences minimal
                    // Convert to cents relative to octave and round to nearest destination step
                    const cents = (step / fromEdo) * 1200;
                    const mapped = Math.round((cents / 1200) * toEdo);
                    return ((mapped % toEdo) + toEdo) % toEdo;
                };
                this.chordExtensions = this.chordExtensions.map(ch => {
                    if (ch && ch.isCustom && Array.isArray(ch.intervals)) {
                        const mappedIntervals = ch.intervals.map(mapStep);
                        // Keep root at 0 explicitly
                        if (!mappedIntervals.includes(0)) mappedIntervals.unshift(0);
                        return {
                            ...ch,
                            intervals: [...new Set(mappedIntervals)].sort((a,b)=>a-b),
                            lastTuning: toEdo
                        };
                    }
                    return ch;
                });
            }
            
            updateIntervalRatio(ratioString) {
                const [num, den] = ratioString.split('/').map(Number);
                this.intervalRatio = [num, den];
                console.log(`Updated interval ratio to ${ratioString}`);
                
                // Regenerate tuning if needed
                this.preserveLockedChordsAndRegenerate();
                // Auto-close the TUNING popup/panel after applying
                if (typeof this.closeBottomPanel === 'function') this.closeBottomPanel();
            }
            
            addChordColumn(chordData) {
                // When adding a new chord, automatically create ONE Major, ONE Minor, ONE Neutral
                if (chordData.intervals && chordData.intervals.length > 0) {
                    // Auto-generate 3 qualities for the new chord with color gradients
                    this.autoGenerateChordQualities(chordData);
                } else {
                    // For standard chord extensions without specific intervals
                    this.chordExtensions.push(chordData);
                    this.saveChordConfiguration(); // Use consistent save method
                }
                
                // Regenerate the columns to show the new chord variations
                this.preserveLockedChordsAndRegenerate();
                
                console.log(`Added chord column: ${chordData.name} with auto-generated qualities`);
            }
            
            autoGenerateChordQualities(chordData) {
                // Automatically create Major, Minor, and Neutral variants with color gradients
                const qualities = [
                    { 
                        name: 'major', 
                        suffix: 'Maj', 
                        color: { bg: '#1e40af', border: '#3b82f6' }, // Blue for Major
                        intervals: chordData.intervals 
                    },
                    { 
                        name: 'minor', 
                        suffix: 'Min', 
                        color: { bg: '#dc2626', border: '#ef4444' }, // Red for Minor
                        intervals: this.convertToMinorIntervals(chordData.intervals)
                    },
                    { 
                        name: 'neutral', 
                        suffix: 'Neu', 
                        color: { bg: '#059669', border: '#10b981' }, // Green for Neutral
                        intervals: this.convertToNeutralIntervals(chordData.intervals)
                    }
                ];
                
                qualities.forEach(quality => {
                    const qualityChord = {
                        name: `${chordData.name}${quality.suffix}`,
                        originalName: chordData.name,
                        intervals: quality.intervals,
                        quality: quality.name,
                        isCustom: true,
                        color: quality.color,
                        baseIntervals: chordData.intervals
                    };
                    
                    // Add to chord extensions for the 3-column layout
                    this.chordExtensions.push(qualityChord);
                });
                
                // Save the updated chord extensions
                this.saveChordConfiguration(); // Use consistent save method
                
                console.log(`Auto-generated 3 qualities for: ${chordData.name}`);
            }
            
            convertToMinorIntervals(intervals) {
                // Convert major intervals to minor by flattening the third
                return intervals.map(interval => {
                    if (interval === 4) return 3; // Major 3rd to minor 3rd
                    if (interval === 11) return 10; // Major 7th to minor 7th
                    return interval;
                });
            }
            
            convertToNeutralIntervals(intervals) {
                // Convert intervals to neutral by using quarter-tones
                return intervals.map(interval => {
                    if (interval === 4) return 3.5; // Major 3rd to neutral 3rd
                    if (interval === 3) return 3.5; // Minor 3rd to neutral 3rd
                    if (interval === 11) return 10.5; // Major 7th to neutral 7th
                    if (interval === 10) return 10.5; // Minor 7th to neutral 7th
                    return interval;
                });
            }
            
            updateExistingChord(newChordData) {
                if (this.currentEditingChord.isCustom) {
                    const index = this.customChords.findIndex(c => c.id === this.currentEditingChord.id);
                    if (index !== -1) {
                        this.customChords[index] = { ...newChordData, id: this.currentEditingChord.id };
                        // localStorage removed - no longer saving custom chords
                    }
                } else {
                    const index = this.chordExtensions.findIndex(c => c.name === this.currentEditingChord.name);
                    if (index !== -1) {
                        this.chordExtensions[index] = newChordData;
                        this.saveChordConfiguration(); // Use consistent save method
                    }
                }
                
                this.preserveLockedChordsAndRegenerate();
                console.log(`Updated chord: ${newChordData.name}`);
            }

            async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.value = this.volume * this.masterVolume; // Apply both volume and master volume at start
                    
                    // Create simple reverb
                    this.createReverb();
                    
                    // Create wet/dry gain nodes for reverb
                    this.wetGainNode = this.audioContext.createGain();
                    this.dryGainNode = this.audioContext.createGain();
                    this.wetGainNode.gain.value = this.reverb.wet;
                    this.dryGainNode.gain.value = 1.0 - this.reverb.wet;
                    
                    // Create reverb filter
                    this.reverbFilterNode = this.audioContext.createBiquadFilter();
                    this.reverbFilterNode.type = 'lowpass';
                    this.reverbFilterNode.frequency.value = this.reverb.filterCutoff;
                    this.reverbFilterNode.Q.value = 1;
                    
                    // Connect audio routing: gainNode ? dry/wet ? reverb ? destination
                    this.gainNode.connect(this.dryGainNode);
                    this.gainNode.connect(this.wetGainNode);
                    this.dryGainNode.connect(this.audioContext.destination);
                    this.wetGainNode.connect(this.reverbNode);
                    this.reverbNode.connect(this.reverbFilterNode);
                    this.reverbFilterNode.connect(this.audioContext.destination);
                    
                    // Store the initial clean state for piano lock system
                    this.storeOriginalUIState();
                    console.log('🎹 Stored original UI state for piano lock system');
                } catch (error) {
                    console.error('Audio initialization failed:', error);
                }
            }

            createReverb() {
                const convolver = this.audioContext.createConvolver();
                const length = this.audioContext.sampleRate * this.reverb.decay;
                const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const n = length - i;
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(n / length, this.reverb.roomSize);
                    }
                }
                
                convolver.buffer = impulse;
                this.reverbNode = convolver;
            }

            createNoiseSource() {
                const bufferSize = this.audioContext.sampleRate * 1; // 1 second of noise
                const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1; // White noise
                }
                
                const whiteNoise = this.audioContext.createBufferSource();
                whiteNoise.buffer = noiseBuffer;
                whiteNoise.loop = true;
                
                return whiteNoise;
            }

            initEventListeners() {
                // Tuning system selection
                document.querySelectorAll('[data-tuning]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-tuning]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        const tuningValue = btn.dataset.tuning;
                        if (tuningValue === 'gamelan') {
                            // Gamelan pelog scale (7 notes)
                            this.currentTuning = 7;
                            this.gamelanMode = true;
                        } else {
                            this.currentTuning = parseInt(tuningValue);
                            this.gamelanMode = false;
                        }
                        
                        this.generateRootButtons();
                        this.preserveLockedChordsAndRegenerate();
                        this.updateChordDisplay();
                    });
                });

                // Quality selection
                document.querySelectorAll('[data-quality]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-quality]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentQuality = btn.dataset.quality;
                        this.preserveLockedChordsAndRegenerate();
                        this.updateChordDisplay();
                    });
                });

                // Removed standalone volumeSlider (merged into master volume UI)

                // ADSR controls with value displays and proper limits
                const attackSlider = document.getElementById('attackSlider');
                if (attackSlider) {
                    attackSlider.addEventListener('input', (e) => {
                        this.envelope.attack = Math.max(0.003, e.target.value / 1000); // 3ms minimum
                        console.log('?? Attack changed to:', this.envelope.attack);
                        const attackValue = document.getElementById('attackValue');
                        if (attackValue) {
                            attackValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('attackSlider not found');
                }
                
                const decaySlider = document.getElementById('decaySlider');
                if (decaySlider) {
                    decaySlider.addEventListener('input', (e) => {
                        this.envelope.decay = Math.max(0.001, e.target.value / 1000); // 1ms minimum, 200ms max
                        console.log('?? Decay changed to:', this.envelope.decay);
                        const decayValue = document.getElementById('decayValue');
                        if (decayValue) {
                            decayValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('decaySlider not found');
                }
                
                const sustainSlider = document.getElementById('sustainSlider');
                if (sustainSlider) {
                    sustainSlider.addEventListener('input', (e) => {
                        this.envelope.sustain = e.target.value / 10; // 0-10 scale to 0-1
                        console.log('?? Sustain changed to:', this.envelope.sustain);
                        const sustainValue = document.getElementById('sustainValue');
                        if (sustainValue) {
                            sustainValue.textContent = `${e.target.value * 10}%`;
                        }
                    });
                } else {
                    console.error('sustainSlider not found');
                }
                
                const releaseSlider = document.getElementById('releaseSlider');
                if (releaseSlider) {
                    releaseSlider.addEventListener('input', (e) => {
                        this.envelope.release = e.target.value / 1000; // 0-3000ms
                        const releaseValue = document.getElementById('releaseValue');
                        if (releaseValue) {
                            releaseValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('releaseSlider not found');
                }

                // Master Volume control with dB conversion
                const masterVolumeSlider = document.getElementById('masterVolume');
                if (masterVolumeSlider) {
                    masterVolumeSlider.addEventListener('input', (e) => {
                        // Convert 0-10 scale to 0dB to -3dB (linear from 0 to 0.9)
                        const sliderValue = e.target.value / 10; // 0-1
                        this.masterVolume = sliderValue * 0.9; // Max at -3dB (0.9 linear gain)
                        if (this.gainNode) {
                            this.gainNode.gain.value = this.volume * this.masterVolume;
                        }
                        const masterVolumeValue = document.getElementById('masterVolumeValue');
                        if (masterVolumeValue) {
                            masterVolumeValue.textContent = `${e.target.value * 10}%`;
                        }
                    });
                } else {
                    console.error('masterVolumeSlider not found');
                }

                // OSC 2 ADSR controls
                const osc2AttackSlider = document.getElementById('osc2AttackSlider');
                if (osc2AttackSlider) {
                    osc2AttackSlider.addEventListener('input', (e) => {
                        this.osc2Envelope.attack = Math.max(0.003, e.target.value / 1000); // 3ms minimum
                        const osc2AttackValue = document.getElementById('osc2AttackValue');
                        if (osc2AttackValue) {
                            osc2AttackValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('osc2AttackSlider not found');
                }
                
                const osc2DecaySlider = document.getElementById('osc2DecaySlider');
                if (osc2DecaySlider) {
                    osc2DecaySlider.addEventListener('input', (e) => {
                        this.osc2Envelope.decay = Math.max(0.001, e.target.value / 1000); // 1ms minimum, 200ms max
                        const osc2DecayValue = document.getElementById('osc2DecayValue');
                        if (osc2DecayValue) {
                            osc2DecayValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('osc2DecaySlider not found');
                }
                
                const osc2SustainSlider = document.getElementById('osc2SustainSlider');
                if (osc2SustainSlider) {
                    osc2SustainSlider.addEventListener('input', (e) => {
                        this.osc2Envelope.sustain = e.target.value / 10; // 0-10 scale to 0-1
                        const osc2SustainValue = document.getElementById('osc2SustainValue');
                        if (osc2SustainValue) {
                            osc2SustainValue.textContent = `${e.target.value * 10}%`;
                        }
                    });
                } else {
                    console.error('osc2SustainSlider not found');
                }
                
                const osc2ReleaseSlider = document.getElementById('osc2ReleaseSlider');
                if (osc2ReleaseSlider) {
                    osc2ReleaseSlider.addEventListener('input', (e) => {
                        this.osc2Envelope.release = e.target.value / 1000; // 0-3000ms
                        const osc2ReleaseValue = document.getElementById('osc2ReleaseValue');
                        if (osc2ReleaseValue) {
                            osc2ReleaseValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('osc2ReleaseSlider not found');
                }

                // Oscillator controls
                document.querySelectorAll('.osc-btn[data-wave]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const osc = btn.dataset.osc;
                        const wave = btn.dataset.wave;
                        
                        // Update active state
                        document.querySelectorAll(`[data-osc="${osc}"]`).forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        this.oscillators[`osc${osc}`].type = wave;
                    });
                });

                // Oscillator detune and level controls
                ['1', '2'].forEach(num => {
                    const detuneSlider = document.getElementById(`osc${num}Detune`);
                    if (detuneSlider) {
                        detuneSlider.addEventListener('input', (e) => {
                            this.oscillators[`osc${num}`].detune = parseInt(e.target.value);
                            const detuneValue = document.getElementById(`osc${num}DetuneValue`);
                            if (detuneValue) {
                                detuneValue.textContent = `${e.target.value}�`;
                            }
                        });
                    } else {
                        console.error(`osc${num}Detune not found`);
                    }
                    
                    const levelSlider = document.getElementById(`osc${num}Level`);
                    if (levelSlider) {
                        levelSlider.addEventListener('input', (e) => {
                            // Convert 0-10 scale to -18dB to 0dB (linear from 0.125 to 1.0)
                            const sliderValue = e.target.value / 10; // 0-1
                            this.oscillators[`osc${num}`].level = sliderValue * 0.125; // Max at -18dB
                            const levelValue = document.getElementById(`osc${num}LevelValue`);
                            if (levelValue) {
                                levelValue.textContent = `${e.target.value * 10}%`;
                            }
                        });
                    } else {
                        console.error(`osc${num}Level not found`);
                    }
                });

                // Oscillator octave and coarse controls
                ['1', '2'].forEach(num => {
                    const octaveSlider = document.getElementById(`osc${num}Octave`);
                    if (octaveSlider) {
                        octaveSlider.addEventListener('input', (e) => {
                            this.oscillators[`osc${num}`].octave = parseInt(e.target.value);
                            const octaveValue = document.getElementById(`osc${num}OctaveValue`);
                            if (octaveValue) {
                                octaveValue.textContent = e.target.value;
                            }
                        });
                    } else {
                        console.error(`osc${num}Octave not found`);
                    }
                    
                    const coarseSlider = document.getElementById(`osc${num}Coarse`);
                    if (coarseSlider) {
                        coarseSlider.addEventListener('input', (e) => {
                            this.oscillators[`osc${num}`].coarse = parseInt(e.target.value);
                            const coarseValue = document.getElementById(`osc${num}CoarseValue`);
                            if (coarseValue) {
                                coarseValue.textContent = `${e.target.value} steps`;
                            }
                        });
                    } else {
                        console.error(`osc${num}Coarse not found`);
                    }
                });

                // Mix mode removed - oscillators will now simply add together

                // Reverb controls
                const reverbWetSlider = document.getElementById('reverbWet');
                if (reverbWetSlider) {
                    reverbWetSlider.addEventListener('input', (e) => {
                        this.reverb.wet = e.target.value / 10; // 0-10 scale to 0-1
                        if (this.wetGainNode && this.dryGainNode) {
                            this.wetGainNode.gain.value = this.reverb.wet;
                            this.dryGainNode.gain.value = 1.0 - this.reverb.wet;
                        }
                        const reverbWetValue = document.getElementById('reverbWetValue');
                        if (reverbWetValue) {
                            reverbWetValue.textContent = `${e.target.value * 10}%`;
                        }
                    });
                } else {
                    console.error('reverbWet slider not found');
                }

                const reverbRoomSlider = document.getElementById('reverbRoom');
                if (reverbRoomSlider) {
                    reverbRoomSlider.addEventListener('input', (e) => {
                        this.reverb.roomSize = e.target.value / 10; // 0-10 scale to 0-1
                        const reverbRoomValue = document.getElementById('reverbRoomValue');
                        if (reverbRoomValue) {
                            reverbRoomValue.textContent = `${e.target.value * 10}%`;
                        }
                        // Recreate reverb with new room size
                        if (this.audioContext) {
                            this.createReverb();
                            // Properly reconnect the reverb chain
                            this.wetGainNode.disconnect();
                            this.reverbFilterNode.disconnect();
                            this.wetGainNode.connect(this.reverbNode);
                            this.reverbNode.connect(this.reverbFilterNode);
                            this.reverbFilterNode.connect(this.audioContext.destination);
                        }
                    });
                } else {
                    console.error('reverbRoom slider not found');
                }
                
                const reverbDecaySlider = document.getElementById('reverbDecay');
                if (reverbDecaySlider) {
                    reverbDecaySlider.addEventListener('input', (e) => {
                        this.reverb.decay = (e.target.value / 100) * 10; // 0-10 seconds
                        const reverbDecayValue = document.getElementById('reverbDecayValue');
                        if (reverbDecayValue) {
                            reverbDecayValue.textContent = `${(this.reverb.decay).toFixed(1)}s`;
                        }
                        // Recreate reverb with new decay time
                        if (this.audioContext) {
                            this.createReverb();
                            // Properly reconnect the reverb chain
                            this.wetGainNode.disconnect();
                            this.reverbFilterNode.disconnect();
                            this.wetGainNode.connect(this.reverbNode);
                            this.reverbNode.connect(this.reverbFilterNode);
                            this.reverbFilterNode.connect(this.audioContext.destination);
                        }
                    });
                } else {
                    console.error('reverbDecay slider not found');
                }
                
                const reverbFilterCutoffSlider = document.getElementById('reverbFilterCutoff');
                if (reverbFilterCutoffSlider) {
                    reverbFilterCutoffSlider.addEventListener('input', (e) => {
                        this.reverb.filterCutoff = parseInt(e.target.value);
                        if (this.reverbFilterNode) {
                            this.reverbFilterNode.frequency.value = this.reverb.filterCutoff;
                        }
                        const reverbFilterCutoffValue = document.getElementById('reverbFilterCutoffValue');
                        if (reverbFilterCutoffValue) {
                            reverbFilterCutoffValue.textContent = `${e.target.value}Hz`;
                        }
                    });
                } else {
                    console.error('reverbFilterCutoff slider not found');
                }

                const reverbFilterResSlider = document.getElementById('reverbFilterRes');
                if (reverbFilterResSlider) {
                    reverbFilterResSlider.addEventListener('input', (e) => {
                        if (this.reverbFilterNode) {
                            this.reverbFilterNode.Q.value = parseFloat(e.target.value);
                        }
                        const reverbFilterResValue = document.getElementById('reverbFilterResValue');
                        if (reverbFilterResValue) {
                            reverbFilterResValue.textContent = e.target.value;
                        }
                    });
                }
                // Note: reverbFilterRes slider not present in current UI

                // Panning controls
                const panningModeSelect = document.getElementById('panningMode');
                if (panningModeSelect) {
                    panningModeSelect.addEventListener('change', (e) => {
                        if (window.omnichord && window.omnichord.panning) {
                            window.omnichord.panning.mode = e.target.value;
                            console.log('?? Panning mode changed to:', window.omnichord.panning.mode);
                        } else {
                            console.error('?? omnichord instance or panning not available');
                        }
                    });
                } else {
                    console.error('panningMode select not found');
                }

                const panningWidthSlider = document.getElementById('panningWidth');
                if (panningWidthSlider) {
                    panningWidthSlider.addEventListener('input', (e) => {
                        if (window.omnichord && window.omnichord.panning) {
                            window.omnichord.panning.width = e.target.value / 100; // 0-100% to 0-1
                            console.log('?? Panning width changed to:', window.omnichord.panning.width);
                            const panningWidthValue = document.getElementById('panningWidthValue');
                            if (panningWidthValue) {
                                panningWidthValue.textContent = `${e.target.value}%`;
                            }
                        } else {
                            console.error('?? omnichord instance or panning not available');
                        }
                    });
                } else {
                    console.error('panningWidth slider not found');
                }

                const panningSpeedSlider = document.getElementById('panningSpeed');
                if (panningSpeedSlider) {
                    panningSpeedSlider.addEventListener('input', (e) => {
                        if (window.omnichord && window.omnichord.panning) {
                            window.omnichord.panning.speed = parseInt(e.target.value);
                            console.log('?? Panning speed changed to:', window.omnichord.panning.speed);
                            const panningSpeedValue = document.getElementById('panningSpeedValue');
                            if (panningSpeedValue) {
                                panningSpeedValue.textContent = `${(e.target.value / 1000).toFixed(1)}s`;
                            }
                        } else {
                            console.error('?? omnichord instance or panning not available');
                        }
                    });
                } else {
                    console.error('panningSpeed slider not found');
                }

                const panningResetBtn = document.getElementById('panningReset');
                if (panningResetBtn) {
                    panningResetBtn.addEventListener('click', () => {
                        if (window.omnichord && window.omnichord.panning) {
                            window.omnichord.panning.rotationAngle = 0;
                            window.omnichord.panning.alternateState = false;
                            console.log('?? Panning reset');
                        } else {
                            console.error('?? omnichord instance or panning not available');
                        }
                    });
                } else {
                    console.error('panningReset button not found');
                }

                // Enhanced string playing with ultra responsiveness (60 FPS optimized)
                const extensionColumns = document.getElementById('extensionColumns');
                
                // Mouse events for strings with optimized performance
                extensionColumns.addEventListener('mousedown', (e) => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    this.isPlayingStrings = true;
                    this.triggeredStrings.clear();
                    this.handleStringTrigger(e);
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isPlayingStrings) {
                        this.handleStringTrigger(e);
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    this.isPlayingStrings = false;
                    this.triggeredStrings.clear();
                    this.stopAllActiveNotes();
                });

                // Touch events for strings
                extensionColumns.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    this.isPlayingStrings = true;
                    this.triggeredStrings.clear();
                    
                    Array.from(e.changedTouches).forEach(touch => {
                        this.activeTouches.set(touch.identifier, touch);
                        this.handleStringTrigger(touch);
                    });
                });
                
                extensionColumns.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.isPlayingStrings) {
                        Array.from(e.changedTouches).forEach(touch => {
                            this.activeTouches.set(touch.identifier, touch);
                            this.handleStringTrigger(touch);
                        });
                    }
                });
                
                extensionColumns.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    Array.from(e.changedTouches).forEach(touch => {
                        this.activeTouches.delete(touch.identifier);
                    });
                    
                    if (this.activeTouches.size === 0) {
                        this.isPlayingStrings = false;
                        this.triggeredStrings.clear();
                        this.stopAllActiveNotes();
                    }
                });
                
                extensionColumns.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    Array.from(e.changedTouches).forEach(touch => {
                        this.activeTouches.delete(touch.identifier);
                    });
                    
                    if (this.activeTouches.size === 0) {
                        this.isPlayingStrings = false;
                        this.triggeredStrings.clear();
                        this.stopAllActiveNotes();
                    }
                });

                // Allow multitouch on control elements - prevent default only on strings
                document.addEventListener('touchstart', (e) => {
                    const target = e.target;
                    if (target.classList.contains('tuning-btn') || 
                        target.classList.contains('chord-btn') || 
                        target.classList.contains('quality-btn') || 
                        target.classList.contains('osc-btn')) {
                        // Don't prevent default on control buttons to allow multitouch
                        return;
                    }
                }, { passive: false });

                // Handle audio context resume on any interaction
                document.addEventListener('click', () => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        console.log('Attempting to resume AudioContext on click...');
                        this.audioContext.resume().then(() => {
                            console.log('AudioContext resumed successfully');
                        });
                    }
                });
                
                document.addEventListener('touchstart', () => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        console.log('Attempting to resume AudioContext on touch...');
                        this.audioContext.resume().then(() => {
                            console.log('AudioContext resumed successfully');
                        });
                    }
                });
                
                document.addEventListener('mousedown', () => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        console.log('Attempting to resume AudioContext on mousedown...');
                        this.audioContext.resume().then(() => {
                            console.log('AudioContext resumed successfully');
                        });
                    }
                });

                // Modal Event Listeners
                const closeColumnModalBtn = document.getElementById('closeColumnModal');
                const addCustomColumnBtn = document.getElementById('addCustomColumn');

                if (closeColumnModalBtn) {
                    closeColumnModalBtn.addEventListener('click', () => {
                        document.getElementById('columnModal').style.display = 'none';
                    });
                }

                if (addCustomColumnBtn) {
                    addCustomColumnBtn.addEventListener('click', () => {
                        document.getElementById('columnModal').style.display = 'none';
                        this.showChordBuilder();
                    });
                }

                // Add to favorites button
                const addToFavoritesBtn = document.getElementById('addToFavoritesBtn');
                if (addToFavoritesBtn) {
                    addToFavoritesBtn.addEventListener('click', () => {
                        this.addCurrentChordToFavorites();
                    });
                }

                // Initialize custom chords storage - no localStorage
                this.customChords = [];
                
                // Migrate old custom chords from 12-TET semitones to native tuning
                this.migrateCustomChords();
                
                this.hiddenColumns = [];
                this.favoriteChords = [];
                this.paletteChords = [];
                this.currentEditingColumn = null;
                
                // Set up context menu
                // Context menu setup removed for clean interface
                
                // Set up fretboard resize functionality
                this.setupFretboardResize();
                
                // Set up sonic chord functionality
                this.setupSonicChords();
                
                // Force initial generation
                console.log('Initializing omnichord with tuning:', this.currentTuning);
                setTimeout(() => {
                    this.generateRootButtons();
                    this.generateExtensionColumns();
                }, 100);
            }

            migrateCustomChords() {
                // Migrate old custom chords that used 12-TET semitones to native tuning
                let needsMigration = false;
                
                this.customChords.forEach(chord => {
                    // Check if this chord needs migration (has intervals property instead of notes)
                    if (chord.intervals && !chord.notes) {
                        // Convert from 12-TET semitones to native tuning
                        const originalTuning = this.currentTuning;
                        this.currentTuning = chord.tuning || 12;
                        
                        chord.notes = chord.intervals.map(semitone => {
                            // For chords saved in their original tuning, just use the intervals directly
                            return semitone;
                        });
                        
                        // Remove old intervals property
                        delete chord.intervals;
                        this.currentTuning = originalTuning;
                        needsMigration = true;
                        console.log(`Migrated custom chord: ${chord.name}`);
                    } else if (!chord.notes && chord.intervals) {
                        // Fallback: copy intervals to notes if notes missing
                        chord.notes = [...chord.intervals];
                        needsMigration = true;
                    }
                });
                
                if (needsMigration) {
                    // localStorage removed - no longer saving custom chords
                    console.log('Custom chords migrated to new format');
                }
            }

            // Context menu functionality removed for clean interface
            setupContextMenu() {
                console.log('🎵 Context menus disabled for cleaner interface');
                
                // Setup keyboard input only
                this.setupKeyboardInput();
            }
            
            setupKeyboardInput() {
                document.addEventListener('keydown', (e) => {
                    // Only handle number keys 1-0 and only if not typing in an input field
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        return; // Don't interfere with text input
                    }
                    
                    const key = e.key;
                    let chordIndex = -1;
                    
                    // Map number keys to chord indices (1-9, then 0 for 10th chord)
                    if (key >= '1' && key <= '9') {
                        chordIndex = parseInt(key) - 1; // 1 -> 0, 2 -> 1, etc.
                    } else if (key === '0') {
                        chordIndex = 9; // 0 -> 9 (10th chord)
                    }
                    
                    if (chordIndex >= 0) {
                        e.preventDefault();
                        this.playChordByIndex(chordIndex);
                    }
                });
            }
            
            playChordByIndex(index) {
                // First try to play from palette chords
                if (this.paletteChords && index < this.paletteChords.length) {
                    const chord = this.paletteChords[index];
                    console.log(`Playing palette chord ${index + 1}:`, chord.name);
                    this.playPaletteChord(chord);
                    return;
                }
                
                // If no palette chord at that index, try to play from extension columns
                const columns = document.querySelectorAll('.extension-column');
                if (index < columns.length) {
                    const column = columns[index];
                    const header = column.querySelector('.extension-header');
                    if (header) {
                        console.log(`Playing extension chord ${index + 1}:`, header.textContent);
                        // Simulate a click on the column to play the chord
                        const rect = column.getBoundingClientRect();
                        const centerY = rect.top + rect.height / 2;
                        this.playChordStrum(column, { name: header.textContent }, centerY - 10, centerY + 10);
                    }
                } else {
                    console.log(`No chord available at index ${index + 1}`);
                }
            }

            setupTouchGestures() {
                // Add touch gesture support to all chord elements
                this.addTouchGesturesToElements();
                
                // Re-apply gestures when DOM changes (for dynamically added elements)
                const observer = new MutationObserver(() => {
                    this.addTouchGesturesToElements();
                });
                
                observer.observe(document.getElementById('extensionColumns'), {
                    childList: true,
                    subtree: true
                });
            }
            
            addTouchGesturesToElements() {
                // Add gestures to chord buttons in extension columns
                document.querySelectorAll('.chord-btn').forEach(btn => {
                    this.addTouchGestureToElement(btn, 'chord');
                    this.addClickGestureToElement(btn, 'chord');
                });
                
                // SKIP extension headers - they're handled by addSimpleClickHandlers() for chord name context menu
                console.log('Skipping extension headers - handled by addSimpleClickHandlers for chord name context menu');
                
                // SKIP extension columns too - let the headers handle all interactions to avoid conflicts
                console.log('Skipping extension columns - headers handle all interactions to avoid conflicts');
                
                // Add gestures to palette chords
                document.querySelectorAll('.palette-chord').forEach(chord => {
                    this.addTouchGestureToElement(chord, 'palette');
                    this.addClickGestureToElement(chord, 'palette');
                });
                
                // Add gestures to root chord buttons
                document.querySelectorAll('.root-btn').forEach(btn => {
                    this.addTouchGestureToElement(btn, 'root');
                    this.addClickGestureToElement(btn, 'root');
                });
            }
            
            addTouchGestureToElement(element, type) {
                // Prevent duplicate listeners
                if (element.dataset.touchGestureAdded) return;
                element.dataset.touchGestureAdded = 'true';
                
                let touchData = {
                    startTime: 0,
                    longPressTimer: null,
                    isLongPress: false
                };
                
                // Store the type for later reference
                element.dataset.touchGestureType = type;
                
                // Touch start
                element.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    touchData.startTime = Date.now();
                    touchData.isLongPress = false;
                    
                    // Add visual feedback for touch press
                    element.classList.add('touch-pressed');
                    
                    // Clear any existing timer
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                    }
                    
                    // Start long press timer - use shorter delay for chord name buttons
                    const delay = (type === 'chord' && element.classList.contains('extension-header')) ? 
                        this.touchGestures.chordNameLongPressDelay : this.touchGestures.longPressDelay;
                    
                    touchData.longPressTimer = setTimeout(() => {
                        touchData.isLongPress = true;
                        element.classList.remove('touch-pressed');
                        element.classList.add('touch-long-press');
                        this.handleLongPress(element, type, touch.clientX, touch.clientY);
                        
                        // Add haptic feedback if available
                        if (navigator.vibrate) {
                            navigator.vibrate(50);
                        }
                    }, delay);
                    
                    // Only prevent default for extension headers, let root buttons work normally
                    if (type === 'chord' && element.classList.contains('extension-header')) {
                        e.preventDefault();
                    } else if (type === 'palette') {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Touch move - cancel long press if moving too much
                element.addEventListener('touchmove', (e) => {
                    // Cancel long press on any significant movement
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                        touchData.longPressTimer = null;
                        element.classList.remove('touch-pressed');
                    }
                    
                    // Only prevent default for extension headers, let root buttons work normally
                    if (type === 'chord' && element.classList.contains('extension-header')) {
                        e.preventDefault();
                    } else if (type === 'palette') {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Touch end
                element.addEventListener('touchend', (e) => {
                    // Clear long press timer
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                        touchData.longPressTimer = null;
                    }
                    
                    // Remove all touch feedback classes
                    element.classList.remove('touch-pressed', 'touch-long-press');
                    
                    // Handle normal tap if not a long press
                    if (!touchData.isLongPress) {
                        const delay = (type === 'chord' && element.classList.contains('extension-header')) ? 
                            this.touchGestures.chordNameLongPressDelay : this.touchGestures.longPressDelay;
                        if (Date.now() - touchData.startTime < delay) {
                            this.handleNormalTap(element, type);
                        }
                    }
                    
                    touchData.isLongPress = false;
                    
                    // Only prevent default for extension headers, let root buttons work normally
                    if (type === 'chord' && element.classList.contains('extension-header')) {
                        e.preventDefault();
                    } else if (type === 'palette') {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Touch cancel
                element.addEventListener('touchcancel', (e) => {
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                        touchData.longPressTimer = null;
                    }
                    
                    // Remove all touch feedback classes
                    element.classList.remove('touch-pressed', 'touch-long-press');
                    
                    touchData.isLongPress = false;
                }, { passive: false });
            }
            
            addClickGestureToElement(element, type) {
                // Prevent duplicate listeners
                if (element.dataset.clickGestureAdded) return;
                element.dataset.clickGestureAdded = 'true';
                
                // Add click event listener for regular mouse clicks (using capture phase for higher priority)
                element.addEventListener('click', (e) => {
                    // Show context menu for chord headers or extension columns
                    if (type === 'chord' && (element.classList.contains('extension-header') || element.classList.contains('extension-column'))) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        // Show context menu on regular click for chord elements
                        this.handleClick(element, type, e.clientX, e.clientY);
                        return false; // Ensure event stops here
                    } else if (type === 'palette') {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        // Show context menu for palette chords
                        this.handleClick(element, type, e.clientX, e.clientY);
                        return false; // Ensure event stops here
                    }
                    // For root buttons (type === 'root'), let the normal click behavior happen
                }, true); // Use capture phase
                
                // Also add a mousedown listener for long-press support
                element.addEventListener('mousedown', (e) => {
                    // Only handle left click (button 0)
                    if (e.button === 0 && type === 'chord' && (element.classList.contains('extension-header') || element.classList.contains('extension-column'))) {
                        // For chord name buttons (extension-header), use 200ms delay
                        if (element.classList.contains('extension-header')) {
                            element.dataset.mouseDownTime = Date.now();
                            element.dataset.mouseDownX = e.clientX;
                            element.dataset.mouseDownY = e.clientY;
                            
                            // Start timer for 200ms long press
                            element.dataset.mouseLongPressTimer = setTimeout(() => {
                                element.dataset.isMouseLongPress = 'true';
                                this.handleLongPress(element, type, e.clientX, e.clientY);
                            }, this.touchGestures.chordNameLongPressDelay);
                        } else {
                            // Regular behavior for other chord elements
                            element.dataset.showContextMenuOnMouseup = 'true';
                        }
                    }
                }, true);
                
                // Add mousemove listener to cancel long press on movement
                element.addEventListener('mousemove', (e) => {
                    if (element.dataset.mouseLongPressTimer && element.dataset.mouseDownX && element.dataset.mouseDownY) {
                        const deltaX = Math.abs(e.clientX - parseInt(element.dataset.mouseDownX));
                        const deltaY = Math.abs(e.clientY - parseInt(element.dataset.mouseDownY));
                        
                        // Cancel long press if mouse moved too much (more than 10px)
                        if (deltaX > 10 || deltaY > 10) {
                            clearTimeout(parseInt(element.dataset.mouseLongPressTimer));
                            delete element.dataset.mouseLongPressTimer;
                            delete element.dataset.mouseDownTime;
                            delete element.dataset.mouseDownX;
                            delete element.dataset.mouseDownY;
                        }
                    }
                });
                
                // Add mouseup listener to complete the action
                element.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        // Handle chord name button mouseup
                        if (element.classList.contains('extension-header') && element.dataset.mouseDownTime) {
                            const holdTime = Date.now() - parseInt(element.dataset.mouseDownTime);
                            
                            // Clear the timer
                            if (element.dataset.mouseLongPressTimer) {
                                clearTimeout(parseInt(element.dataset.mouseLongPressTimer));
                                delete element.dataset.mouseLongPressTimer;
                            }
                            
                            // If it was a long press, don't do anything else (already handled)
                            if (element.dataset.isMouseLongPress === 'true') {
                                delete element.dataset.isMouseLongPress;
                            } else if (holdTime < this.touchGestures.chordNameLongPressDelay) {
                                // Short click - treat as normal tap
                                this.handleNormalTap(element, type);
                            }
                            
                            // Clean up
                            delete element.dataset.mouseDownTime;
                            delete element.dataset.mouseDownX;
                            delete element.dataset.mouseDownY;
                        } else if (element.dataset.showContextMenuOnMouseup === 'true') {
                            // Regular behavior for other chord elements
                            delete element.dataset.showContextMenuOnMouseup;
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            this.handleClick(element, type, e.clientX, e.clientY);
                            return false;
                        }
                    }
                }, true);
            }
            
            handleClick(element, type, x, y) {
                // Show appropriate context menu based on element type
                if (type === 'chord' && (element.classList.contains('extension-header') || element.classList.contains('extension-column'))) {
                    // Handle extension headers and columns
                    const column = element.classList.contains('extension-column') ? element : element.closest('.extension-column');
                    if (column) {
                        // Extract the same data as the contextmenu handler would
                        const chordType = column.dataset.chordType;
                        // Find the extension index and quality from the structure
                        let columnData = null;
                        
                        // Check if it's a custom chord
                        if (chordType && chordType.startsWith('custom_')) {
                            const customIndex = parseInt(chordType.replace('custom_', ''));
                            const customChord = this.customChords[customIndex];
                            if (customChord) {
                                columnData = {
                                    name: customChord.name,
                                    extensions: [],
                                    quality: 'custom',
                                    id: chordType,
                                    isCustom: true,
                                    originalName: customChord.name,
                                    customIndex: customIndex,
                                    intervals: customChord.notes
                                };
                            }
                        } else {
                            // Regular extension chord - need to determine quality and extension
                            const qualitySection = element.closest('.quality-section');
                            const allQualitySections = Array.from(document.querySelectorAll('.quality-section'));
                            const qualityIndex = allQualitySections.indexOf(qualitySection);
                            const qualities = ['major', 'neutral', 'minor'];
                            const quality = qualities[qualityIndex] || 'major';
                            
                            // Find the extension from the chord type ID
                            const chordIndex = parseInt(chordType);
                            const chordExt = this.chordExtensions[chordIndex];
                            
                            if (chordExt) {
                                const header = column.querySelector('.extension-header');
                                columnData = {
                                    name: header ? header.textContent : chordExt.name,
                                    extensions: chordExt.extensions || [],
                                    quality: quality,
                                    id: chordType,
                                    isCustom: false,
                                    originalName: chordExt.name,
                                    extensionIndex: chordIndex
                                };
                            }
                        }
                        
                        if (columnData) {
                            // Context menu removed - no action taken
                        } else {
                            console.error('Failed to create columnData');
                        }
                    } else {
                        console.error('Could not find parent column');
                    }
                } else if (type === 'palette') {
                    const chordData = this.getPaletteChordDataFromElement(element);
                    // Context menu removed - no action taken
                } else {
                    // Unhandled click type - no action
                }
                // Don't handle 'root' type clicks here - let them work normally
            }
            
            handleLongPress(element, type, x, y) {
                // Show appropriate context menu based on element type
                if (type === 'chord') {
                    // Check if this is an extension header (chord name button)
                    if (element.classList.contains('extension-header')) {
                        // Get the column data from the parent column
                        const column = element.closest('.extension-column');
                        if (column) {
                            // Extract the chord data for the chord name context menu
                            const chordData = this.getChordDataFromColumn(column, element);
                            
                            if (chordData) {
                                // Context menu removed - no action taken
                            }
                        }
                    } else {
                        // Fallback to original logic for other chord elements
                        const columnData = this.getColumnDataFromElement(element);
                        // Context menu removed - no action taken
                    }
                } else if (type === 'palette') {
                    const chordData = this.getPaletteChordDataFromElement(element);
                    // Context menu removed - no action taken
                } else if (type === 'root') {
                    // Root chords could have their own context menu
                }
            }
            
            handleNormalTap(element, type) {
                // Handle normal tap based on element type - only show context menu for chord headers and palette
                if (type === 'chord' && element.classList.contains('extension-header')) {
                    // Show chord name context menu for chord headers
                    const rect = element.getBoundingClientRect();
                    const x = rect.left + rect.width / 2;
                    const y = rect.top + rect.height / 2;
                    
                    const column = element.closest('.extension-column');
                    if (column) {
                        const chordData = this.getChordDataFromColumn(column, element);
                        if (chordData) {
                            // Context menu removed - no action taken
                        }
                    }
                } else if (type === 'palette') {
                    // Show context menu for palette chords
                    const rect = element.getBoundingClientRect();
                    const x = rect.left + rect.width / 2;
                    const y = rect.top + rect.height / 2;
                    this.handleClick(element, type, x, y);
                } else if (type === 'root') {
                    // For root buttons, perform normal click behavior
                    const rootBtn = element.closest('.root-btn');
                    if (rootBtn) {
                        // Simulate a normal click to change root note
                        rootBtn.click();
                    }
                } else {
                    // No action for this tap target
                }
            }
            
            getColumnDataFromElement(element) {
                const column = element.closest('[data-chord-type]');
                if (!column) return null;
                
                return {
                    name: column.dataset.chordType,
                    extensions: column.dataset.extensions ? column.dataset.extensions.split(',') : [],
                    element: column
                };
            }
            
            getPaletteChordDataFromElement(element) {
                const chordElement = element.closest('.palette-chord');
                if (!chordElement) return null;
                
                const chordIndex = parseInt(chordElement.dataset.chordIndex);
                return this.paletteChords[chordIndex] || null;
            }
            
            showPaletteContextMenu(x, y, chordData) {
                // Context menu removed - no action taken
            }
            
            handlePaletteContextMenuAction(action) {
                // Context menu removed - no action taken
            }

            showColumnContextMenu(x, y, columnData) {
                // Context menu removed - no action taken
            }

            getChordDataFromColumn(column, header) {
                const chordType = column.dataset.chordType;
                let chordData = null;
                
                console.log('?? getChordDataFromColumn called with chordType:', chordType);
                
                // Check if it's a custom chord
                if (chordType && chordType.startsWith('custom_')) {
                    const customIndex = parseInt(chordType.replace('custom_', ''));
                    const customChord = this.customChords[customIndex];
                    if (customChord) {
                        chordData = {
                            name: customChord.name,
                            extensions: [],
                            quality: 'custom',
                            id: chordType,
                            isCustom: true,
                            originalName: customChord.name,
                            customIndex: customIndex,
                            intervals: customChord.notes,
                            root: this.currentRoot,
                            tuning: this.currentTuning
                        };
                    }
                } else {
                    // Regular extension chord - determine quality and extension
                    let quality = 'major'; // default
                    
                    // Try to find quality from parent quality section first
                    let qualitySection = null;
                    if (header && header.closest) {
                        qualitySection = header.closest('.quality-section');
                    }
                    
                    if (qualitySection) {
                        const allQualitySections = Array.from(document.querySelectorAll('.quality-section'));
                        const qualityIndex = allQualitySections.indexOf(qualitySection);
                        const qualities = ['major', 'neutral', 'minor'];
                        quality = qualities[qualityIndex] || 'major';
                    } else {
                        // For basic triads mode, determine quality from chord type or header text
                        const headerText = header && header.textContent ? header.textContent : '';
                        if (chordType === 'major' || headerText === 'Major') {
                            quality = 'major';
                        } else if (chordType === 'neutral' || headerText === 'Neutral') {
                            quality = 'neutral';
                        } else if (chordType === 'minor' || headerText === 'Minor') {
                            quality = 'minor';
                        }
                    }
                    
                    // Find the extension - in basic triads mode, find by name
                    let chordExt = null;
                    if (chordType === 'major' || chordType === 'neutral' || chordType === 'minor') {
                        // Basic triads mode - find by name
                        chordExt = this.chordExtensions.find(ext => 
                            ext.name.toLowerCase() === header.textContent.toLowerCase()
                        );
                    } else {
                        // Complex mode - find by index
                        const chordIndex = parseInt(chordType);
                        chordExt = this.chordExtensions[chordIndex];
                    }
                    
                    if (chordExt) {
                        chordData = {
                            name: header.textContent,
                            extensions: chordExt.extensions || [],
                            quality: quality,
                            id: chordType,
                            isCustom: false,
                            originalName: chordExt.name,
                            extensionIndex: chordExt.name, // Use name as identifier in basic mode
                            intervals: this.getBaseTriadForQuality(quality).concat(chordExt.extensions || []),
                            root: this.currentRoot,
                            tuning: this.currentTuning
                        };
                        console.log('?? Created chordData:', chordData);
                    } else {
                        console.log('?? Failed to find chordExt for chordType:', chordType);
                    }
                }
                
                return chordData;
            }

            showChordNameContextMenu(x, y, chordData) {
                // Context menu removed - no action taken
            }

            handleContextMenuAction(action) {
                // Context menu removed - no action taken
                console.log('Context menu action requested but disabled:', action);
            }
            
            // New unified methods for the refactored system
            duplicateAndEditColumn() {
                if (!this.currentEditingColumn) return;
                
                // Create a duplicate chord with new ID
                const duplicateChord = {
                    name: this.currentEditingColumn.name + ' Copy',
                    intervals: [...(this.currentEditingColumn.intervals || [])],
                    isCustom: true,
                    id: Date.now()
                };
                
                // Open chord builder with the duplicate
                this.showChordBuilder(duplicateChord);
            }
            
            editColumnInChordBuilder() {
                if (!this.currentEditingColumn) return;
                
                // Open chord builder with current column data for editing
                this.showChordBuilder(this.currentEditingColumn);
            }

            // Palette chord context menu actions
            editPaletteChordNotes(chordData) {
                // Open a modal to edit chord notes
                console.log('Editing palette chord notes:', chordData);
                // TODO: Implement chord note editor
            }
            
            copyPaletteChord(chordData) {
                // Create a copy of the chord and add it to the palette
                const copy = {
                    ...chordData,
                    name: chordData.name + ' Copy'
                };
                this.paletteChords.push(copy);
                this.savePaletteChords();
                console.log('Copied palette chord:', copy);
            }
            
            movePaletteChord(chordData, direction) {
                const currentIndex = this.paletteChords.findIndex(chord => 
                    chord.name === chordData.name && 
                    JSON.stringify(chord.notes) === JSON.stringify(chordData.notes)
                );
                
                if (currentIndex === -1) return;
                
                const newIndex = currentIndex + direction;
                if (newIndex < 0 || newIndex >= this.paletteChords.length) return;
                
                // Swap positions
                [this.paletteChords[currentIndex], this.paletteChords[newIndex]] = 
                [this.paletteChords[newIndex], this.paletteChords[currentIndex]];
                
                this.savePaletteChords();
                console.log('Moved palette chord:', direction > 0 ? 'right' : 'left');
            }
            
            removePaletteChord(chordData) {
                const index = this.paletteChords.findIndex(chord => 
                    chord.name === chordData.name && 
                    JSON.stringify(chord.notes) === JSON.stringify(chordData.notes)
                );
                
                if (index !== -1) {
                    this.paletteChords.splice(index, 1);
                    this.savePaletteChords();
                    console.log('Removed palette chord:', chordData.name);
                }
            }

            setupFretboardResize() {
                const resizeHandle = document.querySelector('.resize-handle');
                const extensionColumns = document.getElementById('extensionColumns');
                let isResizing = false;
                let startY = 0;
                let startHeight = 0;

                if (!resizeHandle || !extensionColumns) return;

                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startY = e.clientY;
                    startHeight = extensionColumns.offsetHeight;
                    document.body.style.cursor = 'ns-resize';
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;
                    
                    const deltaY = e.clientY - startY;
                    const newHeight = Math.max(200, Math.min(800, startHeight + deltaY));
                    
                    // Update container height
                    extensionColumns.style.height = `${newHeight}px`;
                    
                    // Update string spacing by keeping strings thin (1px) with tight margins for 8-octave support
                    const strings = document.querySelectorAll('.string');
                    const stringHeight = 1; // Always keep strings thin at 1px
                    const stringMargin = 0.2; // Consistent tight margin for 8-octave support
                    
                    strings.forEach(string => {
                        string.style.height = `${stringHeight}px`;
                        string.style.margin = `${stringMargin}px 0`;
                    });
                    
                    e.preventDefault();
                });

                document.addEventListener('mouseup', () => {
                    if (isResizing) {
                        isResizing = false;
                        document.body.style.cursor = '';
                    }
                });

                // Touch support for mobile
                resizeHandle.addEventListener('touchstart', (e) => {
                    isResizing = true;
                    startY = e.touches[0].clientY;
                    startHeight = extensionColumns.offsetHeight;
                    e.preventDefault();
                });

                document.addEventListener('touchmove', (e) => {
                    if (!isResizing) return;
                    
                    const deltaY = e.touches[0].clientY - startY;
                    const newHeight = Math.max(200, Math.min(800, startHeight + deltaY));
                    
                    extensionColumns.style.height = `${newHeight}px`;
                    
                    const strings = document.querySelectorAll('.string');
                    const stringHeight = 1; // Always keep strings thin at 1px
                    const stringMargin = 0.2; // Consistent tight margin for 8-octave support
                    
                    strings.forEach(string => {
                        string.style.height = `${stringHeight}px`;
                        string.style.margin = `${stringMargin}px 0`;
                    });
                    
                    e.preventDefault();
                });

                document.addEventListener('touchend', () => {
                    if (isResizing) {
                        isResizing = false;
                    }
                });
            }

            setupSonicChords() {
                // No longer rendering sonic chords - lock buttons work directly on main chord grid
                console.log('Sonic chord system disabled - using direct chord locking');
            }

            handleSonicStringTrigger(e) {
                if (!e.target.classList.contains('string')) return;
                
                const stringElement = e.target;
                const column = stringElement.closest('.sonic-column');
                if (!column) return;
                
                const index = parseInt(column.dataset.index);
                const sonicChord = this.lockedSonicChords[index];
                if (!sonicChord) return;
                
                const stringIndex = parseInt(stringElement.dataset.string);
                const stringKey = `${index}-${stringIndex}`;
                
                if (!this.sonicTriggeredStrings.has(stringKey)) {
                    this.sonicTriggeredStrings.add(stringKey);
                    
                    // Apply sonic settings temporarily and play the string
                    this.playSonicChord(sonicChord, () => {
                        this.playStringAtIndex(stringIndex);
                    });
                }
            }

            playSonicChordStrum(column, sonicChord, startY, endY) {
                // Apply sonic settings temporarily and play chord strum
                this.playSonicChord(sonicChord, () => {
                    this.playChordStrum(column, sonicChord.chordData, startY, endY);
                });
            }

            addToPalette(chordData) {
                // Always add chords to palette, even duplicates for chord progressions
                // Add a unique ID to track individual instances
                const chordWithId = {
                    ...chordData,
                    paletteId: Date.now() + Math.random() // Unique identifier for this instance
                };
                
                this.paletteChords.push(chordWithId);
                // localStorage removed - no longer saving palette chords
                console.log(`Added "${chordData.fullName}" to palette (${this.paletteChords.length} total chords)`);
                this.renderPaletteChords();
            }

            removeFromPalette(index) {
                if (index >= 0 && index < this.paletteChords.length) {
                    const removedChord = this.paletteChords.splice(index, 1)[0];
                    // localStorage removed - no longer saving palette chords
                    this.renderPaletteChords();
                    console.log(`Removed "${removedChord.fullName}" from palette`);
                }
            }

            // =============================================================================
            // SONIC CHORD LOCKING SYSTEM - Complete snapshot of all settings
            // =============================================================================
            
            lockSonicChord(chordData, columnElement) {
                // Check if this chord is already locked
                if (!this.lockedChords) this.lockedChords = new Map();
                
                const isAlreadyLocked = this.lockedChords.has(columnElement);
                
                if (isAlreadyLocked) {
                    // UNLOCK the chord - make it editable but keep it visible
                    console.log('?? Unlocking chord but keeping it visible:', chordData.name);
                    
                    // Get the locked chord data before deleting
                    const lockedChordData = this.lockedChords.get(columnElement);
                    
                    this.lockedChords.delete(columnElement);
                    
                    // Update session data and saved locks
                    this.sessionData.lockedChords = Array.from(this.lockedChords.values());
                    this.savedLockedChords = Array.from(this.lockedChords.values());
                    
                    // Update UI - change lock button to unlocked state (buttons remain visible)
                    const lockButton = columnElement.querySelector('.lock-button');
                    if (lockButton) {
                        lockButton.innerHTML = '🔓';
                        lockButton.classList.remove('locked');
                        lockButton.title = 'Lock chord with current root & settings';
                    }
                    
                    // Keep action buttons visible when unlocked - they should always be available
                    
                    // Reset the column header color to indicate unlocked
                    const header = columnElement.querySelector('.extension-header');
                    const chordName = header.querySelector('.chord-name');
                    if (chordName) {
                        chordName.style.color = '#fff'; // Reset to default color
                        chordName.style.fontWeight = 'normal'; // Reset font weight
                        // Restore original chord name (remove lock icon and root prefix)
                        const originalName = chordData.name || (lockedChordData ? lockedChordData.chordName : 'Chord');
                        const qualityOnlyName = originalName.replace(/^🔒\s*/, '').replace(/^[A-G][#b]?\s*/, ''); // Remove lock icon and root
                        chordName.textContent = qualityOnlyName || originalName;
                        chordName.title = 'Unlocked - will follow current root'; // Update tooltip
                    }
                    
                    // Update the chord extension data to reflect unlocked state
                    if (lockedChordData) {
                        const chordExtension = this.chordExtensions.find(ext => 
                            ext.name === lockedChordData.chordName || 
                            (ext.lockedData && ext.lockedData.lockId === lockedChordData.lockId)
                        );
                        
                        if (chordExtension) {
                            // Convert back to unlocked state but keep the chord visible
                            chordExtension.isLocked = false;
                            chordExtension.lockedData = null;
                            // Keep the intervals so the chord structure remains
                            chordExtension.intervals = lockedChordData.intervals;
                            chordExtension.isCustom = true; // Mark as custom to preserve intervals
                            
                            console.log('?? Converted locked chord to unlocked custom chord:', chordExtension.name);
                        }
                    }
                    
                    // Update the strings in this column to use current root instead of locked root
                    const strings = columnElement.querySelectorAll('.string');
                    strings.forEach(string => {
                        const interval = parseInt(string.dataset.interval);
                        if (!isNaN(interval)) {
                            // Recalculate frequency with current root
                            const frequency = this.getFrequency(interval, this.currentRoot, this.currentTuning);
                            string.dataset.frequency = frequency;
                            
                            // Update note name and tooltip
                            const noteName = this.getIntervalNoteName(interval);
                            string.textContent = noteName;
                            string.title = `${noteName} (${interval} steps, ${frequency.toFixed(1)}Hz)`;
                        }
                    });
                    
                    console.log('?? Chord unlocked but remains visible as editable chord:', chordData.name);
                    return;
                }
                
                // LOCK the chord
                    console.log('?? Locking chord directly in main grid with current root and settings:', chordData);
                
                // Create a unique identifier for this specific chord + root combination
                const currentRoot = this.currentRoot || 0;
                const lockId = `${chordData.name}_${chordData.quality || 'major'}_${currentRoot}`;
                
                // Capture ALL current settings directly from UI controls
                const rootName = this.getNoteNames()[currentRoot] || currentRoot;
                const fullChordName = `${rootName}${chordData.name}`; // Full name with root for locked storage
                
                const lockedChordData = {
                    // Chord identification
                    lockId: lockId,
                    chordName: fullChordName, // Store full name (root + quality) when locked
                    quality: chordData.quality || this.currentQuality || 'major',
                    extensions: chordData.extensions || [],
                    lockedRoot: currentRoot, // THIS is the key - lock to current root
                    
                    // Position tracking - find current position in chordExtensions array
                    originalPosition: chordData.position !== undefined ? chordData.position : this.findChordPosition(chordData),
                    
                    // Store chord intervals for exact reconstruction
                    intervals: chordData.intervals || [],
                    isCustom: chordData.isCustom || false,
                    
                    // Tuning system (locked)
                    lockedTuning: this.currentTuning || 12,
                    lockedGamelanMode: this.gamelanMode || false,
                    
                    // Audio settings (locked)
                    lockedOsc1: {
                        type: document.getElementById('osc1Type')?.value || this.oscillators.osc1.type || 'sine',
                        level: parseFloat(document.getElementById('osc1Level')?.value || this.oscillators.osc1.level || 0.5),
                        octave: parseInt(document.getElementById('osc1Octave')?.value || this.oscillators.osc1.octave || 0),
                        coarse: parseInt(document.getElementById('osc1Coarse')?.value || this.oscillators.osc1.coarse || 0),
                        detune: parseFloat(document.getElementById('osc1Detune')?.value || this.oscillators.osc1.detune || 0)
                    },
                    
                    lockedOsc2: {
                        type: document.getElementById('osc2Type')?.value || this.oscillators.osc2.type || 'sine',
                        level: parseFloat(document.getElementById('osc2Level')?.value || this.oscillators.osc2.level || 0.5),
                        octave: parseInt(document.getElementById('osc2Octave')?.value || this.oscillators.osc2.octave || 0),
                        coarse: parseInt(document.getElementById('osc2Coarse')?.value || this.oscillators.osc2.coarse || 0),
                        detune: parseFloat(document.getElementById('osc2Detune')?.value || this.oscillators.osc2.detune || 0)
                    },
                    
                    lockedEnvelope: {
                        attack: parseFloat(document.getElementById('envAttack')?.value || this.envelope.attack || 0.01),
                        decay: parseFloat(document.getElementById('envDecay')?.value || this.envelope.decay || 0.3),
                        sustain: parseFloat(document.getElementById('envSustain')?.value || this.envelope.sustain || 0.5),
                        release: parseFloat(document.getElementById('envRelease')?.value || this.envelope.release || 1)
                    },
                    
                    lockedOsc2Envelope: {
                        attack: parseFloat(document.getElementById('osc2EnvAttack')?.value || this.osc2Envelope.attack || 0.01),
                        decay: parseFloat(document.getElementById('osc2EnvDecay')?.value || this.osc2Envelope.decay || 0.3),
                        sustain: parseFloat(document.getElementById('osc2EnvSustain')?.value || this.osc2Envelope.sustain || 0.5),
                        release: parseFloat(document.getElementById('osc2EnvRelease')?.value || this.osc2Envelope.release || 1)
                    },
                    
                    lockedEffects: {
                        reverbWet: parseFloat(document.getElementById('reverbWet')?.value || this.reverbWet || 0),
                        reverbDecay: parseFloat(document.getElementById('reverbDecay')?.value || (this.reverb ? this.reverb.decay : 1)),
                        reverbFilterCutoff: parseFloat(document.getElementById('reverbFilterCutoff')?.value || (this.reverbFilterNode ? this.reverbFilterNode.frequency.value : 20000)),
                        panningMode: document.getElementById('panningMode')?.value || this.panning.mode || 'center',
                        panningWidth: parseFloat(document.getElementById('panningWidth')?.value || this.panning.width || 1)
                    },
                    
                    lockedVolume: {
                        master: parseFloat(document.getElementById('masterVolume')?.value || this.masterVolume || 1),
                        main: parseFloat(document.getElementById('mainVolume')?.value || this.volume || 0.5)
                    },
                    
                    // CRITICAL: Capture exact string frequencies for perfect sound preservation
                    exactFrequencies: this.captureStringFrequencies(columnElement),
                    
                    // Timestamp
                    timestamp: Date.now()
                };
                
                // Store in lockedChords map using column element as key
                if (!this.lockedChords) this.lockedChords = new Map();
                this.lockedChords.set(columnElement, lockedChordData);
                
                // Store in session data and keep saved locks in sync
                this.sessionData.lockedChords = Array.from(this.lockedChords.values());
                this.savedLockedChords = Array.from(this.lockedChords.values());

                // Mark chord model as locked so regeneration uses snapshot
                if (chordData) {
                    chordData.isLocked = true;
                    chordData.lockedData = lockedChordData;
                }
                
                // Update UI - change lock button to locked state and show locked root
                const lockButton = columnElement.querySelector('.lock-button');
                if (lockButton) {
                    lockButton.innerHTML = '🔒';
                    lockButton.classList.add('locked');
                    lockButton.title = `Locked to ${this.getNoteNames()[currentRoot] || currentRoot} root with all settings`;
                }
                
                // Action buttons remain visible (they should always be available)
                const editButton = columnElement.querySelector('.chord-action-button.edit');
                const hideButton = columnElement.querySelector('.chord-action-button.delete');
                const duplicateButton = columnElement.querySelector('.chord-action-button.duplicate');
                if (editButton) editButton.style.display = 'flex';
                if (hideButton) hideButton.style.display = 'flex';
                if (duplicateButton) duplicateButton.style.display = 'flex';
                
                // Update the column header to show it's locked to a specific root
                const header = columnElement.querySelector('.extension-header');
                const chordName = header.querySelector('.chord-name');
                if (chordName) {
                    const rootName = this.getNoteNames()[currentRoot] || currentRoot;
                    chordName.style.color = '#4CAF50'; // Green text to indicate locked
                    // Update the displayed name to show the locked root with proper spacing
                    chordName.textContent = `🔒 ${rootName}${chordData.name}`;
                    chordName.title = `Locked to ${rootName} with all synth settings`;
                }
                
                console.log('?? Chord locked directly in main grid:', lockedChordData);
            }
            
            // ============= PIANO SETTINGS LOCK SYSTEM - Oscillator & Effect Settings Only =============
            
            // Store the original UI state to prevent contamination
            storeOriginalUIState() {
                if (!this.originalUIState) {
                    // Store the initial clean state when app starts
                    this.originalUIState = {
                        osc1: { ...this.oscillators.osc1 },
                        osc2: { ...this.oscillators.osc2 },
                        envelope: { ...this.envelope },
                        osc2Envelope: { ...this.osc2Envelope },
                        reverb: { ...this.reverb },
                        panning: { ...this.panning },
                        volume: this.volume,
                        masterVolume: this.masterVolume
                    };
                }
                return this.originalUIState;
            }
            
            // Capture current synthesizer state for piano lock with unique preset ID
            captureCurrentSynthState() {
                // Generate unique preset ID
                this.pianoLockPresetCounter++;
                const presetId = `ID${String(this.pianoLockPresetCounter).padStart(3, '0')}`;
                
                const synthState = {
                    // Unique preset identifier
                    presetId: presetId,
                    
                    // Oscillator 1 settings (COMPLETE)
                    osc1: { ...this.oscillators.osc1 },
                    
                    // Oscillator 2 settings (COMPLETE)
                    osc2: { ...this.oscillators.osc2 },
                    
                    // Envelope settings (OSC 1 COMPLETE ADSR)
                    envelope: { ...this.envelope },
                    
                    // OSC 2 Envelope settings (COMPLETE ADSR)
                    osc2Envelope: { ...this.osc2Envelope },
                    
                    // Reverb settings (COMPLETE)
                    reverb: { ...this.reverb },
                    
                    // Panning settings (COMPLETE)
                    panning: { ...this.panning },
                    
                    // Volume settings
                    volume: {
                        main: this.volume,
                        master: this.masterVolume
                    }
                };
                
                // Preload this preset for instant switching
                this.preloadedPresets.set(presetId, synthState);
                
                console.log(`🎹 Created new piano lock preset: ${presetId}`);
                console.log(`🎹 OSC1: ${synthState.osc1.type} wave, A:${Math.round(synthState.envelope.attack*1000)} D:${Math.round(synthState.envelope.decay*1000)} S:${Math.round(synthState.envelope.sustain*100)}% R:${Math.round(synthState.envelope.release*1000)}`);
                console.log(`🎹 OSC2: ${synthState.osc2.type} wave, A:${Math.round(synthState.osc2Envelope.attack*1000)} D:${Math.round(synthState.osc2Envelope.decay*1000)} S:${Math.round(synthState.osc2Envelope.sustain*100)}% R:${Math.round(synthState.osc2Envelope.release*1000)}`);
                
                return synthState;
            }
            
            // Migrate existing piano locks from old format (with root) to new format (without root)
            migratePianoLocksToNewFormat() {
                if (!this.pianoLockedChords || this.pianoLockedChords.size === 0) return;
                
                console.log('🎹 MIGRATING piano locks to new format (removing root dependency)');
                const oldEntries = Array.from(this.pianoLockedChords.entries());
                const newPianoLocks = new Map();
                const newPreloadedPresets = new Map();
                
                oldEntries.forEach(([oldKey, pianoData]) => {
                    // Check if this is an old-format key (contains root)
                    const keyParts = oldKey.split('_');
                    if (keyParts.length >= 4) {
                        // Old format: chordName_quality_root_extensions_intervals
                        const [chordName, quality, root, ...rest] = keyParts;
                        
                        // Create new key without root
                        const extensions = rest.length > 1 ? rest[0] : '';
                        const intervals = rest.length > 1 ? rest[1] : rest[0] || '';
                        const newKey = `${chordName}_${quality}_${extensions}_${intervals}`;
                        
                        console.log(`🎹 Migrating: ${oldKey} → ${newKey}`);
                        
                        // Store with new key format
                        newPianoLocks.set(newKey, pianoData);
                        
                        // Also migrate preloaded preset
                        if (pianoData.presetId && this.preloadedPresets.has(pianoData.presetId)) {
                            newPreloadedPresets.set(pianoData.presetId, this.preloadedPresets.get(pianoData.presetId));
                        }
                    } else {
                        // Already new format, keep as-is
                        newPianoLocks.set(oldKey, pianoData);
                        if (pianoData.presetId && this.preloadedPresets.has(pianoData.presetId)) {
                            newPreloadedPresets.set(pianoData.presetId, this.preloadedPresets.get(pianoData.presetId));
                        }
                    }
                });
                
                // Replace old maps with migrated data
                this.pianoLockedChords = newPianoLocks;
                this.preloadedPresets = newPreloadedPresets;
                
                console.log('🎹 Migration complete. Piano locks now work across all root notes!');
            }
            
            // Generate stable key for piano lock identification
            generatePianoLockKey(chordData) {
                // Create a stable identifier based on chord content, not DOM elements
                // EXCLUDE root note so piano locks work across all root changes
                const chordName = chordData.name || 'unknown';
                const quality = chordData.quality || this.currentQuality || 'major';
                const extensions = (chordData.extensions || []).sort().join(',');
                const intervals = (chordData.intervals || []).sort().join(',');
                
                const key = `${chordName}_${quality}_${extensions}_${intervals}`;
                
                // Add detailed debugging
                console.log('🔑 generatePianoLockKey DEBUG:');
                console.log('  - Chord Name:', chordName);
                console.log('  - Quality:', quality);
                console.log('  - Extensions:', extensions);
                console.log('  - Intervals:', intervals);
                console.log('  - Generated Key:', key);
                console.log('  - Full chordData:', chordData);
                
                return key;
            }
            
            // Find piano lock data by stable key
            findPianoLockData(chordData) {
                if (!this.pianoLockedChords) return null;
                
                const key = this.generatePianoLockKey(chordData);
                return this.pianoLockedChords.get(key) || null;
            }
            
            lockPianoSettings(chordData, columnElement) {
                console.log('🎹 lockPianoSettings function called with:', chordData, columnElement);
                
                // Check if this chord already has piano-locked settings using stable key
                if (!this.pianoLockedChords) this.pianoLockedChords = new Map();
                
                const lockKey = this.generatePianoLockKey(chordData);
                const isAlreadyPianoLocked = this.pianoLockedChords.has(lockKey);
                
                if (isAlreadyPianoLocked) {
                    // UNLOCK the piano settings
                    console.log('🎹 Unlocking piano settings for:', chordData.name, 'key:', lockKey);
                    
                    this.pianoLockedChords.delete(lockKey);
                    
                    // Update UI - change piano lock button to unlocked state
                    const pianoLockButton = columnElement.querySelector('.piano-lock-button');
                    if (pianoLockButton) {
                        pianoLockButton.classList.remove('locked');
                        pianoLockButton.title = 'Lock oscillator & effect settings only';
                    }
                    
                    // Reset chord extension data to indicate unlocked state
                    chordData.isPianoLocked = false;
                    chordData.pianoLockedData = null;
                    
                    console.log('🎹 Piano settings unlocked for:', chordData.name);
                    return;
                }
                
                // LOCK the piano settings
                console.log('🎹 Locking piano settings for:', chordData.name, 'key:', lockKey);
                
                // Capture current synthesizer state at the time of locking
                const currentSynthState = this.captureCurrentSynthState();
                const pianoLockedData = {
                    // Chord identification
                    chordName: chordData.name,
                    lockKey: lockKey,
                    
                    // All settings captured from current synth state
                    ...currentSynthState,
                    
                    // Timestamp
                    timestamp: Date.now()
                };
                
                // Store in pianoLockedChords map using stable key
                console.log('🎹 STORING piano lock with key:', lockKey);
                console.log('🎹 Current piano locks before storing:', Array.from(this.pianoLockedChords.keys()));
                
                // Check if this key already exists (collision detection)
                if (this.pianoLockedChords.has(lockKey)) {
                    console.log('⚠️  KEY COLLISION DETECTED! Overwriting existing piano lock:', lockKey);
                    const existingLock = this.pianoLockedChords.get(lockKey);
                    console.log('⚠️  Existing lock data:', existingLock);
                }
                
                this.pianoLockedChords.set(lockKey, pianoLockedData);
                
                console.log('🎹 Piano locks after storing:', Array.from(this.pianoLockedChords.keys()));
                console.log('🎹 Total piano locks:', this.pianoLockedChords.size);
                
                // Update the chord extension data to indicate piano locked state
                chordData.isPianoLocked = true;
                chordData.pianoLockedData = pianoLockedData;
                chordData.pianoLockKey = lockKey; // Store the key for reference
                
                // Update UI - change piano lock button to locked state
                const pianoLockButton = columnElement.querySelector('.piano-lock-button');
                if (pianoLockButton) {
                    pianoLockButton.classList.add('locked');
                    pianoLockButton.title = 'LOCKED oscillator & effect settings - click to unlock';
                }
                
                console.log('🎹 Piano settings locked for:', chordData.name, 'with key:', lockKey, pianoLockedData);
            }
            
            // Apply piano-locked settings when playing a chord (NEVER modifies base synthesizer state)
            applyPianoLockedSettings(pianoLockedData) {
                if (!pianoLockedData) return;
                
                const presetId = pianoLockedData.presetId;
                console.log(`🎹 Applying piano-locked preset: ${presetId} (${pianoLockedData.chordName})`);
                
                // Use preloaded preset if available for instant switching
                let settingsToApply = pianoLockedData;
                if (this.preloadedPresets.has(presetId)) {
                    settingsToApply = this.preloadedPresets.get(presetId);
                    console.log(`🎹 Using preloaded preset for instant switching: ${presetId}`);
                } else {
                    console.log(`🎹 Preset not preloaded, using stored data: ${presetId}`);
                }
                
                console.log(`🎹 OSC1: ${settingsToApply.osc1.type} wave, A:${Math.round(settingsToApply.envelope.attack*1000)} D:${Math.round(settingsToApply.envelope.decay*1000)} S:${Math.round(settingsToApply.envelope.sustain*100)}% R:${Math.round(settingsToApply.envelope.release*1000)}`);
                console.log(`🎹 OSC2: ${settingsToApply.osc2.type} wave, A:${Math.round(settingsToApply.osc2Envelope.attack*1000)} D:${Math.round(settingsToApply.osc2Envelope.decay*1000)} S:${Math.round(settingsToApply.osc2Envelope.sustain*100)}% R:${Math.round(settingsToApply.osc2Envelope.release*1000)}`);
                
                // IMPORTANT: We directly modify the synthesizer objects only temporarily
                // These will be immediately restored after playFrequency starts
                
                // Apply oscillator settings (complete objects)
                if (settingsToApply.osc1) {
                    Object.assign(this.oscillators.osc1, settingsToApply.osc1);
                }
                if (settingsToApply.osc2) {
                    Object.assign(this.oscillators.osc2, settingsToApply.osc2);
                }
                
                // Apply envelope settings (complete objects)
                if (settingsToApply.envelope) {
                    Object.assign(this.envelope, settingsToApply.envelope);
                }
                if (settingsToApply.osc2Envelope) {
                    Object.assign(this.osc2Envelope, settingsToApply.osc2Envelope);
                }
                
                // Apply reverb settings
                if (settingsToApply.reverb) {
                    Object.assign(this.reverb, settingsToApply.reverb);
                    
                    // Apply to audio context nodes if available
                    if (this.wetGainNode && this.dryGainNode) {
                        this.wetGainNode.gain.value = this.reverb.wet;
                        this.dryGainNode.gain.value = 1.0 - this.reverb.wet;
                    }
                    if (this.reverbFilterNode) {
                        this.reverbFilterNode.frequency.value = this.reverb.filterCutoff;
                    }
                }
                
                // Apply panning settings
                if (settingsToApply.panning) {
                    Object.assign(this.panning, settingsToApply.panning);
                }
                
                // Apply volume settings
                if (settingsToApply.volume) {
                    this.volume = settingsToApply.volume.main;
                    this.masterVolume = settingsToApply.volume.master;
                    if (this.gainNode) {
                        this.gainNode.gain.value = this.volume * this.masterVolume;
                    }
                }
                
                console.log(`🎹 Applied piano-locked preset: ${presetId} for ${pianoLockedData.chordName}`);
            }
            
            // Helper to capture exact frequencies from a column's strings when locking
            captureStringFrequencies(columnElement) {
                console.log('?? Capturing exact string frequencies for locked chord');
                const stringElements = columnElement.querySelectorAll('.string');
                const frequencies = [];
                
                stringElements.forEach(stringElement => {
                    // Get exact frequency from the element dataset
                    // This will be the actual frequency value used in playback
                    const freq = parseFloat(stringElement.dataset.frequency);
                    if (!isNaN(freq)) {
                        frequencies.push(freq);
                        console.log(`?? Captured frequency: ${freq.toFixed(2)} Hz`);
                    }
                });
                
                console.log(`?? Total frequencies captured: ${frequencies.length}`);
                return frequencies.length > 0 ? frequencies : null;
            }
            
            // Create strings using exact captured frequencies - guaranteed perfect reproduction
            generateStringsWithExactFrequencies(column, lockedData) {
                console.log('?? Generating strings with EXACT frequencies for perfect reproduction');
                
                // Clear any existing strings
                const stringsContainer = document.createElement('div');
                stringsContainer.className = 'strings-column';
                
                // Style the container like main columns
                stringsContainer.style.cssText = `
                    flex: 1;
                    overflow: hidden;
                    padding: 1px;
                    height: calc(100% - 40px);
                    display: flex;
                    flex-direction: column;
                    justify-content: space-evenly;
                `;
                
                // Remove old strings container if exists
                const oldContainer = column.querySelector('.strings-column');
                if (oldContainer) {
                    column.removeChild(oldContainer);
                }
                
                // Create strings using exact frequencies
                lockedData.exactFrequencies.forEach((freq, index) => {
                    const stringElement = document.createElement('div');
                    stringElement.className = 'string';

                    // Store exact frequency for playback - CRITICAL
                    stringElement.dataset.frequency = freq;

                    // Estimate note and octave for display and color calculation
                    const noteInfo = this.estimateNoteFromFrequency(freq);
                    stringElement.dataset.note = noteInfo.note;
                    stringElement.dataset.octave = noteInfo.octave;

                    // Calculate interval from the locked root to get proper color
                    const intervalFromRoot = (noteInfo.note - lockedData.lockedRoot + lockedData.lockedTuning) % lockedData.lockedTuning;
                    const intervalColor = this.getIntervalColor(intervalFromRoot);
                    const baseColor = intervalColor.color;
                    const glowColor = (baseColor && baseColor.toLowerCase() === '#000000') ? '#555555' : baseColor;
                    stringElement.dataset.glowColor = glowColor;

                    // Visible core
                    const core = document.createElement('div');
                    core.className = 'string-core';
                    core.style.background = baseColor;
                    core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;

                    // Tooltip with exact frequency
                    const noteDisplay = this.getNoteNames()[noteInfo.note] || noteInfo.note;
                    stringElement.title = `${noteDisplay}${noteInfo.octave} - LOCKED: ${freq.toFixed(2)}Hz`;

                    // Precompute vibration period
                    const period = this.computeVibrationPeriod(freq, noteInfo.note);
                    core.style.setProperty('--vib-period', period + 'ms');

                    // Click handlers for playback
                    this.addStringPlaybackHandlers(stringElement, freq);

                    // Attach
                    stringElement.appendChild(core);
                    stringsContainer.appendChild(stringElement);
                });
                
                column.appendChild(stringsContainer);
                
                // Add locked icon and visual indication this is using exact frequencies
                const header = column.querySelector('.extension-header');
                if (header) {
                    const chordName = header.querySelector('.chord-name');
                    if (chordName) {
                        chordName.style.color = '#ff9500'; // Bright orange to indicate exact frequency preservation
                        chordName.title = `LOCKED: Using exact frequencies (${lockedData.exactFrequencies.length}) for perfect reproduction`;
                    }
                }
                
                console.log(`?? Generated ${lockedData.exactFrequencies.length} strings with exact frequencies`);
            }
            
            // Helper to add click handlers to strings
            addStringPlaybackHandlers(stringElement, frequency) {
                // Add click handlers for immediate playback
                stringElement.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.playStringNote(frequency, 0); // Use exact frequency

                    // Visual feedback on core
                    const glow = stringElement.dataset.glowColor || '#FFFFFF';
                    const core = stringElement.querySelector('.string-core');
                    if (core) {
                        core.style.transform = 'scaleY(1.3)';
                        core.style.boxShadow = `0 0 6px ${glow}, 0 0 16px ${glow}B3, 0 0 24px ${glow}80`;
                        core.style.filter = 'brightness(1.15)';
                        const stepIndex = parseInt(stringElement.dataset.noteIndex||'0',10);
                        const period = this.computeVibrationPeriod(frequency, stepIndex);
                        core.style.setProperty('--vib-period', period + 'ms');
                        core.classList.add('vibrating');
                        setTimeout(() => core.classList.remove('vibrating'), 220);
                        setTimeout(() => {
                            core.style.transform = 'scaleY(1)';
                            core.style.boxShadow = `0 0 4px ${glow}, 0 0 10px ${glow}AA, 0 0 18px ${glow}66`;
                            core.style.filter = 'brightness(1)';
                        }, 200);
                    }
                });
                
                // Touch support
                stringElement.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.playStringNote(frequency, 0); // Use exact frequency
                });
            }
            
            // ============= PROPER CHORD NAMING SYSTEM =============
            
            getProperChordSymbol(intervals) {
                if (!intervals || intervals.length === 0) return '';
                
                // Sort intervals and remove duplicates
                const uniqueIntervals = [...new Set(intervals)].sort((a, b) => a - b);
                const numNotes = uniqueIntervals.length;
                
                // Special cases
                if (numNotes >= 24) return 'Cluster';
                if (numNotes === this.currentTuning) return 'Chromatic Scale';
                
                // Convert intervals to set for easy lookup
                const intervalSet = new Set(uniqueIntervals);
                
                // Helper function to check if intervals match a pattern (adjusted for current tuning)
                const hasIntervals = (...pattern) => {
                    // Convert 12-TET intervals to current tuning
                    const convertedPattern = pattern.map(interval => Math.round(interval * this.currentTuning / 12));
                    return convertedPattern.every(interval => intervalSet.has(interval));
                };
                
                // 🎵 UNISON (single note) - only root note
                if (numNotes === 1 && uniqueIntervals[0] === 0) {
                    return 'Unison';
                }
                
                // 🎵 DYADS (2-note intervals) - adjusted for current tuning
                if (numNotes === 2 && uniqueIntervals[0] === 0) {
                    const interval = uniqueIntervals[1];
                    const interval12TET = Math.round(interval * 12 / this.currentTuning);
                    
                    const intervalNames = {
                        1: 'Minor 2nd',
                        2: 'Major 2nd', 
                        3: 'Minor 3rd',
                        4: 'Major 3rd',
                        5: 'Perfect 4th',
                        6: 'Tritone',
                        7: 'Perfect 5th',
                        8: 'Minor 6th',
                        9: 'Major 6th',
                        10: 'Minor 7th',
                        11: 'Major 7th'
                    };
                    
                    return intervalNames[interval12TET] || `${interval12TET} semitones`;
                }
                
                // Normalize to pitch classes (ignore octaves)
                const edo = this.currentTuning || 12;
                const pitchClasses = [...new Set(uniqueIntervals.map(i => ((i % edo) + edo) % edo))].sort((a,b)=>a-b);

                // Helper to map EDO steps to rounded 12-TET semitones for pattern matching
                const to12 = step => Math.round((step * 12) / edo);

                // Inversion-invariant matcher: check all possible roots (each pitch class)
                const matchInversions = (targetSets) => {
                    // targetSets: array of {set:[...12-semis], name:string}
                    const results = [];
                    for (const rootPc of pitchClasses) {
                        const rel = pitchClasses.map(pc => (pc - rootPc + edo) % edo);
                        const rel12 = [...new Set(rel.map(to12))].sort((a,b)=>a-b);
                        for (const t of targetSets) {
                            if (t.set.length !== rel12.length) continue;
                            let ok = true;
                            for (let i=0;i<t.set.length;i++) if (t.set[i] !== rel12[i]) { ok=false; break; }
                            if (ok) results.push(t.name);
                        }
                    }
                    return results;
                };

                // 🎵 TRIADS (3-note chords) - inversion-invariant
                if (pitchClasses.length === 3) {
                    const triadTargets = [
                        { set:[0,4,7], name:'Major' },
                        { set:[0,3,7], name:'m' },
                        { set:[0,3,6], name:'°' },
                        { set:[0,4,8], name:'+' },
                        { set:[0,2,7], name:'sus2' },
                        { set:[0,5,7], name:'sus4' },
                    ];
                    const hits = matchInversions(triadTargets);
                    if (hits.length) {
                        // Simple priority for suspensions over diminished/aug if ambiguous
                        const order = ['Major','m','sus4','sus2','°','+'];
                        const pick = order.find(n => hits.includes(n)) || hits[0];
                        return pick;
                    }
                }

                // 🎵 TETRADS (4-note chords) - inversion-invariant with 6/m6 preference over 7/m7
                if (pitchClasses.length === 4) {
                    const tetradTargets = [
                        { set:[0,4,7,9],  name:'6'   },
                        { set:[0,3,7,9],  name:'m6'  },
                        { set:[0,4,7,11], name:'Δ7'  },
                        { set:[0,4,7,10], name:'7'   },
                        { set:[0,3,7,10], name:'m7'  },
                        { set:[0,3,7,11], name:'mΔ7' },
                        { set:[0,3,6,10], name:'ø7'  },
                        { set:[0,3,6,9],  name:'°7'  },
                        { set:[0,5,7,10], name:'7sus4' },
                    ];
                    const hits = matchInversions(tetradTargets);
                    if (hits.length) {
                        // Preference order: 6/m6 > Δ7 > 7/m7 > others
                        const order = ['6','m6','Δ7','7','m7','mΔ7','ø7','°7','7sus4'];
                        const pick = order.find(n => hits.includes(n)) || hits[0];
                        return pick;
                    }
                }
                
                // 🎵 5-NOTE CHORDS - adjusted for current tuning
                if (numNotes === 5) {
                    if (hasIntervals(0, 4, 7, 2)) return 'add9'; // Add 9
                    if (hasIntervals(0, 3, 7, 2)) return 'madd9'; // Minor Add 9
                    if (hasIntervals(0, 4, 7, 9, 2)) return '6/9'; // 6/9
                    if (hasIntervals(0, 4, 7, 10, 2)) return '9'; // Dominant 9
                    if (hasIntervals(0, 4, 7, 11, 2)) return 'Δ9'; // Major 9
                    if (hasIntervals(0, 3, 7, 10, 2)) return 'm9'; // Minor 9
                    if (hasIntervals(0, 3, 7, 11, 2)) return 'mΔ9'; // Minor/Major 9
                    if (hasIntervals(0, 4, 7, 10, 1)) return '7♭9'; // Dominant 7♭9
                    if (hasIntervals(0, 4, 7, 10, 3)) return '7♯9'; // Dominant 7♯9
                    if (hasIntervals(0, 4, 7, 10, 6)) return '7♯11'; // Dominant 7♯11
                    if (hasIntervals(0, 4, 7, 11, 6)) return 'Δ7♯11'; // Major 7♯11
                    if (hasIntervals(0, 3, 7, 10, 6)) return 'm7♯11'; // Minor 7♯11
                }
                
                // 🎵 6-NOTE CHORDS - adjusted for current tuning
                if (numNotes === 6) {
                    if (hasIntervals(0, 4, 7, 10, 2, 5)) return '11'; // 11th
                    if (hasIntervals(0, 4, 7, 11, 2, 5)) return 'Δ11'; // Major 11
                    if (hasIntervals(0, 3, 7, 10, 2, 5)) return 'm11'; // Minor 11
                    if (hasIntervals(0, 3, 7, 11, 2, 5)) return 'mΔ11'; // Minor/Major 11
                    if (hasIntervals(0, 4, 7, 10, 2, 9)) return '13'; // 13th
                    if (hasIntervals(0, 4, 7, 11, 2, 9)) return 'Δ13'; // Major 13
                    if (hasIntervals(0, 3, 7, 10, 2, 9)) return 'm13'; // Minor 13
                    if (hasIntervals(0, 4, 7, 10, 1, 6)) return '7♭9♯11'; // Dominant 7♭9♯11
                    if (hasIntervals(0, 4, 7, 10, 3, 6)) return '7♯9♯11'; // Dominant 7♯9♯11
                    if (hasIntervals(0, 4, 7, 10, 1, 8)) return '7♭9♭13'; // Dominant 7♭9♭13
                    if (hasIntervals(0, 3, 7, 10, 5, 9)) return 'm11(no9)'; // Minor 11 no 9
                }
                
                // Fall back to nearest fit + additions
                return this.findNearestChordFit(uniqueIntervals);
            }
            
            findNearestChordFit(intervals) {
                // Find the closest standard chord and add extensions
                const core = this.findCoreChord(intervals);
                const extensions = this.findExtensions(intervals, core.intervals);
                
                let symbol = core.symbol;
                if (extensions.length > 0) {
                    symbol += extensions.map(ext => `add${ext}`).join('');
                }
                
                return symbol;
            }
            
            findCoreChord(intervals) {
                // Find the best matching triad or tetrad
                const intervalSet = new Set(intervals);
                
                // Check tetrads first (more specific)
                const tetrads = [
                    { intervals: [0, 4, 7, 11], symbol: 'Δ7' },
                    { intervals: [0, 4, 7, 10], symbol: '7' },
                    { intervals: [0, 3, 7, 10], symbol: 'm7' },
                    { intervals: [0, 3, 7, 11], symbol: 'mΔ7' },
                    { intervals: [0, 4, 7, 9], symbol: '6' },
                    { intervals: [0, 3, 7, 9], symbol: 'm6' },
                    { intervals: [0, 3, 6, 10], symbol: 'ø7' },
                    { intervals: [0, 3, 6, 9], symbol: '°7' },
                    { intervals: [0, 5, 7, 10], symbol: '7sus4' }
                ];
                
                for (const tetrad of tetrads) {
                    if (tetrad.intervals.every(interval => intervalSet.has(interval))) {
                        return tetrad;
                    }
                }
                
                // Check triads
                const triads = [
                    { intervals: [0, 4, 7], symbol: 'Major' }, // Major triad gets full name
                    { intervals: [0, 3, 7], symbol: 'm' },
                    { intervals: [0, 3, 6], symbol: '°' },
                    { intervals: [0, 4, 8], symbol: '+' },
                    { intervals: [0, 2, 7], symbol: 'sus2' },
                    { intervals: [0, 5, 7], symbol: 'sus4' }
                ];
                
                for (const triad of triads) {
                    if (triad.intervals.every(interval => intervalSet.has(interval))) {
                        return triad;
                    }
                }
                
                // Default to major triad if root is present
                return { intervals: [0], symbol: 'Major' };
            }
            
            findExtensions(intervals, coreIntervals) {
                const extensions = [];
                const coreSet = new Set(coreIntervals);
                
                for (const interval of intervals) {
                    if (!coreSet.has(interval) && interval !== 0) {
                        // Convert interval to extension name
                        const extName = this.intervalToExtensionName(interval);
                        if (extName) extensions.push(extName);
                    }
                }
                
                return extensions;
            }
            
            intervalToExtensionName(interval) {
                const extensionMap = {
                    1: '♭9', 2: '9', 3: '♯9', 4: '3', 5: '11', 6: '♯11',
                    7: '5', 8: '♭13', 9: '6/13', 10: '♭7', 11: '7'
                };
                return extensionMap[interval] || interval.toString();
            }
            
            // Estimate note and octave from frequency (for display only)
            estimateNoteFromFrequency(freq) {
                // A4 = 440 Hz is our reference
                const a4 = 440.0;
                const a4NoteNumber = 69; // MIDI note number for A4
                
                // Calculate MIDI note number from frequency
                const noteNumber = 12 * Math.log2(freq / a4) + a4NoteNumber;
                const roundedNoteNumber = Math.round(noteNumber);
                
                // Convert MIDI note number to note and octave
                const octave = Math.floor((roundedNoteNumber - 12) / 12);
                const note = roundedNoteNumber % 12;
                
                return { note, octave };
            }
            
            editLockedChord(chordData, columnElement) {
                // Get the locked chord data to extract the intervals
                const lockedChord = this.lockedChords.get(columnElement);
                if (!lockedChord) {
                    alert('This chord must be locked before it can be edited');
                    return;
                }
                
                console.log('? Editing locked chord:', chordData.name, 'with intervals:', lockedChord.intervals);
                
                // Enter chord creation mode with the locked chord's intervals
                this.enterChordCreationMode();
                
                // Set the intervals from the locked chord
                this.selectedIntervals = [...(lockedChord.intervals || [])];
                
                // Update the note selector to show these intervals
                // Refresh interval selection UI and preview column in builder
                this.updateIntervalButtons();
                this.updatePreviewChordColumn();
                
                // Show the chord name input with current name
                const modal = document.getElementById('chordBuilderModal');
                if (modal) {
                    modal.style.display = 'block';
                    const nameInput = document.getElementById('chordNameInput');
                    if (nameInput) {
                        nameInput.value = chordData.name;
                    }
                }
                
                console.log('? Chord edit mode activated with existing intervals');
            }
            
            hideLockedChord(chordData, columnElement) {
                if (!this.hiddenColumns) this.hiddenColumns = [];
                
                const chordId = chordData.id || chordData.name.toLowerCase().replace(/\s+/g, '_');
                
                if (confirm(`Hide the locked chord "${chordData.name}"? You can show it again from the settings.`)) {
                    // Add to hidden columns
                    if (!this.hiddenColumns.includes(chordId)) {
                        this.hiddenColumns.push(chordId);
                        // localStorage removed - no longer saving hidden columns
                    }
                    
                    // Regenerate columns to hide this one
                    this.generateExtensionColumns();
                    
                    console.log('?? Hidden locked chord:', chordData.name);
                }
            }
            
            duplicateLockedChord(chordData, columnElement) {
                // Get the locked chord data
                const lockedChord = this.lockedChords.get(columnElement);
                if (!lockedChord) {
                    alert('This chord must be locked before it can be duplicated');
                    return;
                }
                
                console.log('? Duplicating locked chord:', chordData.name, 'with intervals:', lockedChord.intervals);
                
                // Create a new chord extension with a copy name
                const duplicateChord = {
                    name: chordData.name + ' Copy',
                    intervals: [...(lockedChord.intervals || [])],
                    extensions: [...(chordData.extensions || [])],
                    quality: chordData.quality || 'major',
                    isCustom: true,
                    id: 'duplicate_' + Date.now()
                };
                
                // Add to chord extensions
                this.chordExtensions.push(duplicateChord);
                this.saveChordConfiguration();
                
                // Regenerate columns
                this.generateExtensionColumns();
                
                // Enter edit mode for the duplicate
                setTimeout(() => {
                    // Find the new column and enter edit mode
                    this.enterChordCreationMode();
                    this.selectedIntervals = [...duplicateChord.intervals];
                    this.updateIntervalButtons();
                    this.updatePreviewChordColumn();
                    
                    const modal = document.getElementById('chordBuilderModal');
                    if (modal) {
                        modal.style.display = 'block';
                        const nameInput = document.getElementById('chordNameInput');
                        if (nameInput) {
                            nameInput.value = duplicateChord.name;
                        }
                    }
                }, 100);
                
                console.log('? Duplicated and editing chord:', duplicateChord.name);
            }
            
            // Generic functions that work for ALL chords (not just locked ones)
            editChordFromButton(chordData, columnElement) {
                console.log('🔧 EDIT (copy→delete→edit) for:', chordData?.name);
                if (!chordData || !chordData.name) {
                    alert('Error: Invalid chord data for editing');
                    return;
                }
                // Determine the exact index of the clicked chord
                const idx = this.getIndexFromColumn(columnElement, chordData);
                if (idx === -1) {
                    alert('Error: Could not locate the selected chord for editing');
                    return;
                }
                const original = this.chordExtensions[idx];
                if (!original) {
                    alert('Error: Selected chord no longer exists');
                    return;
                }
                // Prepare intervals
                const intervals = (original.intervals && original.intervals.length)
                    ? [...original.intervals]
                    : (chordData.intervals && chordData.intervals.length)
                        ? [...chordData.intervals]
                        : (this.getBaseTriadForQuality(this.stripRootFromName(chordData.name).toLowerCase()) || [0,4,7]);

                // Remove original and set editing flags
                this.chordExtensions.splice(idx, 1);
                this.normalizeChordPositions();
                this.isEditingChord = true;
                this.editingOriginalIndex = idx;
                console.log('🔧 Removed original at', idx, original, '— entering edit mode at same position');

                // First refresh columns to reflect removal
                this.generateExtensionColumns();

                // Then enter builder with the copy data and show preview you can strum
                this.enterChordCreationMode();
                this.selectedIntervals = [...intervals];
                this.updateIntervalButtons();
                this.updatePreviewChordColumn();
                setTimeout(() => {
                    const nameInput = document.getElementById('chordNameInput');
                    if (nameInput) nameInput.value = original.name;
                }, 0);
            }
            
            hideChordFromButton(chordData, columnElement) {
                // Repurpose as Delete Chord
                console.log('🗑️ DELETE for:', chordData?.name);
                if (!chordData || !chordData.name) {
                    alert('Error: Invalid chord data for delete');
                    return;
                }
                if (!confirm(`Delete the chord "${chordData.name}"? This cannot be undone.`)) return;
                const idx = this.getIndexFromColumn(columnElement, chordData);
                if (idx !== -1) {
                    this.chordExtensions.splice(idx, 1);
                    this.normalizeChordPositions();
                }
                this.generateExtensionColumns();
            }
            
            duplicateChordFromButton(chordData, columnElement) {
                console.log('📋 DUPLICATE for:', chordData?.name);
                if (!chordData || !chordData.name) {
                    alert('Error: Invalid chord data for duplication');
                    return;
                }
                // Find base chord and position
                const idx = this.getIndexFromColumn(columnElement, chordData);
                const base = (idx !== -1 && this.chordExtensions[idx]) ? this.chordExtensions[idx] : chordData;
                const intervals = (base.intervals && base.intervals.length)
                    ? [...base.intervals]
                    : (this.getBaseTriadForQuality(this.stripRootFromName(base.name).toLowerCase()) || [0,4,7]);

                // Open editor for a duplicate without inserting yet; on save insert after original
                this.isEditingChord = true;
                this.editingOriginalIndex = (idx !== -1) ? (idx + 1) : this.chordExtensions.length;
                this.enterChordCreationMode();
                this.selectedIntervals = [...intervals];
                this.updateIntervalButtons();
                this.updatePreviewChordColumn();
                setTimeout(() => {
                    const nameInput = document.getElementById('chordNameInput');
                    if (nameInput) nameInput.value = `${base.name} Copy`;
                }, 0);
            }

            // --- Helpers to robustly find the clicked chord in this.chordExtensions ---
            findChordIndex(chordData) {
                // Prefer exact id match
                if (chordData && chordData.id) {
                    const byId = this.chordExtensions.findIndex(ext => ext && ext.id === chordData.id);
                    if (byId !== -1) return byId;
                }
                // Fallback: name + intervals match
                const intervals = (chordData && (chordData.intervals || chordData.notes)) || [];
                const key = JSON.stringify(intervals);
                const byStruct = this.chordExtensions.findIndex(ext => {
                    if (!ext) return false;
                    if (ext.name !== chordData.name) return false;
                    const extIntervals = ext.intervals || [];
                    return JSON.stringify(extIntervals) === key;
                });
                if (byStruct !== -1) return byStruct;
                // Last resort: position if present
                if (typeof chordData.position === 'number') return chordData.position;
                return -1;
            }

            getIndexFromColumn(columnElement, chordData) {
                // First trust the dataset from the DOM column created with this chord
                const ds = columnElement && columnElement.dataset ? columnElement.dataset : {};
                if (ds && typeof ds.originalPosition !== 'undefined') {
                    const idx = parseInt(ds.originalPosition, 10);
                    if (!Number.isNaN(idx) && idx >= 0 && idx < this.chordExtensions.length) return idx;
                }
                // Then try to calculate from chordData
                const fallbackIdx = this.findChordIndex(chordData);
                if (fallbackIdx !== -1) return fallbackIdx;
                // Give up gracefully
                return -1;
            }
            
            findChordPosition(chordData) {
                // Find the position of this chord in the chordExtensions array
                for (let i = 0; i < this.chordExtensions.length; i++) {
                    const chord = this.chordExtensions[i];
                    if (chord.name === chordData.name && 
                        chord.id === chordData.id ||
                        (chord.isCustom === chordData.isCustom && chord.name === chordData.name)) {
                        return i;
                    }
                }
                return this.chordExtensions.length; // Default to end if not found
            }

            // Remove pitch-class prefix from chord names (e.g., "Csus4" -> "sus4")
            stripRootFromName(name) {
                if (!name) return '';
                return String(name).replace(/^[A-G][#b]?\s*/, '').trim();
            }
            
            applyLockedChordSettings(lockedChord) {
                console.log('?? Applying locked chord settings:', lockedChord);
                
                // Apply locked musical settings (MOST IMPORTANT - the locked root!)
                this.currentRoot = lockedChord.lockedRoot;
                this.currentQuality = lockedChord.quality;
                this.currentTuning = lockedChord.lockedTuning;
                this.gamelanMode = lockedChord.lockedGamelanMode;
                
                // Apply locked oscillator settings
                this.oscillators.osc1 = { ...lockedChord.lockedOsc1 };
                this.oscillators.osc2 = { ...lockedChord.lockedOsc2 };
                
                // Apply locked envelope settings
                this.envelope = { ...lockedChord.lockedEnvelope };
                this.osc2Envelope = { ...lockedChord.lockedOsc2Envelope };
                
                // Apply locked effects settings
                this.reverbWet = lockedChord.lockedEffects.reverbWet;
                if (this.reverb) this.reverb.decay = lockedChord.lockedEffects.reverbDecay;
                if (this.reverbFilterNode) this.reverbFilterNode.frequency.value = lockedChord.lockedEffects.reverbFilterCutoff;
                this.panning.mode = lockedChord.lockedEffects.panningMode;
                this.panning.width = lockedChord.lockedEffects.panningWidth;
                
                // Apply locked volume settings
                this.masterVolume = lockedChord.lockedVolume.master;
                this.volume = lockedChord.lockedVolume.main;
                
                console.log('?? Applied locked settings - root:', this.currentRoot, 'tuning:', this.currentTuning, 'quality:', this.currentQuality);
            }
            
            loadLockedChords() {
                // No localStorage - always return empty (start fresh each session)
                return null;
            }
            
            restoreLockedChordStates() {
                if (!this.savedLockedChords || this.savedLockedChords.length === 0) {
                    console.log('?? No saved locked chords to restore');
                    return;
                }
                
                // Ensure lockedChords Map is initialized
                if (!this.lockedChords) this.lockedChords = new Map();
                
                console.log('?? Restoring locked chord states for', this.savedLockedChords.length, 'locked chords');
                
                // After columns are generated, restore locked states using position-based matching
                this.savedLockedChords.forEach((lockedChord, index) => {
                    console.log('?? Restoring locked chord:', lockedChord.chordName, 'at position:', lockedChord.originalPosition);
                    
                    // Find the matching column element by position and chord data
                    const columns = Array.from(document.querySelectorAll('.extension-column'));
                    
                    // Method 1: Try position-based matching first (most reliable)
                    let targetColumn = null;
                    if (lockedChord.originalPosition !== undefined && columns[lockedChord.originalPosition]) {
                        targetColumn = columns[lockedChord.originalPosition];
                        console.log('?? Using position-based match at index', lockedChord.originalPosition);
                    }
                    
                    // Method 2: If position doesn't work, try finding by chord data
                    if (!targetColumn) {
                        targetColumn = columns.find(column => {
                            const chordType = column.dataset.chordType;
                            const header = column.querySelector('.extension-header');
                            const chordName = header?.querySelector('.chord-name');
                            
                            if (chordName) {
                                const currentText = chordName.textContent.trim();
                                console.log('?? Checking column with text:', currentText, 'against locked chord:', lockedChord.chordName);
                                return this.isChordMatch(currentText, lockedChord);
                            }
                            return false;
                        });
                        
                        if (targetColumn) {
                            console.log('?? Using name-based match');
                        }
                    }
                    
                    // Method 3: If still no match, try by original chord extension index
                    if (!targetColumn && lockedChord.originalPosition !== undefined) {
                        // Find chord extension that matches the locked chord
                        const matchingExtension = this.chordExtensions.find(ext => 
                            ext.name === lockedChord.chordName || 
                            (ext.isCustom && ext.id && lockedChord.lockId && lockedChord.lockId.includes(ext.id))
                        );
                        
                        if (matchingExtension) {
                            const extensionIndex = this.chordExtensions.indexOf(matchingExtension);
                            if (columns[extensionIndex]) {
                                targetColumn = columns[extensionIndex];
                                console.log('?? Using extension-based match at index', extensionIndex);
                            }
                        }
                    }
                    
                    if (targetColumn) {
                        console.log('?? Found matching column for:', lockedChord.chordName);
                        
                        // Restore the locked state
                        this.lockedChords.set(targetColumn, lockedChord);
                        
                        // Update UI immediately
                        const lockButton = targetColumn.querySelector('.lock-button');
                        if (lockButton) {
                            lockButton.innerHTML = '🔒';
                            lockButton.classList.add('locked');
                            const rootName = this.getNoteNames()[lockedChord.lockedRoot] || lockedChord.lockedRoot;
                            lockButton.title = `Locked to ${rootName} root with all settings`;
                        }
                        
                        // Show action buttons for locked chords
                        const editButton = targetColumn.querySelector('.chord-action-button.edit');
                        const hideButton = targetColumn.querySelector('.chord-action-button.delete');
                        const duplicateButton = targetColumn.querySelector('.chord-action-button.duplicate');
                        if (editButton) editButton.style.display = 'flex';
                        if (hideButton) hideButton.style.display = 'flex';
                        if (duplicateButton) duplicateButton.style.display = 'flex';
                        
                        // Update visual styling and show locked root in name
                        const chordNameElement = targetColumn.querySelector('.chord-name');
                        if (chordNameElement) {
                            chordNameElement.style.color = '#4CAF50';
                            chordNameElement.style.fontWeight = 'bold';
                            const rootName = this.getNoteNames()[lockedChord.lockedRoot] || lockedChord.lockedRoot;
                            
                            // ALWAYS show the locked root in the chord name
                            if (lockedChord.chordName.match(/^[A-G][#b]?/)) {
                                // Already has root in name (like "CMaj6"), keep it exactly as locked
                                chordNameElement.textContent = lockedChord.chordName;
                            } else {
                                // Standard chord name, prepend the locked root
                                chordNameElement.textContent = `${rootName}${lockedChord.chordName}`;
                            }
                            
                            chordNameElement.title = `?? LOCKED: ${rootName} root, ${lockedChord.lockedTuning}TET, ${lockedChord.lockedOsc1.type}/${lockedChord.lockedOsc2.type} waves`;
                            
                            // Make sure this chord name never changes by marking it
                            chordNameElement.dataset.isLocked = 'true';
                            chordNameElement.dataset.lockedName = chordNameElement.textContent;
                        }
                        
                        console.log('?? Successfully restored locked chord:', lockedChord.chordName, 'at position', lockedChord.originalPosition);
                    } else {
                        console.warn('?? Could not find matching column for locked chord:', lockedChord.chordName, 'position:', lockedChord.originalPosition);
                        console.warn('?? Available columns:', columns.length, 'chord extensions:', this.chordExtensions.length);
                    }
                });
                
                console.log('?? Finished restoring locked chord states. Active locked chords:', this.lockedChords.size);
            }
            
            isChordMatch(currentText, lockedChord) {
                const chordBaseName = lockedChord.chordName;
                
                // Exact match (for custom chords like "CMaj6")
                if (currentText === chordBaseName) {
                    return true;
                }
                // Partial match (for complex chord names)
                if (currentText.includes(chordBaseName) || chordBaseName.includes(currentText)) {
                    return true;
                }
                // Quality-based match (for standard chords)
                if (lockedChord.quality && (
                    currentText.toLowerCase().includes(lockedChord.quality.toLowerCase()) ||
                    currentText.includes('Maj') && lockedChord.quality.includes('major') ||
                    currentText.includes('Min') && lockedChord.quality.includes('minor') ||
                    currentText.includes('Neu') && lockedChord.quality.includes('neutral')
                )) {
                    return true;
                }
                return false;
            }
            
            clearLockedChords() {
                if (confirm('Clear all locked chords?')) {
                    // Clear the locked chords map
                    this.lockedChords = new Map();
                    
                    // Clear localStorage
                    // localStorage removed
                    
                    // Reset all lock buttons to unlocked state
                    document.querySelectorAll('.lock-button').forEach(button => {
                        button.innerHTML = '🔓';
                        button.classList.remove('locked');
                        button.title = 'Lock chord with current root & settings';
                    });
                    
                    // Reset chord header colors to indicate unlocked
                    document.querySelectorAll('.extension-header .chord-name').forEach(chordName => {
                        chordName.style.color = '#fff'; // Reset to default color
                        chordName.title = ''; // Clear locked indicator
                    });
                    
                    console.log('?? All locked chords cleared from main grid');
                }
            }

            playPaletteChord(chord) {
                // Use locked settings from when the chord was dragged
                const originalRoot = this.currentRoot;
                const originalQuality = this.currentQuality;
                const originalTuning = this.currentTuning;
                const originalGamelanMode = this.gamelanMode;
                
                // Temporarily switch to the chord's locked settings
                this.currentRoot = chord.lockedRoot || chord.root;
                this.currentQuality = chord.quality;
                if (chord.lockedTuning !== undefined) {
                    this.currentTuning = chord.lockedTuning;
                }
                if (chord.lockedGamelanMode !== undefined) {
                    this.gamelanMode = chord.lockedGamelanMode;
                }
                
                // Generate intervals for this chord using locked settings
                let intervals;
                if (chord.intervals) {
                    // Custom chord with specific intervals (already in native tuning)
                    intervals = chord.intervals.map(interval => 
                        (this.currentRoot + interval) % this.currentTuning
                    );
                } else {
                    // Standard chord with extensions
                    const chordIntervals = this.getChordIntervals(chord.extensions);
                    intervals = chordIntervals.map(interval => 
                        (this.currentRoot + interval) % this.currentTuning
                    );
                }
                
                // Play the chord for 1 second with proper ADSR routing
                const baseOctave = 4;
                intervals.forEach(step => {
                    const freq = this.getFrequency(step, baseOctave, this.currentTuning);
                    // Create a dummy element for proper ADSR handling
                    const dummyElement = { classList: { add: () => {}, remove: () => {} } };
                    this.playFrequency(freq, dummyElement);
                });
                
                // Stop all notes after 1 second
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 1000);
                
                // Restore original settings
                this.currentRoot = originalRoot;
                this.currentQuality = originalQuality;
                this.currentTuning = originalTuning;
                this.gamelanMode = originalGamelanMode;
                
                console.log(`Played chord: ${chord.fullName} (${chord.tuningName || 'current tuning'})`);
            }

            renameColumn() {
                const newName = prompt('Enter new column name:', this.currentEditingColumn.name);
                if (newName && newName.trim()) {
                    this.currentEditingColumn.name = newName.trim();
                    this.updateColumnInStorage();
                    this.generateExtensionColumns();
                }
            }

            copyColumn() {
                // Create a copy of the current column as a new chord extension (not custom chord)
                const baseName = this.currentEditingColumn.originalName || this.currentEditingColumn.name.replace(/^(Maj|Neu|Min)/, '');
                const columnCopy = {
                    name: `${baseName} Copy`,
                    extensions: [...(this.currentEditingColumn.extensions || [])],
                    intervals: this.currentEditingColumn.intervals || null
                };
                
                // Add to chord extensions so it gets all 3 flavors
                this.chordExtensions.push(columnCopy);
                this.saveChordConfiguration();
                this.generateExtensionColumns();
                
                console.log(`Copied column: ${columnCopy.name}`);
            }

            editColumnPattern() {
                const modal = document.getElementById('editPatternModal');
                const title = document.getElementById('editPatternTitle');
                const nameInput = document.getElementById('editPatternName');
                
                title.textContent = `Edit Pattern: ${this.currentEditingColumn.name}`;
                nameInput.value = this.currentEditingColumn.name;
                
                this.setupIntervalEditor();
                modal.style.display = 'block';
            }

            setupIntervalEditor() {
                const editor = document.getElementById('intervalEditor');
                editor.innerHTML = '';
                
                // Create interval input fields for common intervals
                const intervals = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
                
                intervals.forEach(interval => {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `interval_${interval}`;
                    checkbox.value = interval;
                    
                    const label = document.createElement('label');
                    label.htmlFor = `interval_${interval}`;
                    label.textContent = interval;
                    label.style.cssText = 'display: flex; align-items: center; gap: 5px; padding: 5px; background: #16213e; border-radius: 3px; cursor: pointer;';
                    
                    label.prepend(checkbox);
                    editor.appendChild(label);
                });
            }

            setQuickPattern(intervals) {
                // Convert 12TET intervals to current tuning system
                const currentTuning = this.getTuningStepsPerOctave();
                const convertedIntervals = intervals.map(interval => {
                    // Convert from 12TET to current tuning
                    return Math.round((interval / 12) * currentTuning);
                });
                
                console.log(`?? Converting intervals from 12TET ${intervals} to ${currentTuning}EDO: ${convertedIntervals}`);
                
                // Clear all checkboxes
                document.querySelectorAll('#intervalEditor input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                
                // Check the converted intervals
                convertedIntervals.forEach(interval => {
                    const checkbox = document.getElementById(`interval_${interval}`);
                    if (checkbox) {
                        checkbox.checked = true;
                        console.log(`? Checked interval ${interval} in ${currentTuning}EDO`);
                    }
                });
                
                // Also update the chord creation mode if active
                if (this.chordCreationMode) {
                    this.selectedIntervals = [...convertedIntervals];
                    this.updateIntervalButtons();
                    this.updatePreviewChordColumn();
                }
            }

            saveEditedPattern() {
                const nameInput = document.getElementById('editPatternName');
                const selectedIntervals = Array.from(document.querySelectorAll('#intervalEditor input[type="checkbox"]:checked'))
                    .map(cb => parseInt(cb.value))
                    .sort((a, b) => a - b);

                if (selectedIntervals.length === 0) {
                    alert('Please select at least one interval.');
                    return;
                }

                // Update the column
                this.currentEditingColumn.name = nameInput.value;
                this.currentEditingColumn.intervals = selectedIntervals;
                
                this.updateColumnInStorage();
                document.getElementById('editPatternModal').style.display = 'none';
                this.generateExtensionColumns();
            }

            moveColumn(direction) {
                const currentId = this.currentEditingColumn.id || this.currentEditingColumn.name.toLowerCase();
                const currentIndex = this.chordExtensions.findIndex(ext => 
                    ext.name.toLowerCase() === currentId || ext.name === this.currentEditingColumn.name
                );
                
                if (currentIndex === -1) return;
                
                const newIndex = currentIndex + direction;
                if (newIndex < 0 || newIndex >= this.chordExtensions.length) return;
                
                // Swap the chord extensions
                [this.chordExtensions[currentIndex], this.chordExtensions[newIndex]] = 
                [this.chordExtensions[newIndex], this.chordExtensions[currentIndex]];
                
                // Save configuration
                this.saveChordConfiguration();
                
                // Regenerate columns
                this.generateExtensionColumns();
                
                console.log(`Moved column ${this.currentEditingColumn.name} ${direction > 0 ? 'right' : 'left'}`);
            }

            loadChordConfiguration() {
                // No localStorage - always return null (start fresh each session)
                return null;
            }

            saveChordConfiguration() {
                // No localStorage - update session data instead
                this.sessionData.chordExtensions = this.chordExtensions;
                console.log('?? Chord configuration updated in session data');
            }
            
            // ============= OMG FILE SYSTEM =============
            
            saveSessionToFile() {
                // Collect all session data
                const sessionData = {
                    version: "1.0",
                    timestamp: Date.now(),
                    customChords: this.customChords,
                    favoriteChords: this.favoriteChords,
                    paletteChords: this.paletteChords,
                    lockedSonicChords: this.lockedSonicChords,
                    hiddenColumns: this.hiddenColumns,
                    chordExtensions: this.chordExtensions,
                    lockedChords: this.lockedChords ? Array.from(this.lockedChords.values()) : [],
                    currentTuning: this.currentTuning || 12,
                    gamelanMode: this.gamelanMode || false,
                    currentRoot: this.currentRoot || 0,
                    volume: this.volume || 0.5,
                    masterVolume: this.masterVolume || 1,
                    oscillators: this.oscillators,
                    envelope: this.envelope,
                    osc2Envelope: this.osc2Envelope
                };
                
                const dataStr = JSON.stringify(sessionData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `omnichord-session-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.omg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                console.log('?? Session saved to OMG file');
            }
            
            loadSessionFromFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const sessionData = JSON.parse(e.target.result);
                            
                            // Restore all data
                            this.customChords = sessionData.customChords || [];
                            this.favoriteChords = sessionData.favoriteChords || [];
                            this.paletteChords = sessionData.paletteChords || [];
                            this.lockedSonicChords = sessionData.lockedSonicChords || [];
                            this.hiddenColumns = sessionData.hiddenColumns || [];
                            this.chordExtensions = sessionData.chordExtensions || [];
                            
                            // Restore locked chords if any
                            if (sessionData.lockedChords && sessionData.lockedChords.length > 0) {
                                // Convert back to Map structure
                                this.savedLockedChords = sessionData.lockedChords;
                            }
                            
                            // Restore settings
                            if (sessionData.currentTuning) {
                                this.currentTuning = sessionData.currentTuning;
                                const tuningSelect = document.getElementById('edoDivisions');
                                if (tuningSelect) tuningSelect.value = sessionData.currentTuning;
                            }
                            
                            if (sessionData.gamelanMode !== undefined) {
                                this.gamelanMode = sessionData.gamelanMode;
                            }
                            
                            if (sessionData.currentRoot !== undefined) {
                                this.currentRoot = sessionData.currentRoot;
                            }
                            
                            // Restore audio settings
                            if (sessionData.oscillators) {
                                this.oscillators = sessionData.oscillators;
                            }
                            if (sessionData.envelope) {
                                this.envelope = sessionData.envelope;
                            }
                            if (sessionData.osc2Envelope) {
                                this.osc2Envelope = sessionData.osc2Envelope;
                            }
                            
                            // Regenerate the interface
                            this.generateExtensionColumns();
                            this.generateRootButtons();
                            
                            console.log('?? Session loaded from OMG file:', sessionData);
                            resolve(sessionData);
                        } catch (error) {
                            console.error('Error loading session file:', error);
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }
            
            promptSaveOnExit() {
                if (confirm('Save current session to OMG file before exiting?')) {
                    this.saveSessionToFile();
                }
            }
            
            clearUnlockedChords() {
                // Remove all unlocked chords, keeping only locked ones
                console.log('??? Clearing all unlocked chords...');
                console.log('?? Before clearing - chord extensions:', this.chordExtensions.length, 'chords:', this.chordExtensions.map(c => c.name));
                
                // Filter to keep only locked chords
                const lockedChords = this.chordExtensions.filter(chord => chord.isLocked && chord.lockedData);
                
                console.log('? Found locked chords:', lockedChords.length, 'chords:', lockedChords.map(c => c.name));
                
                // If no locked chords, start in chord creation mode
                if (lockedChords.length === 0) {
                    console.log('?? No chords available, starting in chord creation mode');
                    // Start empty - user must create chords from scratch
                    this.chordExtensions = [];
                } else {
                    console.log('?? Keeping only locked chords with preserved data');
                    // IMPORTANT: Keep the full locked chord data structure intact
                    this.chordExtensions = lockedChords.map(chord => ({
                        ...chord,
                        // Ensure intervals from locked data are preserved
                        intervals: chord.lockedData?.intervals || chord.intervals,
                        // Preserve all locked settings
                        lockedRoot: chord.lockedData?.lockedRoot,
                        lockedTuning: chord.lockedData?.lockedTuning,
                        lockedGamelanMode: chord.lockedData?.lockedGamelanMode,
                        // Keep the lock state
                        isLocked: true,
                        lockedData: chord.lockedData
                    }));
                }
                
                // Clear any old localStorage keys that might be confusing things
                // localStorage removed // Clear old key
                
                // Save the cleaned configuration
                this.saveChordConfiguration();
                
                console.log('?? After clearing - chord extensions:', this.chordExtensions.length, 'chords:', this.chordExtensions.map(c => c.name));
                
                // Regenerate the display
                this.generateExtensionColumns();
            }

            addColumn() {
                // Show modal to select chord type
                this.showAddColumnModal();
            }

            showAddColumnModal() {
                // Create modal for adding new column
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 800px;">
                        <h3>Add New Chord Column</h3>
                        <div style="display: flex; gap: 20px;">
                            <div style="flex: 1;">
                                <h4>Preset Chords</h4>
                                <div class="add-column-grid">
                                    ${this.availableChordTypes.map(chord => `
                                        <button class="add-chord-btn" data-chord='${JSON.stringify(chord)}'>
                                            ${chord.name}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <h4>Create Custom Chord</h4>
                                <div style="margin-bottom: 15px;">
                                    <label>Chord Name:</label>
                                    <input type="text" id="customChordName" placeholder="My Chord" style="width: 100%; padding: 5px; margin-top: 5px;">
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <label>Select Notes (0-11 semitones):</label>
                                    <div id="noteSelector" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 10px;">
                                        ${Array.from({length: 12}, (_, i) => `
                                            <label style="display: flex; align-items: center; gap: 5px; padding: 8px; background: #333; border-radius: 4px; cursor: pointer;">
                                                <input type="checkbox" value="${i}" class="note-checkbox" style="cursor: pointer;">
                                                <span class="note-label">${this.getNoteNameFromSemitone(i)}</span>
                                                <button type="button" class="preview-btn" data-note="${i}" style="margin-left: auto; padding: 2px 6px; font-size: 10px; background: #555; border: none; color: white; border-radius: 3px; cursor: pointer;">?</button>
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <button type="button" id="previewChord" class="osc-btn" style="width: 100%;">?? Preview Full Chord</button>
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <button type="button" id="createCustomChord" class="osc-btn" style="width: 100%; background: #059669;">Create Custom Chord</button>
                                </div>
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                        </div>
                    </div>
                `;
                
                // Add event listeners for preset chord selection
                modal.querySelectorAll('.add-chord-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const chordData = JSON.parse(e.target.dataset.chord);
                        this.addChordColumn(chordData);
                        modal.remove();
                    });
                });
                
                // Add event listeners for custom chord creation
                const previewButtons = modal.querySelectorAll('.preview-btn');
                previewButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const note = parseInt(e.target.dataset.note);
                        this.previewNote(note);
                    });
                });
                
                const previewChordBtn = modal.querySelector('#previewChord');
                previewChordBtn.addEventListener('click', () => {
                    this.previewSelectedChord(modal);
                });
                
                const createCustomBtn = modal.querySelector('#createCustomChord');
                createCustomBtn.addEventListener('click', () => {
                    this.createCustomChordFromModal(modal);
                });
                
                document.body.appendChild(modal);
                
                // Close on ESC
                const closeOnEsc = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', closeOnEsc);
                    }
                };
                document.addEventListener('keydown', closeOnEsc);
            }

            getNoteNameFromSemitone(semitone) {
                const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                return notes[semitone];
            }

            previewNote(semitone) {
                // Calculate frequency for the note (using C4 as base)
                const baseFreq = 261.626; // C4
                const frequency = baseFreq * Math.pow(2, semitone / 12);
                
                // Play the note briefly
                this.playFrequency(frequency, 0.5); // 0.5 second duration
                
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 500);
            }

            previewSelectedChord(modal) {
                const selectedNotes = Array.from(modal.querySelectorAll('.note-checkbox:checked'))
                    .map(cb => parseInt(cb.value))
                    .sort((a, b) => a - b);
                
                if (selectedNotes.length === 0) {
                    alert('Please select at least one note to preview.');
                    return;
                }
                
                // Play all selected notes as a chord
                const baseFreq = 261.626; // C4
                selectedNotes.forEach(semitone => {
                    const frequency = baseFreq * Math.pow(2, semitone / 12);
                    this.playFrequency(frequency, 1.0); // 1 second duration
                });
                
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 1000);
            }

            createCustomChordFromModal(modal) {
                const chordName = modal.querySelector('#customChordName').value.trim();
                const selectedNotes = Array.from(modal.querySelectorAll('.note-checkbox:checked'))
                    .map(cb => parseInt(cb.value))
                    .sort((a, b) => a - b);
                
                if (!chordName) {
                    alert('Please enter a chord name.');
                    return;
                }
                
                if (selectedNotes.length === 0) {
                    alert('Please select at least one note.');
                    return;
                }
                
                // Create custom chord data
                const customChordData = {
                    name: chordName,
                    extensions: [], // Custom chords don't use extensions
                    intervals: selectedNotes,
                    isCustomPattern: true
                };
                
                this.addChordColumn(customChordData);
                modal.remove();
            }

            addChordColumn(chordData) {
                if (chordData.isCustomPattern) {
                    // Handle custom chord with specific intervals
                    if (!this.customChords) this.customChords = [];
                    
                    const customChord = {
                        name: chordData.name,
                        notes: chordData.intervals
                    };
                    
                    this.customChords.push(customChord);
                    // localStorage removed - no longer saving custom chords
                } else {
                    // Handle standard chord extension
                    this.chordExtensions.push({ ...chordData });
                    this.saveChordConfiguration();
                }
                
                // Regenerate columns
                this.generateExtensionColumns();
                
                console.log(`Added new chord column: ${chordData.name}`);
            }

            exportChordConfiguration() {
                const config = {
                    chordExtensions: this.chordExtensions,
                    customChords: this.customChords || [],
                    hiddenColumns: this.hiddenColumns || [],
                    exportDate: new Date().toISOString(),
                    version: '1.0'
                };
                
                const dataStr = JSON.stringify(config, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `microtonal-omnichord-config-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
            }
            
            saveSessionAsOMG() {
                // Save complete session state including all settings and locked chords
                const sessionData = {
                    // Chord data
                    chordExtensions: this.chordExtensions,
                    customChords: this.customChords || [],
                    lockedChords: this.savedLockedChords || Array.from(this.lockedChords?.values() || []),
                    paletteChords: this.paletteChords || [],
                    
                    // Piano lock data - COMPLETE PRESERVATION
                    pianoLockedChords: this.pianoLockedChords ? Array.from(this.pianoLockedChords.entries()) : [],
                    preloadedPresets: this.preloadedPresets ? Array.from(this.preloadedPresets.entries()) : [],
                    pianoLockPresetCounter: this.pianoLockPresetCounter || 0,
                    
                    // UI state
                    hiddenColumns: this.hiddenColumns || [],
                    currentRoot: this.currentRoot,
                    currentTuning: this.currentTuning,
                    gamelanMode: this.gamelanMode,
                    
                    // Audio settings
                    masterVolume: this.masterVolume || 0.7,
                    reverbLevel: this.reverbLevel || 0.3,
                    
                    // Oscillator settings
                    osc1: {
                        type: this.osc1Type || 'sine',
                        attack: this.osc1Attack || 10,
                        decay: this.osc1Decay || 200,
                        sustain: this.osc1Sustain || 70,
                        release: this.osc1Release || 800
                    },
                    osc2: {
                        type: this.osc2Type || 'sine',
                        attack: this.osc2Attack || 5,
                        decay: this.osc2Decay || 30,
                        sustain: this.osc2Sustain || 50,
                        release: this.osc2Release || 1000
                    },
                    
                    // Session metadata
                    savedDate: new Date().toISOString(),
                    version: '1.1',
                    fileType: 'OMG-nichord Session'
                };
                
                const dataStr = JSON.stringify(sessionData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `OMG-session-${new Date().toISOString().split('T')[0]}.omg`;
                link.click();
                
                URL.revokeObjectURL(url);
                
                console.log('?? Session saved as .OMG file');
            }
            
            loadSessionFromOMG(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                // Check file extension
                if (!file.name.toLowerCase().endsWith('.omg')) {
                    alert('Please select a .OMG session file');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const sessionData = JSON.parse(e.target.result);
                        
                        // Verify it's an OMG session file
                        if (sessionData.fileType !== 'OMG-nichord Session') {
                            alert('Invalid .OMG session file format');
                            return;
                        }
                        
                        console.log('?? Loading .OMG session file:', sessionData);
                        
                        // Clear ALL existing data first - start fresh
                        this.chordExtensions = [];
                        this.customChords = [];
                        this.paletteChords = [];
                        this.hiddenColumns = [];
                        this.lockedChords = new Map();
                        
                        // ONLY restore locked chords from the OMG file
                        if (sessionData.lockedChords && sessionData.lockedChords.length > 0) {
                            console.log('?? Restoring ONLY locked chords from OMG file:', sessionData.lockedChords.length, 'chords');
                            
                            // Convert locked chords to chord extensions that will appear as locked
                            this.chordExtensions = sessionData.lockedChords.map(locked => ({
                                name: locked.chordName,
                                intervals: locked.intervals,
                                extensions: locked.extensions || [],
                                quality: locked.quality || 'custom',
                                isCustom: true,
                                isLocked: true,
                                lockedData: locked,
                                position: locked.originalPosition || 0
                            }));
                            
                            // Store for restoration after regeneration
                            this.savedLockedChords = sessionData.lockedChords;
                        } else {
                            console.log('?? No locked chords found in OMG file - starting empty');
                        }
                        
                        // Restore global settings (these are OK to restore)
                        if (sessionData.currentRoot !== undefined) {
                            this.currentRoot = sessionData.currentRoot;
                        }
                        if (sessionData.currentTuning !== undefined) {
                            this.currentTuning = sessionData.currentTuning;
                        }
                        if (sessionData.gamelanMode !== undefined) {
                            this.gamelanMode = sessionData.gamelanMode;
                        }
                        
                        // Restore audio settings
                        if (sessionData.masterVolume !== undefined) {
                            this.masterVolume = sessionData.masterVolume;
                        }
                        if (sessionData.reverbLevel !== undefined) {
                            this.reverbLevel = sessionData.reverbLevel;
                        }
                        
                        // Restore oscillator settings
                        if (sessionData.osc1) {
                            this.osc1Type = sessionData.osc1.type || 'sine';
                            this.osc1Attack = sessionData.osc1.attack || 10;
                            this.osc1Decay = sessionData.osc1.decay || 200;
                            this.osc1Sustain = sessionData.osc1.sustain || 70;
                            this.osc1Release = sessionData.osc1.release || 800;
                        }
                        if (sessionData.osc2) {
                            this.osc2Type = sessionData.osc2.type || 'sine';
                            this.osc2Attack = sessionData.osc2.attack || 5;
                            this.osc2Decay = sessionData.osc2.decay || 30;
                            this.osc2Sustain = sessionData.osc2.sustain || 50;
                            this.osc2Release = sessionData.osc2.release || 1000;
                        }
                        
                        // Restore piano lock data - COMPLETE RESTORATION
                        if (sessionData.pianoLockedChords && sessionData.pianoLockedChords.length > 0) {
                            console.log('🎹 Restoring piano locks from OMG file:', sessionData.pianoLockedChords.length, 'locks');
                            this.pianoLockedChords = new Map(sessionData.pianoLockedChords);
                        } else {
                            this.pianoLockedChords = new Map();
                        }
                        
                        if (sessionData.preloadedPresets && sessionData.preloadedPresets.length > 0) {
                            console.log('🎹 Restoring preloaded presets from OMG file:', sessionData.preloadedPresets.length, 'presets');
                            this.preloadedPresets = new Map(sessionData.preloadedPresets);
                        } else {
                            this.preloadedPresets = new Map();
                        }
                        
                        if (sessionData.pianoLockPresetCounter !== undefined) {
                            this.pianoLockPresetCounter = sessionData.pianoLockPresetCounter;
                        }
                        
                        // Save all data to localStorage
                        this.saveChordConfiguration();
                        
                        // Regenerate everything with only locked chords
                        this.generateRootButtons();
                        this.generateExtensionColumns();
                        this.renderPaletteChords();
                        
                        // Restore locked chord states after generation
                        if (this.savedLockedChords && this.savedLockedChords.length > 0) {
                            setTimeout(() => {
                                this.restoreLockedChordStates();
                            }, 100); // Small delay to ensure DOM is ready
                        }
                        
                        // Ensure ready for new chord creation without auto-entering chord mode
                        console.log('🎹 OMG session loaded - ready for new chord creation with "New Chord" button');
                        // DO NOT auto-enter chord creation mode - user should click "New Chord" when ready
                        
                        alert(`Session restored successfully!\nLoaded ${sessionData.lockedChords ? sessionData.lockedChords.length : 0} locked chords and ${sessionData.pianoLockedChords ? sessionData.pianoLockedChords.length : 0} piano locks from: ${sessionData.savedDate}`);
                        console.log('?? OMG session loaded - showing only locked chords, tuning and root changeable');
                        
                    } catch (error) {
                        alert('Error loading session: Invalid .OMG file format');
                        console.error('Load error:', error);
                    }
                };
                reader.readAsText(file);
                
                // Reset file input
                event.target.value = '';
            }

            importChordConfiguration(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const config = JSON.parse(e.target.result);
                        
                        if (config.chordExtensions) {
                            this.chordExtensions = config.chordExtensions;
                        }
                        if (config.customChords) {
                            this.customChords = config.customChords;
                            // localStorage removed - no longer saving custom chords
                        }
                        if (config.hiddenColumns) {
                            this.hiddenColumns = config.hiddenColumns;
                            // localStorage removed - no longer saving hidden columns
                        }
                        
                        this.saveChordConfiguration();
                        this.generateExtensionColumns();
                        
                        alert('Configuration imported successfully!');
                    } catch (error) {
                        alert('Error importing configuration: Invalid file format');
                        console.error('Import error:', error);
                    }
                };
                reader.readAsText(file);
                
                // Reset file input
                event.target.value = '';
            }

            resetToDefaults() {
                if (confirm('Reset completely? This will remove ALL chords and start fresh.')) {
                    // Clear all storage
                    // localStorage removed - no longer clearing chord config
                    // localStorage removed
                    // localStorage removed
                    // localStorage removed
                    // localStorage removed
                    
                    // Reset to completely empty state
                    this.chordExtensions = [];
                    this.customChords = [];
                    this.hiddenColumns = [];
                    this.lockedChords = new Map();
                    this.savedLockedChords = [];
                    this.currentEditingColumn = null;
                    
                    // Start in chord creation mode since no chords exist
                    this.enterChordCreationMode();
                    
                    alert('Reset complete - you can now create chords from scratch');
                }
            }

            hideColumn() {
                if (!this.hiddenColumns) this.hiddenColumns = [];
                const columnId = this.currentEditingColumn.id || this.currentEditingColumn.name.toLowerCase();
                
                if (!this.hiddenColumns.includes(columnId)) {
                    this.hiddenColumns.push(columnId);
                    // localStorage removed - no longer saving hidden columns
                    this.generateExtensionColumns();
                }
            }

            addToFavorites() {
                if (!this.favoriteChords) this.favoriteChords = [];
                
                const favoriteChord = {
                    name: this.currentEditingColumn.name,
                    originalName: this.currentEditingColumn.originalName || this.currentEditingColumn.name,
                    extensions: this.currentEditingColumn.extensions || [],
                    quality: this.currentEditingColumn.quality,
                    intervals: this.currentEditingColumn.intervals,
                    root: this.currentRoot, // Store current root note
                    isCustom: this.currentEditingColumn.isCustom || false,
                    addedAt: Date.now()
                };
                
                // Check if already in favorites
                const exists = this.favoriteChords.some(fav => 
                    fav.name === favoriteChord.name && 
                    fav.quality === favoriteChord.quality &&
                    fav.root === favoriteChord.root
                );
                
                if (!exists) {
                    this.favoriteChords.push(favoriteChord);
                    // localStorage removed - no longer saving favorite chords
                    this.generateExtensionColumns();
                    console.log(`Added "${favoriteChord.name}" to favorites with root ${this.getNoteNames()[favoriteChord.root]}`);
                } else {
                    alert('This chord with this root is already in favorites!');
                }
            }

            addCurrentChordToFavorites() {
                const chordName = document.getElementById('customChordName').value.trim();
                if (!chordName) {
                    alert('Please enter a chord name first!');
                    return;
                }
                
                const selectedNotes = this.getSelectedNotes();
                if (selectedNotes.length === 0) {
                    alert('Please select at least one note!');
                    return;
                }
                
                if (!this.favoriteChords) this.favoriteChords = [];
                
                const favoriteChord = {
                    name: chordName,
                    originalName: chordName,
                    extensions: [],
                    quality: this.currentQuality,
                    intervals: selectedNotes,
                    notes: selectedNotes,
                    root: this.currentRoot,
                    isCustom: true,
                    addedAt: Date.now(),
                    tuning: this.currentTuning
                };
                
                // Check if already in favorites
                const exists = this.favoriteChords.some(fav => 
                    fav.name === favoriteChord.name && 
                    fav.quality === favoriteChord.quality &&
                    fav.root === favoriteChord.root
                );
                
                if (!exists) {
                    this.favoriteChords.push(favoriteChord);
                    // localStorage removed - no longer saving favorite chords
                    this.updateFavoritesDisplay();
                    console.log(`Added "${favoriteChord.name}" to favorites`);
                    alert(`Added "${favoriteChord.name}" to favorites!`);
                } else {
                    alert('This chord is already in favorites!');
                }
            }
            
            updateFavoritesDisplay() {
                const favoritesList = document.getElementById('favoriteChordsList');
                if (!favoritesList) return;
                
                favoritesList.innerHTML = '';
                
                if (!this.favoriteChords || this.favoriteChords.length === 0) {
                    favoritesList.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #8fb3d3; font-style: italic; padding: 20px;">No favorite chords yet</div>';
                    return;
                }
                
                this.favoriteChords.forEach((chord, index) => {
                    const chordElement = document.createElement('div');
                    chordElement.style.cssText = `
                        background: linear-gradient(135deg, #f39c12, #e67e22);
                        border: 1px solid #d68910;
                        border-radius: 6px;
                        padding: 8px;
                        text-align: center;
                        cursor: pointer;
                        font-size: 12px;
                        color: #fff;
                        position: relative;
                        transition: all 0.2s ease;
                        user-select: none;
                    `;
                    
                    chordElement.innerHTML = `
                        <div style="font-weight: bold;">${chord.name}</div>
                        <div style="font-size: 10px; opacity: 0.8;">${this.getNoteNames()[chord.root] || 'C'} ${chord.quality}</div>
                        <div style="position: absolute; top: 2px; right: 2px; background: rgba(0,0,0,0.3); border-radius: 50%; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; font-size: 10px; cursor: pointer;" class="remove-favorite" data-index="${index}">�</div>
                    `;
                    
                    // Play chord on click
                    chordElement.addEventListener('click', (e) => {
                        if (e.target.classList.contains('remove-favorite')) return;
                        this.playChord(chord.intervals || chord.notes, chord.root);
                    });
                    
                    // Hover effects
                    chordElement.addEventListener('mouseenter', () => {
                        chordElement.style.transform = 'scale(1.05)';
                        chordElement.style.boxShadow = '0 4px 12px rgba(243, 156, 18, 0.4)';
                    });
                    
                    chordElement.addEventListener('mouseleave', () => {
                        chordElement.style.transform = 'scale(1)';
                        chordElement.style.boxShadow = 'none';
                    });
                    
                    favoritesList.appendChild(chordElement);
                });
                
                // Add remove functionality
                favoritesList.addEventListener('click', (e) => {
                    if (e.target.classList.contains('remove-favorite')) {
                        const index = parseInt(e.target.dataset.index);
                        this.removeFavoriteChord(index);
                    }
                });
            }
            
            removeFavoriteChord(index) {
                if (confirm('Remove this chord from favorites?')) {
                    this.favoriteChords.splice(index, 1);
                    // localStorage removed - no longer saving favorite chords
                    this.updateFavoritesDisplay();
                }
            }
            
            getSelectedNotes() {
                const selector = document.getElementById('edoNoteSelector');
                if (!selector) return [];
                
                const selectedButtons = selector.querySelectorAll('.note-btn.selected');
                return Array.from(selectedButtons).map(btn => parseInt(btn.dataset.note));
            }

            removeFromFavorites() {
                if (this.currentEditingColumn.favoriteIndex !== undefined) {
                    const favoriteName = this.favoriteChords[this.currentEditingColumn.favoriteIndex].name;
                    this.favoriteChords.splice(this.currentEditingColumn.favoriteIndex, 1);
                    // localStorage removed - no longer saving favorite chords
                    this.generateExtensionColumns();
                    console.log(`Removed "${favoriteName}" from favorites`);
                }
            }

            addToPalette() {
                if (!this.paletteChords) this.paletteChords = [];
                
                const noteNames = this.getNoteNames();
                const rootName = noteNames[this.currentRoot] || this.currentRoot;
                
                // Generate the actual chord intervals for this column
                let chordIntervals = [];
                if (this.currentEditingColumn.intervals && this.currentEditingColumn.intervals.length > 0) {
                    // Use stored intervals (for custom chords)
                    chordIntervals = this.currentEditingColumn.intervals;
                } else {
                    // Generate intervals from extensions and quality (for standard chords)
                    const originalQuality = this.currentQuality;
                    this.currentQuality = this.currentEditingColumn.quality || 'major';
                    chordIntervals = this.getChordIntervals(this.currentEditingColumn.extensions || []);
                    // Convert EDO steps back to semitones for storage
                    chordIntervals = chordIntervals.map(step => (step * 12) / this.currentTuning);
                    this.currentQuality = originalQuality;
                }
                
                const paletteChord = {
                    name: this.currentEditingColumn.name,
                    fullName: `${rootName}${this.currentEditingColumn.name}`,
                    extensions: this.currentEditingColumn.extensions || [],
                    quality: this.currentEditingColumn.quality || 'major',
                    rootNote: this.currentRoot,
                    originalName: this.currentEditingColumn.originalName || this.currentEditingColumn.name,
                    isCustom: this.currentEditingColumn.isCustom || false,
                    intervals: chordIntervals,
                    root: this.currentRoot,
                    lockedTuning: this.currentTuning,
                    lockedGamelanMode: this.gamelanMode
                };
                
                // Always allow adding chords to create sequences
                this.paletteChords.push(paletteChord);
                // localStorage removed - no longer saving palette chords
                this.renderPaletteChords();
                console.log(`Added "${paletteChord.fullName}" to palette with intervals:`, chordIntervals);
            }

            deleteColumn() {
                console.log('?? deleteColumn called, currentEditingColumn:', this.currentEditingColumn);
                
                if (!this.currentEditingColumn) {
                    console.error('?? No currentEditingColumn set for deleteColumn');
                    alert('Error: No column selected for deletion');
                    return;
                }
                
                if (this.currentEditingColumn.isCustom) {
                    console.log('?? Deleting custom chord:', this.currentEditingColumn.name);
                    if (confirm(`Delete custom column "${this.currentEditingColumn.name}"?`)) {
                        const index = this.customChords.findIndex(chord => chord.name === this.currentEditingColumn.name);
                        console.log('?? Found custom chord at index:', index);
                        if (index !== -1) {
                            this.customChords.splice(index, 1);
                            // localStorage removed - no longer saving custom chords
                            console.log('?? Custom chord deleted, regenerating columns');
                            this.generateExtensionColumns();
                            // Custom chords automatically appear in extensions
                        } else {
                            console.error('?? Custom chord not found for deletion');
                            alert('Error: Custom chord not found for deletion');
                        }
                    }
                } else {
                    console.log('?? Deleting standard chord:', this.currentEditingColumn.originalName || this.currentEditingColumn.name);
                    // Allow deleting standard chord columns too
                    if (confirm(`Delete column "${this.currentEditingColumn.originalName || this.currentEditingColumn.name}"? This will remove all 3 flavors (Maj/Neu/Min) permanently.`)) {
                        // Use extension index if available, otherwise find by name
                        let index = -1;
                        if (this.currentEditingColumn.extensionIndex !== undefined) {
                            index = this.currentEditingColumn.extensionIndex;
                            console.log('?? Using extensionIndex:', index);
                        } else {
                            const searchName = this.currentEditingColumn.originalName || this.currentEditingColumn.name;
                            index = this.chordExtensions.findIndex(ext => 
                                ext.name === searchName || ext.name.toLowerCase() === searchName.toLowerCase()
                            );
                            console.log('?? Found extension by name at index:', index);
                        }
                        
                        if (index !== -1 && index < this.chordExtensions.length) {
                            console.log('?? Deleting chord extension at index:', index);
                            this.chordExtensions.splice(index, 1);
                            this.saveChordConfiguration();
                            this.generateExtensionColumns();
                            console.log(`?? Deleted chord extension at index ${index}`);
                        } else {
                            console.error('?? Could not find chord extension to delete:', this.currentEditingColumn);
                            alert('Error: Could not find chord extension to delete');
                        }
                    }
                }
            }

            updateColumnInStorage() {
                if (this.currentEditingColumn.isCustom) {
                    const index = this.customChords.findIndex(chord => chord.name === this.currentEditingColumn.originalName || this.currentEditingColumn.name);
                    if (index !== -1) {
                        this.customChords[index].name = this.currentEditingColumn.name;
                        if (this.currentEditingColumn.intervals) {
                            this.customChords[index].notes = this.currentEditingColumn.intervals;
                        }
                        // localStorage removed - no longer saving custom chords
                    }
                }
            }

            // Chord Name Context Menu Methods
            hideChord() {
                this.pushState();
                console.log('?? hideChord called, currentEditingChord:', this.currentEditingChord);
                
                if (!this.currentEditingChord) {
                    console.error('?? No currentEditingChord set for hideChord');
                    alert('Error: No chord selected for hiding');
                    return;
                }
                
                const chordId = this.currentEditingChord.id;
                if (!this.hiddenColumns.includes(chordId)) {
                    this.hiddenColumns.push(chordId);
                    // localStorage removed - no longer saving hidden columns
                    this.generateExtensionColumns();
                    console.log(`?? Hidden chord: ${this.currentEditingChord.name}`);
                }
            }

            duplicateChord() {
                this.pushState();
                console.log('?? duplicateChord called, currentEditingChord:', this.currentEditingChord);
                
                if (!this.currentEditingChord) {
                    console.error('?? No currentEditingChord set for duplicateChord');
                    alert('Error: No chord selected for duplication');
                    return;
                }
                
                // Create a duplicate chord
                const duplicateChord = {
                    name: this.currentEditingChord.name + ' Copy',
                    intervals: [...(this.currentEditingChord.intervals || [])],
                    isCustom: true,
                    id: 'custom_' + Date.now()
                };
                
                // Open chord builder with the duplicate
                this.showChordBuilder(duplicateChord);
            }

            editChord() {
                console.log('?? editChord called, currentEditingChord:', this.currentEditingChord);
                
                if (!this.currentEditingChord) {
                    console.error('?? No currentEditingChord set for editChord');
                    alert('Error: No chord selected for editing');
                    return;
                }
                
                // Open chord builder with the current chord
                this.showChordBuilder(this.currentEditingChord);
            }

            copyToCustomChords() {
                console.log('?? copyToCustomChords called, currentEditingChord:', this.currentEditingChord);
                
                if (!this.currentEditingChord) {
                    console.error('?? No currentEditingChord set for copyToCustomChords');
                    alert('Error: No chord selected for copying');
                    return;
                }
                
                // Get safe root note name
                const noteNames = this.getNoteNames();
                const rootIndex = this.currentEditingChord.root || this.currentRoot || 0;
                const rootName = noteNames[rootIndex] || `Note${rootIndex}`;
                
                console.log('?? Root details - index:', rootIndex, 'name:', rootName, 'noteNames:', noteNames);
                
                // Create a custom chord copy with root and tuning system
                const customChord = {
                    name: this.currentEditingChord.name + ` (${rootName})`,
                    notes: [...(this.currentEditingChord.intervals || [])],
                    id: Date.now()
                };
                
                console.log('?? Created customChord:', customChord);
                
                // Add to custom chords storage
                if (!this.customChords) this.customChords = [];
                this.customChords.push(customChord);
                // localStorage removed - no longer saving custom chords
                
                // Add to palette for immediate use
                const paletteChord = {
                    name: customChord.name,
                    fullName: customChord.name,
                    extensions: [],
                    quality: 'custom',
                    id: 'custom_' + customChord.id,
                    isCustom: true,
                    originalName: customChord.name,
                    intervals: customChord.notes,
                    root: this.currentEditingChord.root || this.currentRoot || 0,
                    lockedTuning: this.currentEditingChord.tuning || this.currentTuning,
                    lockedGamelanMode: this.gamelanMode
                };
                
                console.log('?? Created paletteChord:', paletteChord);
                
                if (!this.paletteChords) this.paletteChords = [];
                this.paletteChords.push(paletteChord);
                // localStorage removed - no longer saving palette chords
                
                // Regenerate everything
                this.generateExtensionColumns();
                this.renderPaletteChords();
                
                // Show success message
                alert(`Successfully copied "${customChord.name}" to custom palette!`);
                
                console.log(`?? Copied chord "${customChord.name}" to custom chords and palette`);
            }

            getNotesFromExtensions(extensions) {
                // Convert chord extensions to note intervals
                const intervals = this.getChordIntervals(extensions);
                return intervals;
            }

            // =============================================================================
            // LEGACY CODE REMOVED - Replaced by Unified Chord Builder
            // =============================================================================
            
            // OLD: showColumnModal(), showCustomChordModal(), saveCustomChord()
            // NEW: All functionality moved to unified ChordBuilder module above
            
            toggleColumnVisibility(columnId, visible) {
                if (visible) {
                    this.hiddenColumns = this.hiddenColumns.filter(id => id !== columnId);
                } else {
                    if (!this.hiddenColumns.includes(columnId)) {
                        this.hiddenColumns.push(columnId);
                    }
                }
                // localStorage removed - no longer saving hidden columns
                this.generateExtensionColumns();
            }

            deleteCustomChord(index) {
                if (confirm('Delete this custom chord?')) {
                    this.customChords.splice(index, 1);
                    // localStorage removed - no longer saving custom chords
                    this.generateExtensionColumns();
                }
            }

            updateChordDisplay() {
                // Chord display removed for cleaner interface
            }

            translateSemitoneToTuning(semitone) {
                // Translate 12-TET semitone to nearest step in current tuning
                // This ensures custom chords sound close in different tunings
                const exactStep = (semitone / 12) * this.currentTuning;
                return Math.round(exactStep) % this.currentTuning;
            }

            generateRootButtons() {
                const rootGrid = document.getElementById('rootGrid');
                if (!rootGrid) return;
                // Reuse existing keyboard element to avoid layout shift flicker
                let keyboard = rootGrid.querySelector('.piano-keyboard');
                if (!keyboard) {
                    // First-time creation
                    keyboard = document.createElement('div');
                    keyboard.className = 'piano-keyboard';
                    const by = document.createElement('div');
                    by.className = 'by-fastfast';
                    by.textContent = 'By FASTFAST';
                    keyboard.appendChild(by);
                    rootGrid.appendChild(keyboard);
                } else {
                    // Clear dynamic children (keys + dots) only
                    keyboard.querySelectorAll('.white-key.root-btn, .black-key.root-btn, .edo-dot').forEach(el=> el.remove());
                    // Ensure attribution present
                    if (!keyboard.querySelector('.by-fastfast')) {
                        const by = document.createElement('div');
                        by.className = 'by-fastfast';
                        by.textContent = 'By FASTFAST';
                        keyboard.appendChild(by);
                    }
                }

                // Fallback to legacy buttons in gamelan mode (7-tone pelog)
                if (this.gamelanMode) {
                    const noteNames = this.getNoteNames();
                    for (let i = 0; i < this.currentTuning; i++) {
                        const b = document.createElement('div');
                        b.className = 'root-btn';
                        b.textContent = noteNames[i] || i;
                        if (i === this.currentRoot) b.classList.add('active');
                        b.addEventListener('click',()=>{
                            document.querySelectorAll('#rootGrid .root-btn').forEach(x=>x.classList.remove('active'));
                            b.classList.add('active');
                            this.currentRoot = i;
                            this.regenerateAllColumnsPreservingLocks();
                        });
                        rootGrid.appendChild(b);
                    }
                    return;
                }

                // Piano layout definitions
                const whiteOrder = [0,2,4,5,7,9,11]; // semitone numbers for C D E F G A B
                const whiteLabels = ['C','D','E','F','G','A','B'];
                const blackMap = { 1:'C#',3:'D#',6:'F#',8:'G#',10:'A#' };
                const blackPositionsRelativeToWhite = {1:0,3:1,6:3,8:4,10:5}; // index of white to left

                // Precompute cent positions of all current tuning steps (0..currentTuning-1)
                const stepCents = Array.from({length:this.currentTuning},(_,i)=> this.getCentValue(i));

                // Map each tuning step to nearest 12TET semitone (0..11)
                const semitoneCenters = Array.from({length:12},(_,i)=> i*100);
                const stepToSemitone = stepCents.map(c=>{
                    let best=0; let mind=Infinity;
                    for (let s=0;s<12;s++){const d=Math.abs(c-semitoneCenters[s]); if(d<mind){mind=d;best=s;}}
                    return {cent:c, step: c/ (1200/ this.currentTuning), idx:best, dist:mind};
                });

                // For deciding which standard keys (white/black) are represented by an EDO step
                const threshold = 35; // cents tolerance to claim a semitone
                const semitoneHasStep = new Array(12).fill(false);
                stepToSemitone.forEach(o=>{ if(o.dist<=threshold) semitoneHasStep[o.idx]=true; });

                // keyboard already prepared above
                // Dynamic width scaling for higher EDO counts
                this.adjustKeyboardWidth(keyboard);

                // Function to select a root by actual tuning step index
                const selectRoot = (targetStep)=>{
                    document.querySelectorAll('#rootGrid .root-btn, #rootGrid .edo-dot').forEach(x=>x.classList.remove('active'));
                    this.currentRoot = targetStep;
                    // find element with data-step
                    const els = keyboard.querySelectorAll(`[data-step='${targetStep}']`);
                    els.forEach(el=> el.classList.add('active'));
                    // Update chord header colors in-place for unlocked chords
                    try {
                        document.querySelectorAll('.extension-column').forEach(col=>{
                            const header = col.querySelector('.extension-header');
                            if (!header) return;
                            // Decide if this column is locked
                            const isLocked = col.querySelector('.lock-button')?.classList.contains('locked');
                            if (isLocked) return; // keep locked header color tied to locked root
                            const semi = this.stepToSemitone(this.currentRoot ?? 0, this.currentTuning || 12);
                            const accent = this.getChromaticColorForSemitone(semi);
                            const text = this.pickTextColor(accent);
                            header.style.background = accent;
                            header.style.borderBottom = `2px solid ${accent}`;
                            header.style.boxShadow = `0 0 10px ${accent}55`;
                            header.style.color = text;
                        });
                    } catch {}
                    this.regenerateAllColumnsPreservingLocks();
                    this.updateChordDisplay();
                    if (this.chordCreationMode) {
                        // Keep preview column in sync with new root
                        this.updatePreviewChordColumn();
                    }
                };

                // Pick representative step for each claimed semitone (closest)
                const semitoneToStep = new Array(12).fill(null);
                for (let s=0;s<12;s++){
                    let best=null; let mind=Infinity;
                    stepToSemitone.forEach(o=>{ if(o.idx===s && o.dist < mind){ mind=o.dist; best=o; }});
                    semitoneToStep[s]=best; // may be null
                }

                // Horizontal positions for 7 white circles equally spaced across width
                const whiteCenters = whiteOrder.map((_,i)=> ( (i+0.5)/7 )*100 );
                whiteOrder.forEach((semi,i)=>{
                    const rep = semitoneToStep[semi];
                    const el = document.createElement('div');
                    el.className='white-key root-btn';
                    // Always interactive: fallback to nearest step even if not within threshold
                    let stepIndex = rep? Math.round(rep.step) : this.findNearestStepForSemitone(semi, stepCents);
                    el.dataset.step = stepIndex;
                    if(stepIndex===this.currentRoot) el.classList.add('active');
                    el.dataset.semitone=semi;
                    el.style.left = whiteCenters[i] + '%';
                    // Replace label with microtonal note name for that step
                    el.textContent = this.getMicrotonalNoteName(stepIndex % this.currentTuning);
                    el.addEventListener('click',()=> selectRoot(stepIndex));
                    keyboard.appendChild(el);
                });

                // Black key centers between specific white centers
                const blackCenters = {1:(whiteCenters[0]+whiteCenters[1])/2,3:(whiteCenters[1]+whiteCenters[2])/2,6:(whiteCenters[3]+whiteCenters[4])/2,8:(whiteCenters[4]+whiteCenters[5])/2,10:(whiteCenters[5]+whiteCenters[6])/2};
                Object.entries(blackMap).forEach(([semi,label])=>{
                    const s=parseInt(semi,10);
                    const rep = semitoneToStep[s];
                    const el=document.createElement('div');
                    el.className='black-key root-btn';
                    let stepIndex = rep? Math.round(rep.step) : this.findNearestStepForSemitone(s, stepCents);
                    el.dataset.step = stepIndex;
                    if(stepIndex===this.currentRoot) el.classList.add('active');
                    el.dataset.semitone=s;
                    el.style.left = blackCenters[s] + '%';
                    el.textContent=this.getMicrotonalNoteName(stepIndex % this.currentTuning);
                    el.addEventListener('click',()=> selectRoot(stepIndex));
                    keyboard.appendChild(el);
                });

                // Gap-based microtone layout: for each semitone gap place up to one blue (<50), one green (~50), one red (>50) actual EDO steps.
                const semiCenters = {}; // semitone -> percent center (0..100)
                whiteOrder.forEach((s,i)=>{ semiCenters[s]=whiteCenters[i]; });
                Object.entries(blackCenters).forEach(([s,p])=>{ semiCenters[parseInt(s,10)]=p; });
                // NOTE: removed previous wrappedC>100 approach; we now constrain the B–C gap to end at 100%
                // so no element ever receives a left position >100 (which previously pushed B off-screen after re-spacing)
                const firstC = whiteCenters[0];
                const addMicroDot = (pct,color,targetCent,label)=>{
                    if (pct < firstC) pct = firstC; // clamp so nothing before first C
                    if (pct > 100) pct = 99.5; // hard clamp to stay on screen
                    const d=document.createElement('div');
                    d.className=`edo-dot edo-lane-${color} ${color}`;
                    d.style.left=pct+'%';
                    // nearest tuning step
                    let bestStep=0; let bestDist=Infinity;
                    stepCents.forEach((c,i)=>{ const base=c%1200; const dist=Math.abs(base-targetCent); if(dist<bestDist){bestDist=dist;bestStep=i;} });
                    d.dataset.step=bestStep;
                    if (bestStep===this.currentRoot) d.classList.add('active');
                    // Assign microtonal note name as visible text
                    d.textContent = this.getMicrotonalNoteName(bestStep % this.currentTuning);
                    d.title=`${d.textContent} (${color})`; // concise tooltip
                    d.addEventListener('click',()=> selectRoot(bestStep));
                    keyboard.appendChild(d);
                };
                // ================== ALGORITHMIC MICROTONAL COLOR ORDERING ==================
                // Goal: purely algorithmic (no special-case 48 only) ordering of internal microtones.
                // For any semitone gap that contains internal steps (excluding those claimed by the end semitone centers):
                //   White -> Black gap (W-B):   assign in ascending order: Red (near white) , Green (middle), Blue (near black)
                //   Black -> White gap (B-W):   assign in ascending order: Blue (near black), Green (middle), Red (near white)
                //   Natural gaps (E–F s=4->5 and B–C s=11->0): place a single Green (midpoint). If multiple internal steps, choose the one nearest 50¢;
                //   for B–C bias midpoint toward B (~42%) when only one internal microtone exists.
                // If fewer than 3 internal steps in a chromatic gap, endpoints get priority colors; middle is Green when present.
                // If more than 3 internal steps, only the first, a middle representative, and last are kept to avoid clutter.
                const whiteSemis = new Set([0,2,4,5,7,9,11]);
                const blackSemis = new Set([1,3,6,8,10]);
                // Build set of step indices already used for keys so we don't recolor them
                const claimedSteps = new Set();
                semitoneToStep.forEach(rep=>{ if(rep) claimedSteps.add(Math.round(rep.step)); });

                for(let s=0;s<12;s++){
                    const nextSemi = (s===11)? 0 : s+1;
                    const leftPct = semiCenters[s];
                    // Constrain final B–C gap to end-of-range (100%) instead of artificial wrappedC (>100)
                    let rightPct;
                    if (s===11) {
                        rightPct = 100; // end of visible octave span
                    } else {
                        rightPct = semiCenters[nextSemi];
                    }
                    if(leftPct==null || rightPct==null) continue;
                    let spanPct = rightPct-leftPct;
                    if (spanPct<=0) continue; // safety; prevents negative or zero spans

                    // Determine gap type
                    const isNaturalGap = (s===4 && nextSemi===5) || (s===11 && nextSemi===0);
                    const gapType = isNaturalGap ? 'NAT' : (whiteSemis.has(s) && blackSemis.has(nextSemi) ? 'WB' : (blackSemis.has(s) && whiteSemis.has(nextSemi) ? 'BW' : 'OTHER'));
                    const gapStartCent = s*100; const gapEndCent = (s+1)*100; // cents

                    // Gather internal candidate steps (exclude endpoints and claimed key steps)
                    const candidates = [];
                    stepCents.forEach((c,i)=>{
                        const cent = c % 1200;
                        if (cent>gapStartCent && cent<gapEndCent) {
                            if (claimedSteps.has(i)) return; // skip key representative
                            const offset = cent - gapStartCent; // 0..100
                            candidates.push({cent,offset,step:i});
                        }
                    });
                    if(!candidates.length) continue;
                    candidates.sort((a,b)=> a.offset - b.offset); // ascending by position in gap

                    if (gapType==='NAT') {
                        // Single neutral microtone (green). Choose nearest to 50¢ (bias to 42% for B–C when only one)
                        let chosen;
                        if (candidates.length===1) { chosen = candidates[0]; }
                        else { chosen = candidates.slice().sort((a,b)=> Math.abs(a.offset-50)-Math.abs(b.offset-50))[0]; }
                        let frac = chosen.offset/100;
                        if (s===11 && candidates.length===1) { // B–C bias toward B
                            frac = Math.min(frac, 0.42);
                        }
                        let pct = leftPct + spanPct*frac; if (pct>100) pct-=100;
                        addMicroDot(pct,'green',chosen.cent,`Between ${s}-${nextSemi}`);
                        continue;
                    }
                    if (gapType==='OTHER') {
                        // Fallback: use original tri-color heuristic (treat as WB style)
                        const first = candidates[0];
                        const last = candidates[candidates.length-1];
                        const mid = candidates[Math.floor(candidates.length/2)];
                        const chosen = [first, mid, last];
                        const colors = ['red','green','blue'];
                        chosen.forEach((obj,idx)=>{
                            if(!obj) return;
                            let pct = leftPct + spanPct*(obj.offset/100); if (pct>100) pct-=100;
                            addMicroDot(pct, colors[idx], obj.cent, `Between ${s}-${nextSemi}`);
                        });
                        continue;
                    }
                    // Chromatic gaps with a black key boundary (WB or BW)
                    let core = candidates;
                    if (core.length>3) { // reduce to first/middle/last
                        core = [core[0], core[Math.floor(core.length/2)], core[core.length-1]];
                    }
                    // Assign colors based on direction
                    let colorOrder; // array parallel to sorted offsets
                    if (gapType==='WB') { // white -> black
                        if (core.length===1) colorOrder=['green'];
                        else if (core.length===2) colorOrder=['red','blue'];
                        else colorOrder=['red','green','blue'];
                    } else { // 'BW'
                        if (core.length===1) colorOrder=['green'];
                        else if (core.length===2) colorOrder=['blue','red'];
                        else colorOrder=['blue','green','red'];
                    }
                    core.forEach((obj,idx)=>{
                        let pct = leftPct + spanPct*(obj.offset/100);
                        addMicroDot(pct, colorOrder[idx], obj.cent, `Between ${s}-${nextSemi}`);
                    });
                }
        // After constructing all keys and dots, resize to fit
                this.resizeKeyboardKeys(keyboard, whiteCenters);
                this.adjustForDotOverlap(keyboard);
                this.enforceEquidistantCenters(keyboard);
                this.resizeDotsToKeySize(keyboard);
            }

            getNoteNames() {
                if (this.gamelanMode) {
                    // Gamelan pelog note names
                    return ['Bem', 'Gulu', 'Dada', 'Pelog', 'Lima', 'Nem', 'Barang'];
                }
                
                // Use microtonal directional notation system
                const names = [];
                for (let i = 0; i < this.currentTuning; i++) {
                    names.push(this.getMicrotonalNoteName(i));
                }
                return names;
            }

            getCentValue(step, tuning = null) {
                const currentTuning = tuning || this.currentTuning;
                console.log('getCentValue called with step:', step, 'tuning:', tuning, 'gamelanMode:', this.gamelanMode, 'currentTuning:', currentTuning);
                
                if (this.gamelanMode) {
                    // Gamelan pelog scale approximation in cents from root
                    const gamelanCents = [0, 136, 348, 560, 704, 840, 1056]; // 7-note pelog scale
                    const result = gamelanCents[step % 7] + (Math.floor(step / 7) * 1200);
                    console.log('gamelan cents result:', result);
                    return result;
                }
                const result = (step * 1200) / currentTuning;
                console.log('equal temperament cents result:', result);
                return result;
            }

            // Find nearest EDO step (index) whose cent value is closest to a given 12-TET semitone center
            findNearestStepForSemitone(semitone, stepCents){
                const targetCent = semitone * 100;
                let bestIdx = 0; let bestDist = Infinity;
                stepCents.forEach((c,i)=>{
                    const dist = Math.abs((c%1200) - targetCent);
                    if(dist < bestDist){ bestDist = dist; bestIdx = i; }
                });
                return bestIdx;
            }

            // Dynamically resize circular keys to avoid overflow and keep everything after first C
            resizeKeyboardKeys(keyboard, whiteCenters){
                if(!keyboard || !whiteCenters || whiteCenters.length < 2) return;
                const kbWidth = (keyboard.clientWidth || 1000);
                const edo = this.currentTuning || 12;
                const densityFactor = edo/12;
                let diameter = 70 / densityFactor;
                const spacingPct = whiteCenters[1]-whiteCenters[0];
                const spacingPx = (spacingPct/100) * kbWidth;
                diameter = Math.min(diameter, spacingPx * 0.85);
                const minReadable = edo >= 72 ? 12 : 16;
                if (diameter < minReadable) diameter = minReadable;
                this.currentKeyDiameter = diameter;
                const renderD = diameter;
                keyboard.querySelectorAll('.white-key.root-btn').forEach(el=>{
                    el.style.width = renderD + 'px';
                    el.style.height = renderD + 'px';
                });
                keyboard.querySelectorAll('.black-key.root-btn').forEach(el=>{
                    el.style.width = renderD + 'px';
                    el.style.height = renderD + 'px';
                });
                keyboard.querySelectorAll('.edo-dot').forEach(el=>{
                    const dotD = renderD * 0.55;
                    el.style.width = dotD + 'px';
                    el.style.height = dotD + 'px';
                });
            }

            // Widen keyboard proportionally with EDO so higher divisions have more horizontal space
            adjustKeyboardWidth(keyboard){
                // Legacy function retained for compatibility; intentionally does nothing now.
                if(!keyboard) return;
            }

            // Detect dot/key overlaps; shrink keys globally until all dots clear or min size reached
            adjustForDotOverlap(keyboard){
                if(!keyboard) return;
                const kbWidth = keyboard.clientWidth || 1000;
                const percentPerPx = 100 / kbWidth;
                const padPx = 2;
                const dotRadiusPx = 10; // 20px diameter per CSS
                let diameter = this.currentKeyDiameter || 70;
                const minDiameter = 34;
                const dots = Array.from(keyboard.querySelectorAll('.edo-dot'));
                if(!dots.length) return;
                const getOverlapExists = ()=>{
                    const keyCenters = [];
                    keyboard.querySelectorAll('.white-key.root-btn, .black-key.root-btn').forEach(k=>{
                        const leftPct = parseFloat(k.style.left);
                        keyCenters.push(leftPct);
                    });
                    const keyRadiusPct = (diameter/2) * percentPerPx;
                    const dotRadiusPct = dotRadiusPx * percentPerPx;
                    const padPct = padPx * percentPerPx;
                    for(const d of dots){
                        const dPct = parseFloat(d.style.left);
                        for(const kc of keyCenters){
                            if (Math.abs(dPct - kc) < (keyRadiusPct + dotRadiusPct + padPct)){
                                return true;
                            }
                        }
                    }
                    return false;
                };
                let guard=0;
                while(getOverlapExists() && diameter>minDiameter && guard<20){
                    guard++;
                    diameter -= 3; // shrink step
                    this.currentKeyDiameter = diameter;
                    // Use the same scale logic as in resizeKeyboardKeys
                    const renderD = diameter;
                    keyboard.querySelectorAll('.white-key.root-btn').forEach(el=>{
                        el.style.width = renderD + 'px';
                        el.style.height = renderD + 'px';
                    });
                    keyboard.querySelectorAll('.black-key.root-btn').forEach(el=>{
                        el.style.width = renderD + 'px';
                        el.style.height = renderD + 'px';
                    });
                }
             }

            // Reposition all key & dot centers to be perfectly equidistant while preserving ordering
            enforceEquidistantCenters(keyboard){
                if(!keyboard) return;
                const all = Array.from(keyboard.querySelectorAll('.white-key.root-btn, .black-key.root-btn, .edo-dot'));
                if(all.length < 2) return;
                // Sort by current left
                all.sort((a,b)=> parseFloat(a.style.left) - parseFloat(b.style.left));
                // Determine first C (white key with label starting C) to lock at current position
                const firstCEl = all.find(el=> el.classList.contains('white-key') && /C/.test(el.textContent));
                const firstLeft = firstCEl ? parseFloat(firstCEl.style.left) : parseFloat(all[0].style.left);
                const lastEl = all[all.length-1];
                const lastLeft = parseFloat(lastEl.style.left);
                if (lastLeft <= firstLeft) return;
                // If any element already exceeds 100%, abort normalization (shouldn't happen after earlier clamps)
                if (all.some(el=> parseFloat(el.style.left) > 100)) return;
                const span = lastLeft - firstLeft;
                const uniformGap = span / (all.length - 1);
                all.forEach((el,idx)=>{
                    if (el===firstCEl || el===lastEl) return; // lock ends
                    const newLeft = firstLeft + idx*uniformGap;
                    // Safety clamp
                    el.style.left = Math.min(99.5, Math.max(firstLeft, newLeft)) + '%';
                });
            }

            // Make colored micro dots same diameter as (reduced) black/white keys for easier tapping
            resizeDotsToKeySize(keyboard){
                if(!keyboard) return;
                const diameter = (this.currentKeyDiameter || 70) * 0.97; // match black key size
                keyboard.querySelectorAll('.edo-dot').forEach(dot=>{
                    dot.style.width = diameter + 'px';
                    dot.style.height = diameter + 'px';
                    dot.style.lineHeight = diameter + 'px';
                    // Adjust font size relative to diameter
                    const fs = Math.max(10, Math.min(14, diameter * 0.22));
                    dot.style.fontSize = fs + 'px';
                });
            }

            getFrequency(step, octave = 4, tuning = null) {
                console.log('getFrequency called with step:', step, 'octave:', octave, 'tuning:', tuning, 'currentTuning:', this.currentTuning);
                
                const cents = this.getCentValue(step, tuning);
                console.log('cents calculated:', cents);
                
                // Use C4 as base frequency (261.626 Hz) since step 0 = C
                const baseFreq = 261.626 * Math.pow(2, (octave - 4)); // C4 = 261.626Hz
                console.log('baseFreq calculated:', baseFreq);
                
                const finalFreq = baseFreq * Math.pow(2, cents / 1200);
                console.log('finalFreq calculated:', finalFreq);
                
                if (isNaN(finalFreq)) {
                    console.error('NaN frequency detected! step:', step, 'octave:', octave, 'cents:', cents, 'baseFreq:', baseFreq);
                }
                
                return finalFreq;
            }

            generateChordPattern(extensions) {
                // Generate a pattern of chord intervals
                const intervals = this.getChordIntervals(extensions);
                return intervals;
            }

            getTuningDivisions() {
                return this.currentTuning;
            }

            getNoteName(noteIndex) {
                if (noteIndex === undefined || noteIndex === null) {
                    return 'C'; // Default to C if undefined
                }
                const noteNames = this.getNoteNames();
                return noteNames[noteIndex] || noteIndex.toString();
            }

            getChordIntervals(extensions = []) {
                let intervals = [0]; // Root
                
                // Base triad
                switch (this.currentQuality) {
                    case 'major':
                        intervals.push(Math.round(4 * this.currentTuning / 12)); // Major third
                        intervals.push(Math.round(7 * this.currentTuning / 12)); // Perfect fifth
                        break;
                    case 'minor':
                        intervals.push(Math.round(3 * this.currentTuning / 12)); // Minor third
                        intervals.push(Math.round(7 * this.currentTuning / 12)); // Perfect fifth
                        break;
                    case 'neutral':
                        intervals.push(Math.round(3.5 * this.currentTuning / 12)); // Neutral third
                        intervals.push(Math.round(7 * this.currentTuning / 12)); // Perfect fifth
                        break;
                }
                
                // Apply extensions
                extensions.forEach(ext => {
                    switch (ext) {
                        case '6':
                            intervals.push(Math.round(9 * this.currentTuning / 12));
                            break;
                        case '7':
                            intervals.push(Math.round(10 * this.currentTuning / 12));
                            break;
                        case 'maj7':
                            intervals.push(Math.round(11 * this.currentTuning / 12));
                            break;
                        case '9':
                            intervals.push(Math.round(10 * this.currentTuning / 12)); // Add 7th first
                            intervals.push(Math.round(14 * this.currentTuning / 12)); // Then 9th
                            break;
                        case 'sus2':
                            intervals = intervals.filter(i => i !== Math.round(4 * this.currentTuning / 12) && i !== Math.round(3 * this.currentTuning / 12) && i !== Math.round(3.5 * this.currentTuning / 12));
                            intervals.push(Math.round(2 * this.currentTuning / 12));
                            break;
                        case 'sus4':
                            intervals = intervals.filter(i => i !== Math.round(4 * this.currentTuning / 12) && i !== Math.round(3 * this.currentTuning / 12) && i !== Math.round(3.5 * this.currentTuning / 12));
                            intervals.push(Math.round(5 * this.currentTuning / 12));
                            break;
                        case 'add9':
                            intervals.push(Math.round(14 * this.currentTuning / 12));
                            break;
                        case '13':
                            intervals.push(Math.round(10 * this.currentTuning / 12)); // Add 7th
                            intervals.push(Math.round(21 * this.currentTuning / 12)); // Add 13th
                            break;
                        case '#11':
                            intervals.push(Math.round(18 * this.currentTuning / 12)); // #11
                            break;
                        case '7#9':
                            intervals.push(Math.round(10 * this.currentTuning / 12)); // 7th
                            intervals.push(Math.round(15 * this.currentTuning / 12)); // #9 (raised 9th)
                            break;
                        case '#9':
                            intervals.push(Math.round(15 * this.currentTuning / 12)); // #9 (raised 9th)
                            break;
                        case 'n7':
                            intervals.push(Math.round(10.5 * this.currentTuning / 12)); // neutral 7th
                            break;
                        case 'n11':
                            intervals.push(Math.round(16.5 * this.currentTuning / 12)); // neutral 11th
                            break;
                    }
                });
                
                return [...new Set(intervals)].sort((a, b) => a - b);
            }
            
            regenerateAllColumnsPreservingLocks() {
                console.log('?? Regenerating all columns while preserving locked chord settings');
                
                // Get all current columns
                const container = document.getElementById('extensionColumns');
                const allColumns = Array.from(container.querySelectorAll('.extension-column'));
                
                // For each column, regenerate its strings using appropriate settings
                allColumns.forEach(column => {
                    const isLocked = this.lockedChords && this.lockedChords.has(column);
                    
                    if (isLocked) {
                        // This column is locked - regenerate using its locked settings
                        const lockedChord = this.lockedChords.get(column);
                        console.log('?? Regenerating locked column:', lockedChord.chordName, 'with locked root:', lockedChord.lockedRoot);
                        
                        // Find the chord extension for this column
                        const chordExt = this.chordExtensions.find(ext => 
                            ext.name === lockedChord.chordName || 
                            ext.name === lockedChord.originalChordName ||
                            (ext.symbol && lockedChord.chordName.includes(ext.symbol))
                        );
                        
                        if (chordExt) {
                            // Clear existing strings and regenerate with locked settings
                            const stringsContainer = column.querySelector('.strings-column');
                            if (stringsContainer) {
                                stringsContainer.remove();
                            }
                            
                            // Generate strings using locked settings
                            this.generateStringsForColumnWithLockedSettings(column, chordExt.intervals, lockedChord);
                        }
                    } else {
                        // This column is unlocked - regenerate using current global settings
                        const chordName = column.querySelector('.chord-name')?.textContent;
                        console.log('?? Regenerating unlocked column:', chordName, 'with current root:', this.currentRoot);
                        
                        // Find the chord extension for this column
                        const chordExt = this.chordExtensions.find(ext => 
                            ext.name === chordName || 
                            ext.symbol === chordName ||
                            (ext.symbol === '' && chordName === 'Major')
                        );
                        
                        if (chordExt) {
                            // Clear existing strings and regenerate with current settings
                            const stringsContainer = column.querySelector('.strings-column');
                            if (stringsContainer) {
                                stringsContainer.remove();
                            }
                            
                            // Generate strings using current global settings
                            this.generateStringsForColumn(column, chordExt.intervals, chordExt.isCustom);
                        }
                    }
                });
                
                console.log('?? Completed regeneration preserving', this.lockedChords ? this.lockedChords.size : 0, 'locked chords');
            }

            regenerateUnlockedChordsOnly() {
                console.log('?? Regenerating only unlocked chords, preserving locked ones exactly as they are');
                
                if (!this.lockedChords || this.lockedChords.size === 0) {
                    // No locked chords, just regenerate everything normally
                    console.log('?? No locked chords found, regenerating all chords normally');
                    this.preserveLockedChordsAndRegenerate();
                    return;
                }
                
                // Get all columns currently in the DOM
                const container = document.getElementById('extensionColumns');
                const existingColumns = Array.from(container.querySelectorAll('.extension-column'));
                
                console.log('?? Found', existingColumns.length, 'existing columns,', this.lockedChords.size, 'are locked');
                
                // Separate locked and unlocked columns
                const lockedColumns = [];
                const unlockedColumns = [];
                
                existingColumns.forEach(column => {
                    if (this.lockedChords.has(column)) {
                        lockedColumns.push(column);
                        console.log('?? Preserving locked column:', column.querySelector('.chord-name')?.textContent);
                    } else {
                        unlockedColumns.push(column);
                        console.log('?? Will regenerate unlocked column:', column.querySelector('.chord-name')?.textContent);
                    }
                });
                
                // Remove only the unlocked columns from DOM (keep locked ones in place)
                unlockedColumns.forEach(column => {
                    column.remove();
                });
                
                // Update chord names in locked columns to ensure they display correctly
                // but preserve their locked root information
                lockedColumns.forEach(column => {
                    const lockedChord = this.lockedChords.get(column);
                    if (lockedChord) {
                        const chordNameElement = column.querySelector('.chord-name');
                        if (chordNameElement) {
                            // Keep the locked chord name exactly as it was locked
                            // This prevents it from being rewritten with the new root
                            const lockedName = lockedChord.chordName;
                            chordNameElement.textContent = `🔒 ${lockedName}`;
                            chordNameElement.style.color = '#4CAF50';
                            chordNameElement.style.fontWeight = 'bold';
                            
                            const rootName = this.getNoteNames()[lockedChord.lockedRoot] || lockedChord.lockedRoot;
                            chordNameElement.title = `LOCKED: ${rootName} root, ${lockedChord.lockedTuning}TET, ${lockedChord.lockedOsc1.type}/${lockedChord.lockedOsc2.type} waves`;
                            
                            console.log('?? Preserved locked chord display:', lockedName, 'locked to root:', lockedChord.lockedRoot);
                        }
                    }
                });
                
                // Now regenerate only the chord extensions that correspond to unlocked columns
                // Find which chord extensions were unlocked
                const unlockedExtensions = this.chordExtensions.filter(ext => {
                    // Check if this extension had a locked column
                    const wasLocked = lockedColumns.some(column => {
                        const lockedChord = this.lockedChords.get(column);
                        return lockedChord && (
                            ext.name === lockedChord.chordName ||
                            (ext.isCustom && lockedChord.lockId && lockedChord.lockId.includes(ext.id || ext.name))
                        );
                    });
                    return !wasLocked;
                });
                
                console.log('?? Found', unlockedExtensions.length, 'unlocked extensions to regenerate');
                
                // Generate new columns for unlocked extensions with the new root
                unlockedExtensions.forEach(ext => {
                    console.log('?? Regenerating column for unlocked extension:', ext.name);
                    this.generateSingleChordColumn(ext, container);
                });
                
                console.log('?? Completed regeneration - preserved', lockedColumns.length, 'locked chords, regenerated', unlockedExtensions.length, 'unlocked chords');
            }
            
            generateSingleChordColumn(chordExt, container) {
                // This function generates a single chord column for the given chord extension
                // This is extracted from the main generateExtensionColumns function
                const noteNames = this.getNoteNames();
                
                const column = document.createElement('div');
                column.className = 'extension-column';
                // Provide stable identifiers so delete/reorder logic can map back to data
                try {
                    const absoluteIndex = (typeof chordExt.position === 'number')
                        ? chordExt.position
                        : (this.findChordIndex ? this.findChordIndex(chordExt) : (this.chordExtensions ? this.chordExtensions.indexOf(chordExt) : -1));
                    if (absoluteIndex !== -1) column.dataset.originalPosition = String(absoluteIndex);
                    const slug = (chordExt.id || (chordExt.name || '').toLowerCase().replace(/\s+/g, '_'));
                    column.dataset.chordId = slug;
                    column.dataset.chordType = slug;
                } catch (_) { /* non-fatal */ }
                column.style.flex = '1';
                column.style.height = '100%';
                column.style.border = 'none';
                column.style.borderRadius = '0';
                column.style.margin = '0';
                column.style.padding = '0';
                
                // Create header with chord name and action buttons
                const header = document.createElement('div');
                header.className = 'extension-header';
                
                // Create chord name span
                const chordName = document.createElement('span');
                chordName.className = 'chord-name';
                chordName.textContent = chordExt.name;
                
                // Create buttons container
                const buttonsContainer = document.createElement('div');
                buttonsContainer.className = 'header-buttons';
                
                // Create action buttons (always visible) with unique IDs
                const editButton = document.createElement('button');
                editButton.className = 'chord-action-button edit';
                editButton.id = `edit-single-${chordExt.id || chordExt.name.replace(/\s+/g, '_')}-${Date.now()}`;
                editButton.innerHTML = '✏️';
                editButton.title = 'Edit chord intervals';
                editButton.style.display = 'flex';
                
                // Delete button removed — delete via upward drag
                
                const duplicateButton = document.createElement('button');
                duplicateButton.className = 'chord-action-button duplicate';
                duplicateButton.id = `duplicate-single-${chordExt.id || chordExt.name.replace(/\s+/g, '_')}-${Date.now()}`;
                duplicateButton.innerHTML = '📋';
                duplicateButton.title = 'Duplicate and edit';
                duplicateButton.style.display = 'flex';
                
                // Create lock button
                const lockButton = document.createElement('button');
                lockButton.className = 'lock-button';
                lockButton.innerHTML = '🔓';
                lockButton.title = 'Lock complete sonic snapshot';
                
                // Add button event listeners with proper chord data closure
                editButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('🔧 Edit button clicked for chord:', chordExt.name, 'Button ID:', editButton.id);
                    
                    // Create a deep copy of chord data to ensure it's preserved
                    const chordDataForEdit = {
                        name: chordExt.name,
                        intervals: chordExt.intervals || this.getBaseTriadForQuality(chordExt.name.toLowerCase()),
                        isCustom: chordExt.isCustom || false,
                        id: chordExt.id || `${chordExt.name}_single_${Date.now()}`,
                        originalChord: chordExt
                    };
                    
                    console.log('🔧 Complete chord data for editing:', chordDataForEdit);
                    this.editChordFromButton(chordDataForEdit, column);
                });
                
                editButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('🔧 Edit button touched for chord:', chordExt.name, 'Button ID:', editButton.id);
                    
                    // Create a deep copy of chord data to ensure it's preserved
                    const chordDataForEdit = {
                        name: chordExt.name,
                        intervals: chordExt.intervals || this.getBaseTriadForQuality(chordExt.name.toLowerCase()),
                        isCustom: chordExt.isCustom || false,
                        id: chordExt.id || `${chordExt.name}_single_${Date.now()}`,
                        originalChord: chordExt
                    };
                    
                    this.editChordFromButton(chordDataForEdit, column);
                });
                
                
                duplicateButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const chordDataForDupe = {
                        name: chordExt.name,
                        intervals: chordExt.intervals || this.getBaseTriadForQuality(chordExt.name.toLowerCase()),
                        isCustom: chordExt.isCustom || false,
                        id: chordExt.id || `${chordExt.name}_single_${Date.now()}`,
                        originalChord: chordExt
                    };
                    
                    this.duplicateChordFromButton(chordDataForDupe, column);
                });
                
                duplicateButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const chordDataForDupe = {
                        name: chordExt.name,
                        intervals: chordExt.intervals || this.getBaseTriadForQuality(chordExt.name.toLowerCase()),
                        isCustom: chordExt.isCustom || false,
                        id: chordExt.id || `${chordExt.name}_single_${Date.now()}`,
                        originalChord: chordExt
                    };
                    
                    this.duplicateChordFromButton(chordDataForDupe, column);
                });
                
                // Add lock button functionality
                lockButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.lockSonicChord(chordExt, column);
                });
                
                // Add touchstart for mobile compatibility
                lockButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.lockSonicChord(chordExt, column);
                });
                
                // Create piano lock button
                const pianoLockButton = document.createElement('button');
                pianoLockButton.className = 'piano-lock-button';
                pianoLockButton.innerHTML = '🎹';
                pianoLockButton.title = 'Lock oscillator & effect settings only';
                
                // Add piano lock button functionality
                pianoLockButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    // If column is undefined, find the closest column element
                    const actualColumn = column || e.target.closest('.extension-column');
                    this.lockPianoSettings(chordExt, actualColumn);
                });
                
                // Add touchstart for mobile compatibility
                pianoLockButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    // If column is undefined, find the closest column element
                    const actualColumn = column || e.target.closest('.extension-column');
                    this.lockPianoSettings(chordExt, actualColumn);
                });
                
                // Add buttons to container
                buttonsContainer.appendChild(editButton);
                buttonsContainer.appendChild(duplicateButton);
                buttonsContainer.appendChild(lockButton);
                buttonsContainer.appendChild(pianoLockButton);
                
                header.appendChild(chordName);
                header.appendChild(buttonsContainer);
                
                // Color coding by type
                let qualityColor;
                if (chordExt.name === 'Major') qualityColor = { bg: '#1e40af', border: '#3b82f6' };
                else if (chordExt.name === 'Neutral') qualityColor = { bg: '#059669', border: '#10b981' };
                else if (chordExt.name === 'Minor') qualityColor = { bg: '#dc2626', border: '#ef4444' };
                else qualityColor = { bg: '#4a5568', border: '#718096' }; // Default for custom
                
                header.style.backgroundColor = qualityColor.bg;
                header.style.borderColor = qualityColor.border;
                header.style.color = 'white';
                header.style.border = `1px solid ${qualityColor.border}`;
                
                // Add context menu handlers
                header.addEventListener('click', (e) => {
                    // Don't interfere with action button clicks
                    if (e.target.classList.contains('lock-button') || 
                        e.target.classList.contains('chord-action-button') ||
                        e.target.classList.contains('piano-lock-button')) {
                        return; // Let the buttons handle their own clicks
                    }
                    
                    console.log('?? Single chord header clicked:', chordExt.name);
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const columnData = {
                        name: chordExt.name,
                        extensions: chordExt.extensions || [],
                        quality: chordExt.name.toLowerCase(),
                        id: chordExt.name.toLowerCase().replace(/\s+/g, '_'),
                        intervals: this.getChordIntervals(chordExt.extensions || []),
                        isCustom: chordExt.isCustom || false
                    };
                    
                    this.currentEditingColumn = columnData;
                    this.showColumnContextMenu(e.clientX, e.clientY);
                });
                
                column.appendChild(header);
                
                // Generate strings for this chord
                const intervals = this.getChordIntervals(chordExt.extensions || []);
                intervals.forEach((interval, stringIndex) => {
                    const string = document.createElement('div');
                    string.className = 'string';
                    string.dataset.interval = interval;
                    
                    // Calculate frequency for this string
                    const frequency = this.getFrequency(interval, this.currentRoot, this.currentTuning);
                    string.dataset.frequency = frequency;
                    
                    // Set note name
                    const noteName = this.getIntervalNoteName(interval);
                    string.textContent = noteName;
                    string.title = `${noteName} (${interval} steps, ${frequency.toFixed(1)}Hz)`;
                    
                    column.appendChild(string);
                });
                
                // Add to container
                container.appendChild(column);
                
                // Ensure new single-generated columns are draggable like others
                if (this.attachColumnDragHandlers) {
                    this.attachColumnDragHandlers(column);
                }
                
                return column;
            }
            
            preserveLockedChordsAndRegenerate() {
                console.log('?? Preserving locked chords before regeneration');
                
                // Store current locked chords before regeneration
                if (this.lockedChords && this.lockedChords.size > 0) {
                    this.savedLockedChords = Array.from(this.lockedChords.values());
                    console.log('?? Saved', this.savedLockedChords.length, 'locked chords before regeneration');
                    
                    // Store the original root before any changes occur
                    const originalRoot = this.currentRoot;
                    console.log('?? Original root before regeneration:', originalRoot);
                    
                    // CRITICAL: Preserve the chord extensions that are locked
                    // Don't let them get overwritten during regeneration
                    this.savedLockedChords.forEach(lockedChord => {
                        console.log('?? Preserving chord extension for locked chord:', lockedChord.chordName, 'with locked root:', lockedChord.lockedRoot);
                        
                        // Find the corresponding chord extension and mark it as locked
                        const chordExtension = this.chordExtensions.find(ext => {
                            // Try exact match first
                            if (ext.name === lockedChord.chordName) return true;
                            
                            // Try match with root prefix removed (e.g. "CTetrad" -> "Tetrad")
                            const nameWithoutRoot = lockedChord.chordName.replace(/^[A-G][#b]?/, '');
                            if (ext.name === nameWithoutRoot) return true;
                            
                            // Try custom chord match
                            if (ext.isCustom && lockedChord.lockId && lockedChord.lockId.includes(ext.id || ext.name)) return true;
                            
                            return false;
                        });
                        
                        if (chordExtension) {
                            // Mark this extension as locked so it won't be modified
                            chordExtension.isLocked = true;
                            chordExtension.lockedData = lockedChord;
                            console.log('?? Marked chord extension as locked:', chordExtension.name, 'for locked chord:', lockedChord.chordName);
                        } else {
                            console.warn('?? Could not find chord extension for locked chord:', lockedChord.chordName);
                        }
                    });
                }
                
                // Store current piano locked chords before regeneration
                if (this.pianoLockedChords && this.pianoLockedChords.size > 0) {
                    this.savedPianoLockedChords = Array.from(this.pianoLockedChords.values());
                    console.log('🎹 Saved', this.savedPianoLockedChords.length, 'piano locked chords before regeneration');
                    
                    // Mark chord extensions as piano locked
                    this.savedPianoLockedChords.forEach(pianoLockedData => {
                        const chordExtension = this.chordExtensions.find(ext => ext.name === pianoLockedData.chordName);
                        if (chordExtension) {
                            chordExtension.isPianoLocked = true;
                            chordExtension.pianoLockedData = pianoLockedData;
                            console.log('🎹 Marked chord extension as piano locked:', chordExtension.name);
                        }
                    });
                }
                
                // Clear the Maps since DOM elements will be destroyed
                this.lockedChords = new Map();
                this.pianoLockedChords = new Map();
                
                // Check if we have custom chords - if so, use exact regeneration
                const hasCustomChords = this.chordExtensions.some(chord => chord.isCustom);
                
                if (hasCustomChords) {
                    console.log('?? Has custom chords - using exact regeneration');
                    this.generateExactChordColumns();
                } else {
                    console.log('?? No custom chords - using standard regeneration');
                    this.generateExtensionColumns();
                }
            }

            generateExtensionColumns() {
                console.log('?? Generating extension columns for tuning:', this.currentTuning);
                console.log('?? Current chord extensions:', this.chordExtensions.length, 'chords:', this.chordExtensions.map(c => c.name));
                const container = document.getElementById('extensionColumns');
                
                // Clear container completely to remove any leftover columns
                container.innerHTML = '';
                container.style.display = 'flex';
                container.style.gap = '0px';
                container.style.width = '100%';
                container.style.height = '100%';
                
                const noteNames = this.getNoteNames();
                
                // Initialize hiddenColumns if not exists
                if (!this.hiddenColumns) {
                    this.hiddenColumns = [];
                }
                
                // Map chord extensions to identifiers for hiding
                const chordIds = this.chordExtensions.map((chord, index) => {
                    const id = chord.name.toLowerCase().replace(/\s+/g, '_');
                    console.log(`Mapping chord ${index}: "${chord.name}" -> ID: "${id}"`);
                    return id;
                });
                
                // Filter visible chord extensions
                const visibleExtensions = this.chordExtensions.filter((chordExt, index) => {
                    const chordId = chordIds[index];
                    const isVisible = !this.hiddenColumns.includes(chordId);
                    console.log(`Extension ${index}: "${chordExt.name}" (ID: ${chordId}) - Visible: ${isVisible}`);
                    return isVisible;
                });
                
                console.log('?? Visible extensions:', visibleExtensions.length, 'chords:', visibleExtensions.map(c => c.name));
                
                // If no visible extensions, show empty interface (only locked chords should be loaded)
                if (visibleExtensions.length === 0) {
                    console.log('?? No visible extensions - showing empty interface');
                    // Show message for empty state
                    container.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; color: #8fb3d3; font-size: 16px; text-align: center; flex-direction: column;">
                            <div style="margin-bottom: 10px;">No chords loaded</div>
                            <div style="font-size: 12px; opacity: 0.7;">Lock chords to save them, or use the chord builder to create new ones</div>
                        </div>
                    `;
                    
                    // Still restore locked chord states if they exist
                    this.restoreLockedChordStates();
                    return;
                }
                
                // Always use simple layout - one column per chord type (no more variants)
                console.log('Creating modern chord layout - each chord gets its own column');
                visibleExtensions.forEach((chordExt, extensionIndex) => {
                    const column = document.createElement('div');
                    column.className = 'extension-column';
                    column.dataset.chordType = chordIds[this.chordExtensions.indexOf(chordExt)];
                    // Persist absolute index to support precise mapping for delete/reorder without DOM recreation
                    try {
                        const absoluteIndex = (typeof chordExt.position === 'number') ? chordExt.position : (this.findChordIndex ? this.findChordIndex(chordExt) : this.chordExtensions.indexOf(chordExt));
                        column.dataset.originalPosition = String(absoluteIndex);
                        column.dataset.chordId = chordExt.id || column.dataset.chordType;
                    } catch (_) { /* non-fatal */ }
                    column.style.flex = '1'; // Each column takes equal width
                    column.style.height = '100%';
                    column.style.border = 'none';
                    column.style.borderRadius = '0';
                    column.style.margin = '0';
                    column.style.padding = '0';
                    
                    // Create header with chord name and action buttons
                    const header = document.createElement('div');
                    header.className = 'extension-header';
                    
                    // Create chord name span
                    const chordName = document.createElement('span');
                    chordName.className = 'chord-name';
                    
                    // Check if this chord extension is locked and preserve its locked name
                    if (chordExt.isLocked && chordExt.lockedData) {
                        const lockedData = chordExt.lockedData;
                        const rootName = this.getNoteNames()[lockedData.lockedRoot] || lockedData.lockedRoot;
                        
                        // Use the locked name exactly as it was when locked
                        if (lockedData.chordName.match(/^[A-G][#b]?/)) {
                            chordName.textContent = lockedData.chordName;
                        } else {
                            chordName.textContent = `${rootName}${lockedData.chordName}`;
                        }
                        
                        chordName.style.color = '#4CAF50';
                        chordName.style.fontWeight = 'bold';
                        chordName.dataset.isLocked = 'true';
                        chordName.dataset.lockedName = chordName.textContent;
                        chordName.title = `🔒 LOCKED: ${rootName} root, ${lockedData.lockedTuning}TET, ${lockedData.lockedOsc1.type}/${lockedData.lockedOsc2.type} waves`;
                    } else {
                        // Regular unlocked chord - use current name
                        chordName.textContent = chordExt.name;
                    }
                    
                    // Create buttons container
                    const buttonsContainer = document.createElement('div');
                    buttonsContainer.className = 'header-buttons';
                    
                    // Create edit button (ALWAYS VISIBLE)
                    const editButton = document.createElement('button');
                    editButton.className = 'chord-action-button edit';
                    editButton.innerHTML = '✏️';
                    editButton.title = 'Edit chord intervals';
                    // ALWAYS visible now
                    
                    // Create hide button (ALWAYS VISIBLE)
                    // Delete button removed — delete via upward drag
                    
                    // Create duplicate button (ALWAYS VISIBLE)
                    const duplicateButton = document.createElement('button');
                    duplicateButton.className = 'chord-action-button duplicate';
                    duplicateButton.innerHTML = '📋';
                    duplicateButton.title = 'Duplicate and edit';
                    // ALWAYS visible now
                    
                    // Create lock button
                    const lockButton = document.createElement('button');
                    lockButton.className = 'lock-button';
                    if (chordExt.isLocked && chordExt.lockedData) {
                        const rootName = this.getNoteNames()[chordExt.lockedData.lockedRoot] || chordExt.lockedData.lockedRoot;
                        lockButton.innerHTML = '🔒';
                        lockButton.classList.add('locked');
                        lockButton.title = `LOCKED to ${rootName} root with all settings - click to unlock`;
                    } else {
                        lockButton.innerHTML = '🔓';
                        lockButton.title = 'Lock complete sonic snapshot';
                    }
                    
                    // Add button event listeners using per-chord handlers (no globals)
                    editButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const chordDataForEdit = {
                            name: chordExt.name,
                            intervals: chordExt.intervals || this.getBaseTriadForQuality(this.stripRootFromName(chordExt.name).toLowerCase()),
                            isCustom: chordExt.isCustom || false,
                            id: chordExt.id || `${chordExt.name}_${Date.now()}`,
                            originalChord: chordExt
                        };
                        this.editChordFromButton(chordDataForEdit, column);
                    });
                    
                    editButton.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const chordDataForEdit = {
                            name: chordExt.name,
                            intervals: chordExt.intervals || this.getBaseTriadForQuality(this.stripRootFromName(chordExt.name).toLowerCase()),
                            isCustom: chordExt.isCustom || false,
                            id: chordExt.id || `${chordExt.name}_${Date.now()}`,
                            originalChord: chordExt
                        };
                        this.editChordFromButton(chordDataForEdit, column);
                    });
                    
                    
                    duplicateButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const chordDataForDupe = {
                            name: chordExt.name,
                            intervals: chordExt.intervals || this.getBaseTriadForQuality(this.stripRootFromName(chordExt.name).toLowerCase()),
                            isCustom: chordExt.isCustom || false,
                            id: chordExt.id || `${chordExt.name}_${Date.now()}`,
                            originalChord: chordExt
                        };
                        this.duplicateChordFromButton(chordDataForDupe, column);
                    });
                    
                    duplicateButton.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const chordDataForDupe = {
                            name: chordExt.name,
                            intervals: chordExt.intervals || this.getBaseTriadForQuality(this.stripRootFromName(chordExt.name).toLowerCase()),
                            isCustom: chordExt.isCustom || false,
                            id: chordExt.id || `${chordExt.name}_${Date.now()}`,
                            originalChord: chordExt
                        };
                        this.duplicateChordFromButton(chordDataForDupe, column);
                    });
                    
                    // Add lock button functionality
                    lockButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.lockSonicChord(chordExt, column);
                    });
                    
                    // Add touchstart for mobile compatibility
                    lockButton.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.lockSonicChord(chordExt, column);
                    });
                    
                    // Create piano lock button
                    const pianoLockButton = document.createElement('button');
                    pianoLockButton.className = 'piano-lock-button';
                    pianoLockButton.innerHTML = '🎹';
                    pianoLockButton.title = 'Lock oscillator & effect settings only';
                    
                    // Add piano lock button functionality
                    pianoLockButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        // If column is undefined, find the closest column element
                        const actualColumn = column || e.target.closest('.extension-column');
                        this.lockPianoSettings(chordExt, actualColumn);
                    });
                    
                    // Add touchstart for mobile compatibility
                    pianoLockButton.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        // If column is undefined, find the closest column element
                        const actualColumn = column || e.target.closest('.extension-column');
                        this.lockPianoSettings(chordExt, actualColumn);
                    });
                    
                    // Add buttons to container
                    buttonsContainer.appendChild(editButton);
                    buttonsContainer.appendChild(duplicateButton);
                    buttonsContainer.appendChild(lockButton);
                    buttonsContainer.appendChild(pianoLockButton);
                    
                    header.appendChild(chordName);
                    header.appendChild(buttonsContainer);
                    
                    // Color coding by type
                    let qualityColor;
                    if (chordExt.name === 'Major') qualityColor = { bg: '#1e40af', border: '#3b82f6' };
                    else if (chordExt.name === 'Neutral') qualityColor = { bg: '#059669', border: '#10b981' };
                    else if (chordExt.name === 'Minor') qualityColor = { bg: '#dc2626', border: '#ef4444' };
                    else qualityColor = { bg: '#4a5568', border: '#718096' }; // Default for custom
                    
                    header.style.backgroundColor = qualityColor.bg;
                    header.style.borderColor = qualityColor.border;
                    header.style.color = 'white';
                    header.style.border = `1px solid ${qualityColor.border}`;
                    
                    // Add context menu handlers
                    header.addEventListener('click', (e) => {
                        // Don't interfere with action button clicks
                        if (e.target.classList.contains('lock-button') || 
                            e.target.classList.contains('chord-action-button') ||
                            e.target.classList.contains('piano-lock-button')) {
                            return; // Let the buttons handle their own clicks
                        }
                        
                        console.log('🎵 Chord header clicked:', chordExt.name);
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const columnData = {
                            name: chordExt.name,
                            extensions: chordExt.extensions || [],
                            quality: chordExt.name.toLowerCase(),
                            id: chordIds[this.chordExtensions.indexOf(chordExt)],
                            isCustom: false,
                            originalName: chordExt.name,
                            extensionIndex: this.chordExtensions.indexOf(chordExt),
                            intervals: chordExt.intervals
                        };
                        
                        this.currentEditingColumn = columnData;
                        this.showColumnContextMenu(e.clientX, e.clientY);
                    });
                    
                    column.appendChild(header);
                    
                    // Add elements to header
                    header.appendChild(chordName);
                    header.appendChild(buttonsContainer);
                    
                    // Header click handler (simplified)
                    header.addEventListener('click', (e) => {
                        // Don't interfere with action button clicks
                        if (e.target.classList.contains('lock-button') || 
                            e.target.classList.contains('chord-action-button')) {
                            return; // Let the buttons handle their own clicks
                        }
                        
                        console.log('🎵 Chord header clicked:', chordExt.name);
                        e.preventDefault();
                        e.stopPropagation();
                    });
                    
                    column.appendChild(header);
                    
                    // Generate strings for this chord; prefer locked snapshot
                    if (chordExt.isLocked && chordExt.lockedData) {
                        this.generateStringsForColumnWithLockedSettings(column, chordExt.intervals, chordExt.lockedData);
                    } else {
                        this.generateStringsForColumn(column, chordExt.intervals, chordExt.isCustom || false);
                    }
                    
                    // Enable long-press drag reordering
                    this.attachColumnDragHandlers(column);
                    container.appendChild(column);
                });
                
                // Add click handlers after rendering
                setTimeout(() => {
                    console.log('✅ generateExtensionColumns finished, adding click handlers...');
                    this.addSimpleClickHandlers();
                    this.restoreLockedChordStates(); // Restore locked chord states
                    this.restorePianoLockStates(); // Restore piano lock states
                    console.log('✅ Click handlers and all locked states restored!');
                }, 100);
            }
            
            // Restore piano lock button states after column regeneration
            restorePianoLockStates() {
                if (!this.pianoLockedChords) return;
                
                console.log('🎹 Restoring piano lock states for', this.pianoLockedChords.size, 'locked chords');
                
                // Find all columns and check if they should have piano lock enabled
                const columns = document.querySelectorAll('.extension-column');
                columns.forEach(column => {
                    const chordType = column.dataset.chordType;
                    if (chordType) {
                        // Create basic chord data to check for piano lock
                        const basicChordData = {
                            name: chordType,
                            quality: this.currentQuality,
                            extensions: column.dataset.extensions ? column.dataset.extensions.split(',') : [],
                            intervals: []
                        };
                        
                        const pianoLockData = this.findPianoLockData(basicChordData);
                        if (pianoLockData) {
                            // Restore piano lock button state
                            const pianoLockButton = column.querySelector('.piano-lock-button');
                            if (pianoLockButton) {
                                pianoLockButton.classList.add('locked');
                                pianoLockButton.title = 'LOCKED oscillator & effect settings - click to unlock';
                                console.log('🎹 Restored piano lock state for:', basicChordData.name);
                            }
                        }
                    }
                });
            }
            
            getIntervalColor(interval) {
                // Neon color coding for musical intervals with microtonal gradient support
                const normalizedInterval = ((interval % 12) + 12) % 12;

                // Requested palette mapping (0-11):
                // 0 White, 1 Deep Violet, 2 Bright Orange, 3 Blue, 4 Red,
                // 5 Cyan, 6 Black, 7 Green, 8 Magenta, 9 Bright Yellow,
                // 10 Dark Blue, 11 Lime Green
                const chromaticColors = [
                    { interval: 0, color: '#FFFFFF', name: 'Root' },           // White
                    { interval: 1, color: '#6A0DAD', name: 'm2/♭9' },          // Deep Violet
                    { interval: 2, color: '#FFA500', name: 'M2/9' },           // Bright Orange
                    { interval: 3, color: '#0000FF', name: 'm3' },             // Blue
                    { interval: 4, color: '#FF0000', name: 'M3' },             // Red
                    { interval: 5, color: '#00FFFF', name: 'P4/11' },          // Cyan
                    { interval: 6, color: '#000000', name: 'TT' },             // Black (tritone)
                    { interval: 7, color: '#00FF00', name: 'P5' },             // Green
                    { interval: 8, color: '#FF00FF', name: 'm6/♯5' },          // Magenta
                    { interval: 9, color: '#FFFF00', name: 'M6/13' },          // Bright Yellow
                    { interval: 10, color: '#00008B', name: 'm7' },            // Dark Blue
                    { interval: 11, color: '#32CD32', name: 'M7' },            // Lime Green
                ];

                // Exact chromatic matches
                for (let i = 0; i < chromaticColors.length; i++) {
                    const chromatic = chromaticColors[i];
                    if (Math.abs(normalizedInterval - chromatic.interval) < 0.05) {
                        return { color: chromatic.color, name: chromatic.name };
                    }
                }

                // Microtonal interpolation between adjacent chromatic steps
                for (let i = 0; i < chromaticColors.length; i++) {
                    const current = chromaticColors[i];
                    const next = chromaticColors[(i + 1) % chromaticColors.length];

                    let lowerBound = current.interval;
                    let upperBound = next.interval;
                    if (next.interval < current.interval) upperBound = next.interval + 12; // wrap

                    let testInterval = normalizedInterval;
                    if (upperBound > 12 && normalizedInterval < 6) testInterval = normalizedInterval + 12;

                    if (testInterval > lowerBound + 0.05 && testInterval < upperBound - 0.05) {
                        const position = (testInterval - lowerBound) / (upperBound - lowerBound);
                        const gradientColor = this.interpolateColors(current.color, next.color, position);
                        const cents = Math.round((normalizedInterval - Math.floor(normalizedInterval)) * 100);
                        const baseName = current.name.split('/')[0];
                        const gradientName = `${baseName}+${cents}¢`;
                        return { color: gradientColor, name: gradientName };
                    }
                }

                return { color: '#CCCCCC', name: 'Unknown' };
            }

            // Map an EDO step to nearest 12-TET semitone index (0..11)
            stepToSemitone(step, edo) {
                if (edo <= 0) return 0;
                const semi = Math.round((step * 12) / edo) % 12;
                return ((semi % 12) + 12) % 12;
            }

            // Fixed chromatic palette (0..11) → hex
            getChromaticColorForSemitone(semi) {
                const idx = ((semi % 12) + 12) % 12;
                const palette = ['#FFFFFF','#6A0DAD','#FFA500','#0000FF','#FF0000','#00FFFF','#000000','#00FF00','#FF00FF','#FFFF00','#00008B','#32CD32'];
                return palette[idx] || '#CCCCCC';
            }

            // Simple contrast helper for header text
            pickTextColor(bgHex, light = '#FFFFFF', dark = '#000000') {
                const h = (bgHex || '#000000').replace('#','');
                const r = parseInt(h.substring(0,2),16) || 0;
                const g = parseInt(h.substring(2,4),16) || 0;
                const b = parseInt(h.substring(4,6),16) || 0;
                const brightness = (r*299 + g*587 + b*114) / 1000;
                return brightness > 150 ? dark : light;
            }
            
            interpolateColors(color1, color2, factor) {
                // Convert hex colors to RGB, interpolate, and convert back
                const hex1 = color1.replace('#', '');
                const hex2 = color2.replace('#', '');
                
                const r1 = parseInt(hex1.substr(0, 2), 16);
                const g1 = parseInt(hex1.substr(2, 2), 16);
                const b1 = parseInt(hex1.substr(4, 2), 16);
                
                const r2 = parseInt(hex2.substr(0, 2), 16);
                const g2 = parseInt(hex2.substr(2, 2), 16);
                const b2 = parseInt(hex2.substr(4, 2), 16);
                
                const r = Math.round(r1 + (r2 - r1) * factor);
                const g = Math.round(g1 + (g2 - g1) * factor);
                const b = Math.round(b1 + (b2 - b1) * factor);
                
                return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
            }

            generateStringsForColumn(column, intervals, isCustomChord = false) {
                // Check if this column has locked settings
                const lockedChord = this.lockedChords?.get(column);

                // If exact frequencies were captured for this column, render snapshot and exit
                if (lockedChord && Array.isArray(lockedChord.exactFrequencies) && lockedChord.exactFrequencies.length > 0) {
                    const oldContainer = column.querySelector('.strings-column');
                    if (oldContainer) oldContainer.remove();
                    this.generateStringsWithExactFrequencies(column, lockedChord);
                    return;
                }
                
                // Use locked settings if available, otherwise use current settings
                let currentRoot, currentTuning;
                if (lockedChord) {
                    currentRoot = lockedChord.lockedRoot;
                    currentTuning = lockedChord.lockedTuning;
                    console.log('🎵 Using locked settings for string generation - root:', currentRoot, 'tuning:', currentTuning);
                } else {
                    currentRoot = this.currentRoot;
                    currentTuning = this.currentTuning;
                }
                
                console.log('🔧 generateStringsForColumn called with:', {
                    intervals: intervals,
                    isCustomChord: isCustomChord,
                    currentTuning: currentTuning,
                    currentRoot: currentRoot
                });
                
                const noteNames = this.getNoteNames();
                const tuningSize = currentTuning || this.getTuningStepsPerOctave();
                
                // Generate string frequencies for full C1-C8 octave range (8 full octaves)
                const stringFreqs = [];
                for (let octave = 1; octave <= 8; octave++) {
                    intervals.forEach(interval => {
                        // Check if this is a custom chord with microtonal intervals
                        let edoStep;
                        if (isCustomChord) {
                            // Custom chords already have microtonal intervals, use directly
                            edoStep = interval;
                            console.log('🔧 Custom chord - using interval directly:', interval, '-> EDO step:', edoStep);
                        } else {
                            // Built-in chords use 12TET intervals, convert to current tuning
                            edoStep = this.mapIntervalToEDO(interval, currentTuning);
                            console.log('🔧 Built-in chord - converted interval:', interval, '-> EDO step:', edoStep);
                        }
                        
                        const step = (currentRoot + edoStep) % tuningSize;
                        const freq = this.getFrequency(step, octave, currentTuning);
                        stringFreqs.push({ freq, step, octave, interval });
                    });
                }
                
                // Sort by frequency to ensure proper ordering
                stringFreqs.sort((a, b) => a.freq - b.freq);
                
                // Calculate string sizing to fill full height of column
                const availableHeight = column.offsetHeight || 500; // Default height if not available
                const headerHeight = 40;
                const stringsHeight = availableHeight - headerHeight - 2; // Minimal padding
                const numStrings = stringFreqs.length;
                const stringHeight = Math.max(1, Math.floor(stringsHeight / numStrings) - 0.5); // Ensure strings are visible
                const stringMargin = 0.2; // Minimal margin
                
                // Create strings container that fills remaining space
                const stringsContainer = document.createElement('div');
                stringsContainer.className = 'strings-column';
                stringsContainer.style.cssText = `
                    flex: 1;
                    overflow: hidden;
                    padding: 1px;
                    height: calc(100% - ${headerHeight}px);
                    display: flex;
                    flex-direction: column;
                    justify-content: space-evenly;
                `;
                
                stringFreqs.forEach((stringData, stringIndex) => {
                    const row = document.createElement('div');
                    row.className = 'string';
                    row.dataset.index = stringIndex;
                    row.dataset.column = column.dataset.chordType || 'unknown';
                    row.dataset.frequency = stringData.freq;
                    row.dataset.noteIndex = stringData.step;

                    // Colors
                    const intervalColor = this.getIntervalColor(stringData.interval);
                    const baseColor = intervalColor.color;
                    const glowColor = (baseColor && baseColor.toLowerCase() === '#000000') ? '#555555' : baseColor;
                    row.dataset.glowColor = glowColor;

                    // Visible core
                    const core = document.createElement('div');
                    core.className = 'string-core';
                    core.style.background = baseColor;
                    core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;

                    row.title = `${intervalColor.name} - ${noteNames[stringData.step] || `Note ${stringData.step}`} - Oct${stringData.octave} - ${stringData.freq.toFixed(1)}Hz`;

                    // Hover effects on core
                    row.addEventListener('mouseenter', () => {
                        core.style.transform = 'scaleY(1.25)';
                        core.style.boxShadow = `0 0 6px ${glowColor}, 0 0 14px ${glowColor}CC, 0 0 28px ${glowColor}88`;
                    });
                    row.addEventListener('mouseleave', () => {
                        core.style.transform = 'scaleY(1)';
                        core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;
                    });

                    // Attach core
                    row.appendChild(core);
                    stringsContainer.appendChild(row);

                    // Precompute vibration period and store on core
                    const period = this.computeVibrationPeriod(stringData.freq, stringData.step);
                    core.style.setProperty('--vib-period', period + 'ms');
                });
                // Post-fit adjustment to guarantee no hidden octaves
                this.ensureStringsFullyVisible(stringsContainer);
                
                column.appendChild(stringsContainer);
            }

            // Shrink string heights uniformly if overflow would hide octaves
            ensureStringsFullyVisible(parent){
                if(!parent) return;
                const strings = Array.from(parent.querySelectorAll('.string'));
                if(!strings.length) return;
                // small timeout ensures layout values are settled if heights were zero initially
                const adjust = ()=>{
                    const visibleH = parent.clientHeight;
                    if(visibleH<=0) return;
                    const total = strings.reduce((sum,s)=> sum + s.offsetHeight, 0);
                    if(total <= visibleH) return; // fits already
                    const target = Math.max(1, Math.floor((visibleH - (strings.length*0.4)) / strings.length));
                    strings.forEach(s=>{ s.style.height = target + 'px'; });
                };
                // Run twice (immediate + next frame) to catch late layout
                adjust();
                requestAnimationFrame(adjust);
            }
            
            adjustColorBrightness(hexColor, percent) {
                // Utility function to adjust color brightness
                const num = parseInt(hexColor.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
            
            hexToRgb(hex) {
                // Convert hex color to RGB values
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }
            
            mapIntervalToEDO(interval, tuning = null) {
                // Map 12-TET intervals to the nearest equivalent in the current EDO
                // This preserves diatonic relationships properly
                const tuningSize = tuning || this.getTuningStepsPerOctave();
                const currentTuning = tuning || this.currentTuning;
                
                if (currentTuning === 12) {
                    // For 12-TET, return the interval as-is
                    return Math.round(interval);
                }
                
                // For other EDOs, map to the nearest step that preserves musical relationships
                const exactStep = (interval * tuningSize) / 12;
                return Math.round(exactStep);
            }
            
            getBaseTriadForQuality(quality) {
                // Return standard diatonic intervals in semitones
                // These will be properly mapped to EDO steps by mapIntervalToEDO
                let intervals = [0]; // Root
                
                switch (quality) {
                    case 'major':
                        intervals.push(4); // Major third (4 semitones)
                        intervals.push(7); // Perfect fifth (7 semitones)
                        break;
                    case 'minor':
                        intervals.push(3); // Minor third (3 semitones)
                        intervals.push(7); // Perfect fifth (7 semitones)
                        break;
                    case 'neutral':
                        intervals.push(3.5); // Neutral third (3.5 semitones)
                        intervals.push(7); // Perfect fifth (7 semitones)
                        break;
                    case 'diminished':
                        intervals.push(3); // Minor third
                        intervals.push(6); // Diminished fifth
                        break;
                    case 'augmented':
                        intervals.push(4); // Major third
                        intervals.push(8); // Augmented fifth
                        break;
                    case 'sus2':
                        intervals.push(2); // Major second
                        intervals.push(7); // Perfect fifth
                        break;
                    case 'sus4':
                        intervals.push(5); // Perfect fourth
                        intervals.push(7); // Perfect fifth
                        break;
                    default:
                        intervals.push(4); // Default to major third
                        intervals.push(7); // Perfect fifth
                        break;
                }
                
                return intervals;
            }
            
            convertExtensionsToIntervals(extensions) {
                // Return extensions as semitone intervals that will be mapped by mapIntervalToEDO
                const intervals = [];
                
                extensions.forEach(ext => {
                    switch (ext) {
                        case '6':
                            intervals.push(9); // Major 6th (9 semitones)
                            break;
                        case '7':
                            intervals.push(10); // Minor 7th (10 semitones)
                            break;
                        case 'maj7':
                            intervals.push(11); // Major 7th (11 semitones)
                            break;
                        case '9':
                            intervals.push(10); // 7th (required for 9th chords)
                            intervals.push(14); // 9th (2 semitones up an octave = 14)
                            break;
                        case '11':
                            intervals.push(10); // 7th (required for 11th chords)
                            intervals.push(14); // 9th (often included in 11th chords)
                            intervals.push(17); // 11th (5 semitones up an octave = 17)
                            break;
                        case 's11':
                        case '#11':
                            intervals.push(10); // 7th
                            intervals.push(14); // 9th
                            intervals.push(18); // #11th (6 semitones up an octave = 18)
                            break;
                        case '13':
                            intervals.push(10); // 7th (required for 13th chords)
                            intervals.push(14); // 9th (usually included)
                            intervals.push(17); // 11th (usually included)
                            intervals.push(21); // 13th (9 semitones up an octave = 21)
                            break;
                        case 's13':
                        case '#13':
                            intervals.push(10); // 7th
                            intervals.push(14); // 9th
                            intervals.push(17); // 11th
                            intervals.push(22); // #13th (10 semitones up an octave = 22)
                            break;
                        case 'sus2':
                            intervals.push(2); // Major 2nd
                            break;
                        case 'sus4':
                            intervals.push(5); // Perfect 4th
                            break;
                        case 'add9':
                            intervals.push(14); // 9th (2 semitones up an octave, no 7th)
                            break;
                        case 'neutral7':
                            intervals.push(10); // Still minor 7th, but will be applied to neutral triads
                            break;
                        case 'neutral11':
                            intervals.push(10); // 7th
                            intervals.push(14); // 9th
                            intervals.push(17); // 11th
                            break;
                    }
                });
                
                return intervals;
            }

            // Attach long-press drag and dwell-to-swap on a column (initiation on header or free space only)
            attachColumnDragHandlers(column) {
                try {
                    const container = document.getElementById('extensionColumns');
                    if (!container || !column) return;
                    const header = column.querySelector('.extension-header');
                    if (!header) return;

                    const LONG_PRESS_MS = 200;
                    const DWELL_MS = 200;
                    const JITTER_PX = 6;
                    const DELETE_THRESHOLD_PX = 5; // delete only if dragged to top of the viewport

                    let pressTimer = null;
                    let isDragging = false;
                    let startX = 0, startY = 0;
                    let grabOffsetX = 0, grabOffsetY = 0;
                    let placeholder = null;
                    let dwellTimer = null;
                    let deleteIntent = false;
                    let originalAbsIndex = null;
                    let lastSwapTarget = null;
                    let lastSwapTargetAbsIndex = null;

                    const getPointer = (e) => (e.touches && e.touches[0]) || e;
                    const canStartFrom = (target) => {
                        // allow from header or empty space inside column; block buttons
                        if (!target) return false;
                        if (target.closest('.chord-action-button') || target.closest('.lock-button') || target.closest('.piano-lock-button')) return false;
                        return target.closest('.extension-header') || target.closest('.extension-column');
                    };

                    const swapNodes = (a, b) => {
                        if (!a || !b || a === b) return;
                        const aMarker = document.createElement('div');
                        const bMarker = document.createElement('div');
                        const parent = a.parentNode;
                        if (!parent || !b.parentNode) return;
                        parent.insertBefore(aMarker, a);
                        parent.insertBefore(bMarker, b);
                        parent.replaceChild(b, aMarker);
                        parent.replaceChild(a, bMarker);
                    };

                    const onPressStart = (e) => {
                        if (!canStartFrom(e.target)) return;
                        const p = getPointer(e);
                        startX = p.clientX; startY = p.clientY;
                        pressTimer = setTimeout(() => beginDrag(p), LONG_PRESS_MS);
                    };

                    const cancelPress = () => { if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; } };

                    const maybeCancelOnMove = (e) => {
                        if (!pressTimer) return;
                        const p = getPointer(e);
                        if (Math.abs(p.clientX - startX) > JITTER_PX || Math.abs(p.clientY - startY) > JITTER_PX) cancelPress();
                    };

                    const beginDrag = (p) => {
                        isDragging = true;
                        column.classList.add('dragging');
                        const rect = column.getBoundingClientRect();
                        grabOffsetX = p.clientX - rect.left;
                        grabOffsetY = p.clientY - rect.top;
                        column.style.width = rect.width + 'px';
                        column.style.height = rect.height + 'px';
                        column.style.position = 'fixed';
                        column.style.zIndex = 9999;
                        column.style.pointerEvents = 'none';
                        column.style.transform = 'scale(1.03)';
                        column.style.boxShadow = '0 12px 22px rgba(0,0,0,0.35)';

                        // placeholder
                        placeholder = document.createElement('div');
                        placeholder.className = 'extension-column placeholder';
                        placeholder.style.width = rect.width + 'px';
                        placeholder.style.height = rect.height + 'px';
                        placeholder.style.flex = '1';
                        placeholder.style.border = '2px dashed rgba(255,255,255,0.3)';
                        column.parentNode.insertBefore(placeholder, column);

                        // Capture the absolute index for the dragged column (for data swap)
                        try {
                            if (this.getIndexFromColumn) {
                                originalAbsIndex = this.getIndexFromColumn(column);
                            } else if (column.dataset && column.dataset.originalPosition) {
                                originalAbsIndex = parseInt(column.dataset.originalPosition, 10);
                            } else {
                                originalAbsIndex = Array.from(container.querySelectorAll('.extension-column')).indexOf(column);
                            }
                        } catch (_) { originalAbsIndex = null; }
                        lastSwapTarget = null;
                        lastSwapTargetAbsIndex = null;

                        moveDrag(p);
                        window.addEventListener('mousemove', onMove, { passive: false });
                        window.addEventListener('touchmove', onMove, { passive: false });
                        window.addEventListener('mouseup', onEnd);
                        window.addEventListener('touchend', onEnd);
                    };

                    const moveDrag = (p) => {
                        const x = p.clientX - grabOffsetX;
                        const y = p.clientY - grabOffsetY;
                        column.style.left = x + 'px';
                        column.style.top = y + 'px';

                        // delete intent near top
                        // Only flag delete when pointer is near the very top of the viewport
                        const shouldDelete = (p.clientY <= DELETE_THRESHOLD_PX);
                        if (shouldDelete !== deleteIntent) {
                            deleteIntent = shouldDelete;
                            column.classList.toggle('delete-intent', deleteIntent);
                        }

                        // dwell swap logic: swap ONLY the dragged column's placeholder with the hovered column
                        const siblings = Array.from(container.querySelectorAll('.extension-column'))
                            .filter(el => el !== column && !el.classList.contains('placeholder'));
                        let over = siblings.find(el => {
                            const r = el.getBoundingClientRect();
                            return p.clientX > r.left && p.clientX < r.right && p.clientY > r.top && p.clientY < r.bottom;
                        });

                        // Fallback using elementFromPoint for reliability across browsers
                        if (!over) {
                            const hit = document.elementFromPoint(p.clientX, p.clientY);
                            const hitCol = hit && hit.closest ? hit.closest('.extension-column') : null;
                            if (hitCol && hitCol !== column && !hitCol.classList.contains('placeholder')) {
                                over = hitCol;
                            }
                        }

                        if (over) {
                            if (!dwellTimer) {
                dwellTimer = setTimeout(() => {
                                    if (!placeholder || !over.parentNode) return;
                                    if (over !== lastSwapTarget) {
                                        // Swap placeholder and the hovered column to reflect a simple two-box swap
                                        swapNodes(placeholder, over);
                                        lastSwapTarget = over;
                                        try {
                                            lastSwapTargetAbsIndex = this.getIndexFromColumn ? this.getIndexFromColumn(over) : (over.dataset && over.dataset.originalPosition ? parseInt(over.dataset.originalPosition, 10) : null);
                                        } catch(_) { lastSwapTargetAbsIndex = null; }
                    // Allow subsequent swaps by resetting the dwell timer state
                    clearTimeout(dwellTimer);
                    dwellTimer = null;
                                    }
                                }, DWELL_MS);
                            }
                        } else if (dwellTimer) {
                            clearTimeout(dwellTimer); dwellTimer = null;
                        }
                    };

                    const onMove = (e) => { if (!isDragging && pressTimer) { maybeCancelOnMove(e); return; } if (!isDragging) return; const p = getPointer(e); moveDrag(p); e.preventDefault(); };

                    const onEnd = () => {
                        cancelPress();
                        window.removeEventListener('mousemove', onMove);
                        window.removeEventListener('touchmove', onMove);
                        window.removeEventListener('mouseup', onEnd);
                        window.removeEventListener('touchend', onEnd);
                        if (dwellTimer) { clearTimeout(dwellTimer); dwellTimer = null; }

                        column.classList.remove('dragging');
                        column.style.position = '';
                        column.style.left = '';
                        column.style.top = '';
                        column.style.zIndex = '';
                        column.style.pointerEvents = '';
                        column.style.transform = '';
                        column.style.boxShadow = '';
                        column.style.width = '';
                        column.style.height = '';

                        if (deleteIntent) {
                            deleteIntent = false;
                            // remove column and update data (do not recreate nodes for others)
                            const idx = this.getIndexFromColumn ? this.getIndexFromColumn(column) : Array.from(container.children).indexOf(column);
                            if (idx > -1) {
                                this.chordExtensions.splice(idx, 1);
                                column.remove();
                                this.normalizeChordPositions?.();
                                this.saveChordConfiguration?.();
                            }
                            if (placeholder) placeholder.remove();
                            return;
                        }

                        if (placeholder && placeholder.parentNode) {
                            placeholder.parentNode.insertBefore(column, placeholder);
                            placeholder.remove();
                        }

                        // Rebuild data order from DOM to reflect the final visual order (works for single swap or cascades)
                        const orderedEls = Array.from(container.querySelectorAll('.extension-column'));
                        if (Array.isArray(this.chordExtensions) && orderedEls.length) {
                            const newArray = [];
                            for (let i = 0; i < orderedEls.length; i++) {
                                const el = orderedEls[i];
                                const oldIdx = el.dataset && el.dataset.originalPosition ? parseInt(el.dataset.originalPosition, 10) : i;
                                const model = this.chordExtensions[oldIdx] ?? this.chordExtensions[i];
                                if (model) {
                                    model.position = i;
                                    newArray.push(model);
                                    // Update dataset to new index for consistent future operations
                                    try { el.dataset.originalPosition = String(i); } catch(_) {}
                                }
                            }
                            if (newArray.length === this.chordExtensions.length) {
                                this.chordExtensions = newArray;
                                this.normalizeChordPositions?.();
                                this.saveChordConfiguration?.();
                                // Ensure the visible header names/lock states match the new underlying model order
                                if (typeof this.syncColumnHeaderToModel === 'function') {
                                    for (let i = 0; i < orderedEls.length; i++) {
                                        try { this.syncColumnHeaderToModel(orderedEls[i], this.chordExtensions[i]); } catch(_) {}
                                    }
                                }
                            }
                        }
                    };

                    // Initiation only from header or free space
                    header.addEventListener('mousedown', (e) => { if (e.button !== 0) return; onPressStart(e); });
                    header.addEventListener('touchstart', (e) => { onPressStart(e); }, { passive: true });

                } catch (err) { console.error('attachColumnDragHandlers error:', err); }
            }
            
            getTuningStepsPerOctave() {
                // Handle custom tuning objects
                if (typeof this.currentTuning === 'object' && this.currentTuning.type === 'custom') {
                    // For non-octave tunings, we need to calculate how many steps make an octave
                    const [num, den] = this.currentTuning.ratio;
                    const ratioInOctaves = Math.log2(num / den);
                    return this.currentTuning.divisions / ratioInOctaves;
                }
                
                if (typeof this.currentTuning === 'string') {
                    switch(this.currentTuning) {
                        case 'carlos-alpha': return 78.0;
                        case 'carlos-beta': return 18.8;
                        case 'carlos-gamma': return 34.1895;
                        case 'carlos-delta': return 10.024;
                        case 'lucy': return 6.283; // approximately 2p
                        case 'pythagorean':
                        case 'just':
                        case 'meantone':
                            return 12;
                        case 'arabic': return 24;
                        case 'gamelan-pelog': return 7;
                        case 'gamelan-slendro': return 5;
                        default: return 12;
                    }
                }
                return this.currentTuning;
            }

            // Synchronize a column's header text and lock UI to the provided chord model
            syncColumnHeaderToModel(column, chordModel) {
                if (!column || !chordModel) return;
                const chordNameEl = column.querySelector('.chord-name');
                const lockBtn = column.querySelector('.lock-button');
                if (!chordNameEl) return;

                if (chordModel.isLocked && chordModel.lockedData) {
                    const locked = chordModel.lockedData;
                    const rootName = (this.getNoteNames()[locked.lockedRoot] || locked.lockedRoot);
                    if (locked.chordName && /^[A-G][#b]?/.test(locked.chordName)) {
                        chordNameEl.textContent = locked.chordName;
                    } else if (locked.chordName) {
                        chordNameEl.textContent = `${rootName}${locked.chordName}`;
                    } else {
                        chordNameEl.textContent = `${rootName}${chordModel.name || ''}`;
                    }
                    chordNameEl.style.color = '#4CAF50';
                    chordNameEl.style.fontWeight = 'bold';
                    chordNameEl.dataset.isLocked = 'true';
                    chordNameEl.dataset.lockedName = chordNameEl.textContent;
                    if (lockBtn) {
                        lockBtn.innerHTML = '🔒';
                        lockBtn.classList.add('locked');
                        lockBtn.title = `LOCKED to ${rootName} root with all settings`;
                    }
                } else {
                    chordNameEl.textContent = chordModel.name || '';
                    chordNameEl.style.color = '';
                    chordNameEl.style.fontWeight = '';
                    chordNameEl.dataset.isLocked = '';
                    chordNameEl.dataset.lockedName = '';
                    if (lockBtn) {
                        lockBtn.innerHTML = '🔓';
                        lockBtn.classList.remove('locked');
                        lockBtn.title = 'Lock complete sonic snapshot';
                    }
                }
            }

            addSimpleClickHandlers() {
                console.log('?? Adding simple click handlers to all extension headers');
                
                // Handle extension column headers - PRIORITY handlers for chord name context menu
                const headers = document.querySelectorAll('.extension-header');
                console.log('?? Found', headers.length, 'extension headers');
                
                headers.forEach(header => {
                    // Remove any existing simple click handler to avoid duplicates
                    if (header.simpleClickAdded) return;
                    header.simpleClickAdded = true;
                    
                    console.log('?? Adding chord name context menu handler to header:', header.textContent);
                    
                    // Add immediate click handler with high priority
                    header.addEventListener('click', (e) => {
                        // Don't interfere with lock button clicks
                        if (e.target.classList.contains('lock-button')) {
                            console.log('?? Lock button clicked, allowing event to proceed');
                            return; // Let the lock button handle its own click
                        }
                        
                        console.log('?? IMMEDIATE CLICK on header:', header.textContent);
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        
                        const column = header.closest('.extension-column');
                        if (!column) return;
                        
                        const chordData = this.getChordDataFromColumn(column, header);
                        if (chordData) {
                            console.log('?? Showing CHORD NAME context menu for click:', chordData);
                            // Context menu removed - no action taken
                        }
                    }, true); // Use capture phase for highest priority
                    
                    // Also add a pointerdown event for better mobile support
                    header.addEventListener('pointerdown', (e) => {
                        console.log('?? POINTERDOWN on header:', header.textContent);
                        
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const column = header.closest('.extension-column');
                        if (!column) return;
                        
                        const chordData = this.getChordDataFromColumn(column, header);
                        if (chordData) {
                            console.log('?? Showing CHORD NAME context menu for pointerdown:', chordData);
                            // Context menu removed - no action taken
                        }
                    }, true); // Use capture phase for highest priority
                    
                    header.addEventListener('mousedown', (e) => {
                        console.log('?? MOUSEDOWN on header:', header.textContent);
                        
                        // Only handle left mouse button
                        if (e.button !== 0) return;
                        
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const column = header.closest('.extension-column');
                        if (!column) return;
                        
                        const chordData = this.getChordDataFromColumn(column, header);
                        if (chordData) {
                            console.log('?? Showing CHORD NAME context menu for mousedown:', chordData);
                            // Context menu removed - no action taken
                        }
                    }, true); // Use capture phase for highest priority
                    
                    // Add right-click context menu for easier access
                    header.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        console.log('Right-click on extension header, showing chord name context menu');
                        
                        const column = header.closest('.extension-column');
                        if (column) {
                            const chordData = this.getChordDataFromColumn(column, header);
                            if (chordData) {
                                // Context menu removed - no action taken
                            }
                        }
                    });
                    
                    // Also add touchstart for mobile
                    header.addEventListener('touchstart', (e) => {
                        console.log('TOUCHSTART on header:', header.textContent);
                        
                        // Don't interfere with button clicks - let them bubble up
                        if (e.target.classList.contains('lock-button') || 
                            e.target.classList.contains('piano-lock-button') ||
                            e.target.tagName === 'BUTTON') {
                            console.log('Touch on button, allowing default behavior');
                            return;
                        }
                        
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const column = header.closest('.extension-column');
                        if (!column) return;
                        
                        const chordData = this.getChordDataFromColumn(column, header);
                        if (chordData) {
                            console.log('Showing CHORD NAME context menu for touchstart:', chordData);
                            const touch = e.touches[0];
                            // Context menu removed - no action taken
                        }
                    }, { passive: false });
                });
                
                // Handle palette chord headers
                document.querySelectorAll('.palette-chord .extension-header').forEach(header => {
                    if (header.simplePaletteClickAdded) return;
                    header.simplePaletteClickAdded = true;
                    
                    header.addEventListener('mousedown', (e) => {
                        if (e.button !== 0) return;
                        
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const paletteChord = header.closest('.palette-chord');
                        if (paletteChord) {
                            const chordIndex = parseInt(paletteChord.dataset.chordIndex);
                            const chordData = this.paletteChords[chordIndex];
                            if (chordData) {
                                console.log('Showing palette context menu for mousedown:', chordData);
                                this.showPaletteContextMenu(e.clientX, e.clientY, chordData);
                            }
                        }
                    });
                    
                    header.addEventListener('touchstart', (e) => {
                        // Don't interfere with button clicks - let them bubble up
                        if (e.target.classList.contains('lock-button') || 
                            e.target.classList.contains('piano-lock-button') ||
                            e.target.tagName === 'BUTTON') {
                            console.log('Touch on button, allowing default behavior');
                            return;
                        }
                        
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const paletteChord = header.closest('.palette-chord');
                        if (paletteChord) {
                            const chordIndex = parseInt(paletteChord.dataset.chordIndex);
                            const chordData = this.paletteChords[chordIndex];
                            if (chordData) {
                                const touch = e.touches[0];
                                this.showPaletteContextMenu(touch.clientX, touch.clientY, chordData);
                            }
                        }
                    }, { passive: false });
                });
            }

            stopAllActiveNotes() {
                // Gradually stop all oscillators with natural release
                this.activeOscillators.forEach((noteInfo, noteId) => {
                    if (noteInfo.envelope && noteInfo.osc) {
                        const currentTime = this.audioContext.currentTime;
                        // Apply release phase
                        noteInfo.envelope.gain.cancelScheduledValues(currentTime);
                        noteInfo.envelope.gain.setValueAtTime(noteInfo.envelope.gain.value, currentTime);
                        noteInfo.envelope.gain.linearRampToValueAtTime(0, currentTime + this.envelope.release);
                        
                        // Stop oscillator after release
                        setTimeout(() => {
                            if (noteInfo.osc) {
                                try {
                                    noteInfo.osc.stop();
                                } catch(e) {}
                            }
                            this.activeOscillators.delete(noteId);
                        }, this.envelope.release * 1000 + 100);
                    }
                });
            }

            handleStringTrigger(event, touchId = null) {
                const elements = document.elementsFromPoint(event.clientX, event.clientY);
                const stringElement = elements.find(el => el.classList.contains('string'));
                
                if (stringElement) {
                    const stringIndex = stringElement.dataset.index;
                    const column = parseInt(stringElement.dataset.column) || stringElement.dataset.column;
                    const trackingSet = touchId !== null ? 
                        this.activeTouches.get(touchId)?.triggeredStrings : 
                        this.triggeredStrings;
                    
                    // Throttle triggering per string to avoid audio spam but maintain responsiveness
                    const now = performance.now();
                    const lastTrigger = stringElement.lastTriggerTime || 0;
                    const minInterval = 10; // 10ms minimum between triggers per string
                    
                    if (now - lastTrigger > minInterval) {
                        this.currentPlayingColumn = column;
                        const frequency = parseFloat(stringElement.dataset.frequency);
                        this.playFrequency(frequency, stringElement);
                        this.updateCurrentChord(column);
                        
                        stringElement.lastTriggerTime = now;
                        
                        // Add to tracking for cleanup
                        if (trackingSet) {
                            trackingSet.add(stringIndex);
                            // Quick removal to allow retriggering
                            setTimeout(() => {
                                trackingSet.delete(stringIndex);
                            }, 20);
                        }
                    }
                }
            }

            handlePaletteStringTrigger(event) {
                console.log('handlePaletteStringTrigger called at', event.clientX, event.clientY);
                const elements = document.elementsFromPoint(event.clientX, event.clientY);
                const stringElement = elements.find(el => el.classList.contains('string') && el.dataset.paletteIndex !== undefined);
                console.log('Found string element:', stringElement, 'frequency:', stringElement?.dataset?.frequency);
                
                if (stringElement) {
                    const stringIndex = stringElement.dataset.index;
                    const paletteIndex = stringElement.dataset.paletteIndex;
                    const rawFrequency = stringElement.dataset.frequency;
                    console.log('Raw frequency data:', rawFrequency, 'type:', typeof rawFrequency);
                    
                    // Throttle triggering per string to avoid audio spam but maintain responsiveness
                    const now = performance.now();
                    const lastTrigger = stringElement.lastTriggerTime || 0;
                    const minInterval = 10; // 10ms minimum between triggers per string
                    
                    if (now - lastTrigger > minInterval && !this.paletteTriggeredStrings.has(stringIndex)) {
                        const frequency = parseFloat(rawFrequency);
                        console.log('Parsed frequency:', frequency, 'isValid:', !isNaN(frequency) && isFinite(frequency));
                        
                        if (!isNaN(frequency) && isFinite(frequency)) {
                            this.playFrequency(frequency, stringElement);
                            
                            stringElement.lastTriggerTime = now;
                            this.paletteTriggeredStrings.add(stringIndex);
                            
                            // Quick removal to allow retriggering
                            setTimeout(() => {
                                this.paletteTriggeredStrings.delete(stringIndex);
                            }, 20);
                            
                            console.log('Palette string triggered:', frequency, 'Hz from palette chord', paletteIndex);
                        } else {
                            console.error('Invalid frequency for palette string:', rawFrequency, 'parsed as:', frequency);
                        }
                    }
                }
            }

            updateCurrentChord(column) {
                // Check if the column has piano-locked settings and apply them
                const columnElement = document.querySelector(`[data-column="${column}"]`);
                if (columnElement && this.pianoLockedChords && this.pianoLockedChords.has(columnElement)) {
                    const pianoLockedData = this.pianoLockedChords.get(columnElement);
                    this.applyPianoLockedSettings(pianoLockedData);
                }
            }

            playChordStrum(columnElement, chordData, startY, endY) {
                // Check if this chord is locked
                let originalSettings = null;
                const lockedChord = this.lockedChords?.get(columnElement);
                
                // Check if this chord has piano-locked settings
                const pianoLockedData = this.pianoLockedChords?.get(columnElement);
                
                if (lockedChord) {
                    console.log('?? Playing locked chord:', lockedChord.chordName, 'locked to root:', lockedChord.lockedRoot);
                    // Store current settings
                    originalSettings = this.captureCurrentSettings();
                    // Apply locked settings
                    this.applyLockedChordSettings(lockedChord);
                    
                    // Always make sure we're using the locked root for playback
                    if (this.currentRoot !== lockedChord.lockedRoot) {
                        console.log('?? Overriding current root', this.currentRoot, 'with locked root:', lockedChord.lockedRoot, 'for playback');
                        this.currentRoot = lockedChord.lockedRoot;
                    }
                } else if (pianoLockedData) {
                    // Apply piano-locked settings (oscillator & effects only)
                    console.log('🎹 Playing chord with piano-locked settings:', pianoLockedData.chordName);
                    this.applyPianoLockedSettings(pianoLockedData);
                }
                
                // Get all strings in the column
                const strings = Array.from(columnElement.querySelectorAll('.string'));
                if (strings.length === 0) return;
                
                // Calculate which strings to play based on start and end positions
                const columnRect = columnElement.getBoundingClientRect();
                const relativeStartY = startY - columnRect.top;
                const relativeEndY = endY - columnRect.top;
                
                // Determine strum direction and range
                const strumDown = relativeEndY > relativeStartY;
                const minY = Math.min(relativeStartY, relativeEndY);
                const maxY = Math.max(relativeStartY, relativeEndY);
                
                // Filter strings that fall within the strum range
                const stringsToPlay = strings.filter(string => {
                    const stringRect = string.getBoundingClientRect();
                    const stringY = stringRect.top + stringRect.height / 2 - columnRect.top;
                    return stringY >= minY && stringY <= maxY;
                });
                
                if (stringsToPlay.length === 0) return;
                
                // Sort strings by position for directional strumming
                stringsToPlay.sort((a, b) => {
                    const aY = a.getBoundingClientRect().top;
                    const bY = b.getBoundingClientRect().top;
                    return strumDown ? aY - bY : bY - aY;
                });
                
                // Much faster strum for high-speed playing - 8ms between strings
                const strumDelay = 8; 
                
                stringsToPlay.forEach((string, index) => {
                    setTimeout(() => {
                        const frequency = parseFloat(string.dataset.frequency);
                        if (frequency && !isNaN(frequency)) {
                            this.playFrequency(frequency, string);
                            
                            // Minimal visual feedback for speed on core only
                            const core = string.querySelector('.string-core');
                            if (core) {
                                core.style.transform = 'scaleY(1.15)';
                                core.style.filter = 'brightness(1.12)';
                                setTimeout(() => {
                                    core.style.transform = 'scaleY(1)';
                                    core.style.filter = 'brightness(1)';
                                }, 90);
                            }
                        }
                    }, index * strumDelay);
                });
                
                // Much shorter note duration for clean fast strumming
                setTimeout(() => {
                    stringsToPlay.forEach(string => {
                        const frequency = parseFloat(string.dataset.frequency);
                        if (frequency && !isNaN(frequency)) {
                            this.stopFrequency(frequency, string);
                        }
                    });
                }, 200 + (stringsToPlay.length * strumDelay)); // Very short duration
                
                // Restore original settings if this was a locked chord
                if (originalSettings) {
                    setTimeout(() => {
                        this.restoreSettings(originalSettings);
                        console.log('?? Restored original settings after locked chord playback');
                    }, 250 + (stringsToPlay.length * strumDelay));
                }
            }

            playFrequency(frequency, element) {
                console.log('playFrequency called with:', frequency, 'Hz', element ? 'element present' : 'no element');
                
                // Validate frequency before processing
                if (!frequency || isNaN(frequency) || !isFinite(frequency) || frequency <= 0) {
                    console.error('Invalid frequency passed to playFrequency:', frequency);
                    return;
                }
                
                // Check if this string belongs to a piano-locked chord and apply those settings
                const columnElement = element && element.closest ? element.closest('.extension-column') : null;
                let pianoLockedData = null;
                let originalSettings = null;
                
                if (columnElement) {
                    // Try to find piano lock data by chord identification
                    const chordType = columnElement.dataset.chordType;
                    if (chordType) {
                        // Create a basic chord data object to generate the lock key
                        // IMPORTANT: Match the exact format used when creating the lock
                        let chordName = chordType;
                        let intervals = [];
                        
                        // Handle different chord types properly
                        if (chordType === 'major') {
                            chordName = 'Major'; // Convert to proper case
                            intervals = [0, 4, 7]; // Include default major intervals
                        } else {
                            // For custom chords, try to find the actual chord data to get intervals
                            const headerElement = columnElement.querySelector('.extension-header');
                            const chordData = this.getChordDataFromColumn(columnElement, headerElement);
                            if (chordData && chordData.intervals) {
                                intervals = [...chordData.intervals];
                                chordName = chordData.name; // Use exact name from chord data
                            } else {
                                // Fallback: try to extract intervals from the chord extension data
                                const chordExt = this.chordExtensions.find(ext => 
                                    ext.name.toLowerCase().replace(/\s+/g, '') === chordType.toLowerCase()
                                );
                                if (chordExt && chordExt.intervals) {
                                    intervals = [...chordExt.intervals];
                                    chordName = chordExt.name;
                                }
                            }
                        }
                        
                        const basicChordData = {
                            name: chordName,
                            quality: this.currentQuality,
                            extensions: columnElement.dataset.extensions ? columnElement.dataset.extensions.split(',') : [],
                            intervals: intervals
                        };
                        
                        console.log('🎹 Trying to find piano lock for playback with data:', basicChordData);
                        const generatedKey = this.generatePianoLockKey(basicChordData);
                        console.log('🎹 Generated piano lock key for playback:', generatedKey);
                        console.log('🎹 Available piano lock keys:', Array.from(this.pianoLockedChords.keys()));
                        
                        pianoLockedData = this.findPianoLockData(basicChordData);
                        console.log('🎹 Found piano lock data:', pianoLockedData ? pianoLockedData.chordName : 'NONE');
                    }
                }
                
                if (pianoLockedData) {
                    console.log('🎹 Applying piano-locked settings for playback:', pianoLockedData.chordName);
                    
                    // Store current settings for immediate restoration
                    originalSettings = {
                        osc1: { ...this.oscillators.osc1 },
                        osc2: { ...this.oscillators.osc2 },
                        envelope: { ...this.envelope },
                        osc2Envelope: { ...this.osc2Envelope },
                        reverb: { ...this.reverb },
                        panning: { ...this.panning },
                        volume: this.volume,
                        masterVolume: this.masterVolume
                    };
                    
                    // Apply piano-locked settings temporarily (UI DOES NOT CHANGE)
                    this.applyPianoLockedSettings(pianoLockedData);
                }
                
                // If oscillator already exists, stop it first to prevent overlap
                if (this.activeOscillators.has(frequency)) {
                    this.stopFrequency(frequency, element);
                }
                
                if (!this.audioContext) return;
                
                // Create dual oscillators (or noise sources) with separate envelopes
                let osc1, osc2;
                const osc1Envelope = this.audioContext.createGain();
                const osc2Envelope = this.audioContext.createGain();
                const osc1Gain = this.audioContext.createGain();
                const osc2Gain = this.audioContext.createGain();
                const finalMixer = this.audioContext.createGain();
                
                // Create oscillator 1 (or noise)
                if (this.oscillators.osc1.type === 'noise') {
                    osc1 = this.createNoiseSource();
                } else {
                    osc1 = this.audioContext.createOscillator();
                    osc1.type = this.oscillators.osc1.type;
                    const totalDetune1 = this.oscillators.osc1.detune + (this.oscillators.osc1.coarse * (1200 / this.currentTuning));
                    const freq1 = frequency * Math.pow(2, this.oscillators.osc1.octave + (totalDetune1 / 1200));
                    osc1.frequency.setValueAtTime(freq1, this.audioContext.currentTime);
                }
                
                // Create oscillator 2 (or noise)
                if (this.oscillators.osc2.type === 'noise') {
                    osc2 = this.createNoiseSource();
                } else {
                    osc2 = this.audioContext.createOscillator();
                    osc2.type = this.oscillators.osc2.type;
                    const totalDetune2 = this.oscillators.osc2.detune + (this.oscillators.osc2.coarse * (1200 / this.currentTuning));
                    const freq2 = frequency * Math.pow(2, this.oscillators.osc2.octave + (totalDetune2 / 1200));
                    osc2.frequency.setValueAtTime(freq2, this.audioContext.currentTime);
                }
                
                // Set oscillator levels (include master volume in the calculation)
                const totalVolume = this.volume * this.masterVolume;
                osc1Gain.gain.value = this.oscillators.osc1.level * totalVolume;
                osc2Gain.gain.value = this.oscillators.osc2.level * totalVolume;
                
                // Connect oscillators through their individual envelopes
                osc1.connect(osc1Gain);
                osc1Gain.connect(osc1Envelope);
                
                osc2.connect(osc2Gain);
                osc2Gain.connect(osc2Envelope);
                
                // Simple addition - both oscillators mixed
                osc1Envelope.connect(finalMixer);
                osc2Envelope.connect(finalMixer);
                console.log('Both oscillators mixed');
                
                const currentTime = this.audioContext.currentTime;
                
                // Create panner and apply panning based on mode (BEFORE reverb)
                const panner = this.audioContext.createStereoPanner();
                let panValue = 0; // Default center
                
                switch (this.panning.mode) {
                    case 'frequency':
                        // Pan based on frequency (low = left, high = right)
                        const logFreq = Math.log2(frequency / 220); // A3 as reference
                        panValue = Math.max(-1, Math.min(1, logFreq * 0.3)) * this.panning.width;
                        break;
                    case 'random':
                        // Random panning
                        panValue = (Math.random() * 2 - 1) * this.panning.width;
                        break;
                    case 'rotating':
                        // Rotating panning
                        this.panning.rotationAngle += 0.1;
                        panValue = Math.sin(this.panning.rotationAngle) * this.panning.width;
                        break;
                    case 'alternating':
                        // Alternating left/right
                        this.panning.alternateState = !this.panning.alternateState;
                        panValue = (this.panning.alternateState ? 1 : -1) * this.panning.width;
                        break;
                    default:
                        // Center
                        panValue = 0;
                        break;
                }
                
                panner.pan.setValueAtTime(panValue, currentTime);
                
                // Connect: finalMixer ? panner ? gainNode (gainNode routes to reverb)
                finalMixer.connect(panner);
                panner.connect(this.gainNode);
                
                // OSC 1 ADSR envelope (master ADSR)
                const osc1AttackTime = currentTime + this.envelope.attack;
                const osc1DecayTime = osc1AttackTime + this.envelope.decay;
                
                osc1Envelope.gain.setValueAtTime(0, currentTime);
                osc1Envelope.gain.linearRampToValueAtTime(1, osc1AttackTime); // Attack
                osc1Envelope.gain.linearRampToValueAtTime(this.envelope.sustain, osc1DecayTime); // Decay to sustain
                
                // OSC 2 ADSR envelope (separate OSC 2 ADSR)
                const osc2AttackTime = currentTime + this.osc2Envelope.attack;
                const osc2DecayTime = osc2AttackTime + this.osc2Envelope.decay;
                
                osc2Envelope.gain.setValueAtTime(0, currentTime);
                osc2Envelope.gain.linearRampToValueAtTime(1, osc2AttackTime); // Attack
                osc2Envelope.gain.linearRampToValueAtTime(this.osc2Envelope.sustain, osc2DecayTime); // Decay to sustain
                
                osc1.start();
                osc2.start();
                
                // If we applied piano-locked settings, restore the original synthesizer state immediately
                if (originalSettings) {
                    console.log('🎹 Restoring original settings (no UI change)');
                    
                    // Restore from the stored original settings
                    Object.assign(this.oscillators.osc1, originalSettings.osc1);
                    Object.assign(this.oscillators.osc2, originalSettings.osc2);
                    Object.assign(this.envelope, originalSettings.envelope);
                    Object.assign(this.osc2Envelope, originalSettings.osc2Envelope);
                    Object.assign(this.reverb, originalSettings.reverb);
                    Object.assign(this.panning, originalSettings.panning);
                    this.volume = originalSettings.volume;
                    this.masterVolume = originalSettings.masterVolume;
                    
                    // Update audio context nodes if available
                    if (this.wetGainNode && this.dryGainNode) {
                        this.wetGainNode.gain.value = this.reverb.wet;
                        this.dryGainNode.gain.value = 1.0 - this.reverb.wet;
                    }
                    if (this.reverbFilterNode) {
                        this.reverbFilterNode.frequency.value = this.reverb.filterCutoff;
                    }
                    if (this.gainNode) {
                        this.gainNode.gain.value = this.volume * this.masterVolume;
                    }
                }
                
                // Auto-release timeout (use longer of the two attack+decay times)
                const maxEnvelopeTime = Math.max(
                    this.envelope.attack + this.envelope.decay,
                    this.osc2Envelope.attack + this.osc2Envelope.decay
                );
                const releaseTimeout = setTimeout(() => {
                    this.stopFrequency(frequency, element);
                }, (maxEnvelopeTime + 1) * 1000);
                
                // Store oscillator data
                this.activeOscillators.set(frequency, { 
                    osc1, 
                    osc2, 
                    osc1Envelope,
                    osc2Envelope,
                    finalMixer,
                    panner,
                    osc1Gain,
                    osc2Gain,
                    releaseTimeout,
                    startTime: currentTime
                });
                if (element) {
                    element.classList.add('active');
                    const core = element.querySelector('.string-core');
                    if (core) {
                        const stepIndex = parseInt(element.dataset.noteIndex||'0',10);
                        const period = this.computeVibrationPeriod(frequency, stepIndex);
                        core.style.setProperty('--vib-period', period + 'ms');
                        core.classList.add('vibrating');
                    }
                }
            }

            stopFrequency(frequency, element) {
                const osc = this.activeOscillators.get(frequency);
                if (!osc) return;
                
                const { osc1, osc2, osc1Envelope, osc2Envelope, releaseTimeout } = osc;
                
                // Clear auto-release timeout
                if (releaseTimeout) {
                    clearTimeout(releaseTimeout);
                }
                
                // Remove from active oscillators immediately to prevent overlap
                this.activeOscillators.delete(frequency);
                
                try {
                    const currentTime = this.audioContext.currentTime;
                    
                    // Apply OSC 1 release envelope
                    osc1Envelope.gain.cancelScheduledValues(currentTime);
                    osc1Envelope.gain.setValueAtTime(osc1Envelope.gain.value, currentTime);
                    osc1Envelope.gain.linearRampToValueAtTime(0, currentTime + this.envelope.release);
                    
                    // Apply OSC 2 release envelope
                    osc2Envelope.gain.cancelScheduledValues(currentTime);
                    osc2Envelope.gain.setValueAtTime(osc2Envelope.gain.value, currentTime);
                    osc2Envelope.gain.linearRampToValueAtTime(0, currentTime + this.osc2Envelope.release);
                    
                    // Stop oscillators after the longer of the two release times
                    const maxReleaseTime = Math.max(this.envelope.release, this.osc2Envelope.release);
                    osc1.stop(currentTime + maxReleaseTime);
                    osc2.stop(currentTime + maxReleaseTime);
                    
                    console.log('Note stopped with', maxReleaseTime, 'second release time');
                    
                    // Clean up visual indicator
                    setTimeout(() => {
                        if (element) {
                            element.classList.remove('active');
                            const core = element.querySelector('.string-core');
                            if (core) core.classList.remove('vibrating');
                        }
                    }, maxReleaseTime * 1000 + 50);
                } catch (error) {
                    console.warn('Error stopping oscillator:', error);
                    if (element) {
                        element.classList.remove('active');
                        const core = element.querySelector('.string-core');
                        if (core) core.classList.remove('vibrating');
                    }
                }
            }

            stopAllStrings() {
                // Stop all currently playing oscillators with proper release
                for (const [frequency, oscData] of this.activeOscillators) {
                    const { osc1, osc2, osc1Envelope, osc2Envelope, releaseTimeout } = oscData;
                    
                    if (releaseTimeout) {
                        clearTimeout(releaseTimeout);
                    }
                    
                    try {
                        const currentTime = this.audioContext.currentTime;
                        
                        // Apply OSC 1 release envelope
                        osc1Envelope.gain.cancelScheduledValues(currentTime);
                        osc1Envelope.gain.setValueAtTime(osc1Envelope.gain.value, currentTime);
                        osc1Envelope.gain.linearRampToValueAtTime(0, currentTime + this.envelope.release);
                        
                        // Apply OSC 2 release envelope
                        osc2Envelope.gain.cancelScheduledValues(currentTime);
                        osc2Envelope.gain.setValueAtTime(osc2Envelope.gain.value, currentTime);
                        osc2Envelope.gain.linearRampToValueAtTime(0, currentTime + this.osc2Envelope.release);
                        
                        // Stop oscillators after the longer of the two release times
                        const maxReleaseTime = Math.max(this.envelope.release, this.osc2Envelope.release);
                        osc1.stop(currentTime + maxReleaseTime);
                        osc2.stop(currentTime + maxReleaseTime);
                    } catch (error) {
                        console.warn('Error stopping oscillator:', error);
                    }
                }
                
                // Clear all tracking
                this.activeOscillators.clear();
                this.triggeredStrings.clear();
                
                // Remove visual indicators
                document.querySelectorAll('.string.active').forEach(el => {
                    el.classList.remove('active');
                });
            }

            // Tutorial System
            initTutorial() {
                this.tutorialStep = 0;
                this.tutorialSteps = [
                    {
                        title: "Welcome to Xenmicord!",
                        text: "This is a microtonal omnichord that lets you explore different tuning systems and create awesome harmonic textures. You start with a Major chord ready to play!",
                        highlight: null
                    },
                    {
                        title: "Initial Setup",
                        text: "You can freely change the tuning system and root note before creating new chords. Enter the number of notes per octave (2/1) or use other ratios for things like Bohlen Pierce.",
                        highlight: "#tuningSelector"
                    },
                    {
                        title: "Playing Chords",
                        text: "The Major chord is ready to play! Click and drag vertically on the column to strum the strings. Each column represents a different chord type.",
                        highlight: "#extensionColumns"
                    },
                    {
                        title: "Creating New Chords",
                        text: "Click 'New Chord' to enter chord creation mode. You'll build custom chords by selecting intervals on the top row of the screen.",
                        highlight: "[data-action='newChord']"
                    },
                    {
                        title: "Piano Lock System",
                        text: "Click the piano icon (🎹) on any chord header to 'piano lock' it - this saves the current synthesizer settings (oscillators + effects) specifically for that chord. Each chord gets its own unique sound preset!",
                        highlight: "#extensionColumns"
                    },
                    {
                        title: "Master Controls",
                        text: "Control the overall volume and mix of your sound here. The Master Volume affects everything, and you can adjust the overall stereo balance.",
                        highlight: "#masterSection"
                    },
                    {
                        title: "Effects Section",
                        text: "Add reverb and control stereo panning. Piano-locked chords preserve their individual effect settings while still responding to master controls.",
                        highlight: "#effectsSection"
                    },
                    {
                        title: "Oscillators",
                        text: "Each oscillator has waveform selection, volume, coarse tuning, and ADSR envelope controls. Piano-locked chords remember their oscillator settings. Use the dice button to randomize for inspiration!",
                        highlight: "#oscillatorsSection"
                    },
                    {
                        title: "Saving & Loading",
                        text: "Use 'Save .OMG' to save your complete session - all chords, piano locks, and synthesizer presets. Loading an OMG file restores everything and leaves you ready to create more chords!",
                        highlight: "#saveSessionBtn"
                    },
                    {
                        title: "Advanced Features",
                        text: "Each chord has edit, delete, and duplicate buttons for easy management. Your piano locks work across all root notes until manually unlocked with the padlock icon!",
                        highlight: "#extensionColumns"
                    }
                ];

                document.getElementById('tutorialButton').addEventListener('click', () => {
                    this.startTutorial();
                });

                document.getElementById('tutorialNext').addEventListener('click', () => {
                    this.nextTutorialStep();
                });

                document.getElementById('tutorialPrev').addEventListener('click', () => {
                    this.prevTutorialStep();
                });

                document.getElementById('tutorialSkip').addEventListener('click', () => {
                    this.endTutorial();
                });

                // Initialize escape mechanisms
                this.initTutorialEscapes();
            }

            startTutorial() {
                this.tutorialStep = 0;
                document.getElementById('tutorialOverlay').style.display = 'block';
                this.showTutorialStep();
                this.greyOutAll();
                
                // Add escape mechanisms
                document.addEventListener('keydown', this.tutorialEscapeHandler);
            }

            showTutorialStep() {
                const step = this.tutorialSteps[this.tutorialStep];
                document.getElementById('tutorialTitle').textContent = step.title;
                document.getElementById('tutorialText').textContent = step.text;

                // Update button states
                document.getElementById('tutorialPrev').style.display = this.tutorialStep > 0 ? 'inline-block' : 'none';
                document.getElementById('tutorialNext').textContent = this.tutorialStep < this.tutorialSteps.length - 1 ? 'Next' : 'Finish';

                // Position tutorial box
                this.positionTutorialBox(step.highlight);

                // Highlight current element
                this.highlightElement(step.highlight);
            }

            positionTutorialBox(selector) {
                const tutorialBox = document.getElementById('tutorialBox');
                
                if (selector) {
                    const element = document.querySelector(selector);
                    if (element) {
                        const rect = element.getBoundingClientRect();
                        const boxWidth = 400;
                        const boxHeight = 250;
                        
                        // Try to position next to the element
                        let left = rect.right + 20;
                        let top = rect.top;
                        
                        // Keep box on screen
                        if (left + boxWidth > window.innerWidth) {
                            left = rect.left - boxWidth - 20;
                        }
                        if (left < 20) {
                            left = 20;
                        }
                        
                        if (top + boxHeight > window.innerHeight) {
                            top = window.innerHeight - boxHeight - 20;
                        }
                        if (top < 20) {
                            top = 20;
                        }
                        
                        tutorialBox.style.left = `${left}px`;
                        tutorialBox.style.top = `${top}px`;
                        tutorialBox.style.transform = 'none';
                    } else {
                        // Center if element not found
                        tutorialBox.style.left = '50%';
                        tutorialBox.style.top = '50%';
                        tutorialBox.style.transform = 'translate(-50%, -50%)';
                    }
                } else {
                    // Center the box
                    tutorialBox.style.left = '50%';
                    tutorialBox.style.top = '50%';
                    tutorialBox.style.transform = 'translate(-50%, -50%)';
                }
            }

            highlightElement(selector) {
                // Remove previous highlights
                document.querySelectorAll('.tutorial-highlight').forEach(el => {
                    el.classList.remove('tutorial-highlight');
                    el.style.position = '';
                    el.style.zIndex = '';
                    el.style.filter = '';
                });

                if (selector) {
                    const element = document.querySelector(selector);
                    if (element) {
                        element.classList.add('tutorial-highlight');
                        element.style.position = 'relative';
                        element.style.zIndex = '2100';
                        element.style.filter = 'brightness(1.5) contrast(1.2)';
                    }
                }
            }

            greyOutAll() {
                // Create overlay instead of using filter to avoid breaking highlighting
                const overlay = document.createElement('div');
                overlay.id = 'tutorialGreyOverlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    z-index: 1900;
                    pointer-events: none;
                `;
                document.body.appendChild(overlay);
            }

            ungreyAll() {
                const overlay = document.getElementById('tutorialGreyOverlay');
                if (overlay) {
                    overlay.remove();
                }
                // Also remove any filters that might have been applied
                document.body.style.filter = '';
            }

            nextTutorialStep() {
                if (this.tutorialStep < this.tutorialSteps.length - 1) {
                    this.tutorialStep++;
                    this.showTutorialStep();
                } else {
                    this.endTutorial();
                }
            }

            prevTutorialStep() {
                if (this.tutorialStep > 0) {
                    this.tutorialStep--;
                    this.showTutorialStep();
                }
            }

            endTutorial() {
                document.getElementById('tutorialOverlay').style.display = 'none';
                this.ungreyAll();
                this.highlightElement(null);
                
                // Remove any event listeners that might interfere
                document.removeEventListener('keydown', this.tutorialEscapeHandler);
            }

            // Add escape key handler and click-to-close functionality
            initTutorialEscapes() {
                // ESC key to close tutorial
                this.tutorialEscapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.endTutorial();
                    }
                };

                // Click outside tutorial box to close
                document.getElementById('tutorialOverlay').addEventListener('click', (e) => {
                    if (e.target.id === 'tutorialOverlay') {
                        this.endTutorial();
                    }
                });
            }

            // Random Dice System
            initRandomDice() {
                document.getElementById('randomDiceButton').addEventListener('click', () => {
                    this.randomizeEverything();
                });
            }

            randomizeEverything() {
                // 🎹 PROTECTION: Store all piano-locked settings AND preloaded presets before randomization
                const protectedPianoLocks = new Map();
                const protectedPresets = new Map();
                
                if (this.pianoLockedChords && this.pianoLockedChords.size > 0) {
                    console.log('🎹 PROTECTING', this.pianoLockedChords.size, 'piano-locked chords from randomization');
                    console.log('🎹 Piano lock keys being protected:', Array.from(this.pianoLockedChords.keys()));
                    
                    // Create deep copies of all piano lock data
                    this.pianoLockedChords.forEach((lockData, key) => {
                        console.log(`🎹 Protecting piano lock: ${key} with preset: ${lockData.presetId}`);
                        protectedPianoLocks.set(key, {
                            ...lockData,
                            presetId: lockData.presetId, // Preserve preset ID
                            osc1: { ...lockData.osc1 },
                            osc2: { ...lockData.osc2 },
                            envelope: { ...lockData.envelope },
                            osc2Envelope: { ...lockData.osc2Envelope },
                            reverb: { ...lockData.reverb },
                            panning: { ...lockData.panning },
                            volume: { ...lockData.volume }
                        });
                    });
                    
                    // Also protect preloaded presets
                    this.preloadedPresets.forEach((presetData, presetId) => {
                        console.log(`🎹 Protecting preloaded preset: ${presetId}`);
                        protectedPresets.set(presetId, {
                            ...presetData,
                            osc1: { ...presetData.osc1 },
                            osc2: { ...presetData.osc2 },
                            envelope: { ...presetData.envelope },
                            osc2Envelope: { ...presetData.osc2Envelope },
                            reverb: { ...presetData.reverb },
                            panning: { ...presetData.panning },
                            volume: { ...presetData.volume }
                        });
                    });
                    
                    console.log('🎹 Protected', protectedPresets.size, 'preloaded presets');
                } else {
                    console.log('🎹 NO piano-locked chords found to protect');
                }
                
                // Animate the dice button
                const diceBtn = document.getElementById('randomDiceButton');
                diceBtn.style.transform = 'rotate(720deg)';
                setTimeout(() => {
                    diceBtn.style.transform = '';
                }, 600);

                // Focus purely on oscillator sound design - no tuning/chord changes
                this.randomizeOscillator(1);
                this.randomizeOscillator(2);

                // Randomize effects for sonic variety
                this.randomizeEffects();

                // 🎹 RESTORE: Put back all piano-locked settings and presets after randomization
                if (protectedPianoLocks.size > 0) {
                    console.log('🎹 RESTORING', protectedPianoLocks.size, 'piano-locked chords after randomization');
                    console.log('🎹 Piano lock keys being restored:', Array.from(protectedPianoLocks.keys()));
                    
                    // Detailed restoration logging
                    protectedPianoLocks.forEach((lockData, key) => {
                        console.log(`🎹 Restoring piano lock: ${key} with preset: ${lockData.presetId}`);
                    });
                    
                    this.pianoLockedChords = protectedPianoLocks;
                    
                    // Restore preloaded presets
                    this.preloadedPresets = protectedPresets;
                    console.log('🎹 Restored', protectedPresets.size, 'preloaded presets');
                    
                    // Log what's actually in the restored maps
                    console.log('🎹 Final pianoLockedChords keys:', Array.from(this.pianoLockedChords.keys()));
                    console.log('🎹 Final preloadedPresets keys:', Array.from(this.preloadedPresets.keys()));
                    
                    // Also restore the UI button states for piano locks
                    setTimeout(() => {
                        this.restorePianoLockStates();
                    }, 100);
                } else {
                    console.log('🎹 NO piano-locked chords to restore');
                }

                console.log('?? Randomized oscillator sounds while preserving piano locks!');
            }

            randomizeOscillator(oscNum) {
                const waveforms = ['sine', 'sawtooth', 'square', 'triangle'];
                const randomWave = waveforms[Math.floor(Math.random() * waveforms.length)];
                
                // Set waveform by updating the buttons
                const waveButtons = document.querySelectorAll(`[data-wave][data-osc="${oscNum}"]`);
                waveButtons.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.wave === randomWave) {
                        btn.classList.add('active');
                    }
                });
                this.oscillators[`osc${oscNum}`].type = randomWave;

                // Skip volume, coarse, fine, octave randomization to maintain tuning
                // Only randomize ADSR controls within their actual slider ranges
                
                // Use correct slider IDs - OSC1 has no prefix, OSC2 has "osc2" prefix
                const attackSliderID = oscNum === 1 ? 'attackSlider' : 'osc2AttackSlider';
                const decaySliderID = oscNum === 1 ? 'decaySlider' : 'osc2DecaySlider';
                const sustainSliderID = oscNum === 1 ? 'sustainSlider' : 'osc2SustainSlider';
                const releaseSliderID = oscNum === 1 ? 'releaseSlider' : 'osc2ReleaseSlider';
                
                const attackValueID = oscNum === 1 ? 'attackValue' : 'osc2AttackValue';
                const decayValueID = oscNum === 1 ? 'decayValue' : 'osc2DecayValue';
                const sustainValueID = oscNum === 1 ? 'sustainValue' : 'osc2SustainValue';
                const releaseValueID = oscNum === 1 ? 'releaseValue' : 'osc2ReleaseValue';

                const attackSlider = document.getElementById(attackSliderID);
                const decaySlider = document.getElementById(decaySliderID);
                const sustainSlider = document.getElementById(sustainSliderID);
                const releaseSlider = document.getElementById(releaseSliderID);
                
                // Get the actual slider min/max values for proper randomization
                let attackMin = 5; // default minimum
                let attackMax = 1000; // default for OSC1
                if (attackSlider) {
                    attackMin = Math.max(5, parseInt(attackSlider.min)); // Ensure minimum 5ms
                    attackMax = parseInt(attackSlider.max);
                }
                
                // Randomize ADSR parameters within proper ranges
                const attack = attackMin + Math.random() * (attackMax - attackMin); // Within slider range
                const decay = Math.random() * 1000; // 0-1000ms
                const sustain = Math.random() * 0.5; // 0-50%
                const release = Math.random() * 4000; // 0-4000ms

                if (attackSlider) {
                    attackSlider.value = attack;
                    const attackValue = document.getElementById(attackValueID);
                    if (attackValue) attackValue.textContent = `${Math.round(attack)}ms`;
                    // Update internal ADSR
                    if (oscNum === 1 && this.envelope) {
                        this.envelope.attack = attack / 1000;
                    } else if (oscNum === 2 && this.osc2Envelope) {
                        this.osc2Envelope.attack = attack / 1000;
                    }
                    console.log(`?? OSC${oscNum} Attack set to ${Math.round(attack)}ms`);
                }
                if (decaySlider) {
                    decaySlider.value = decay;
                    const decayValue = document.getElementById(decayValueID);
                    if (decayValue) decayValue.textContent = `${Math.round(decay)}ms`;
                    // Update internal ADSR
                    if (oscNum === 1 && this.envelope) {
                        this.envelope.decay = decay / 1000;
                    } else if (oscNum === 2 && this.osc2Envelope) {
                        this.osc2Envelope.decay = decay / 1000;
                    }
                    console.log(`?? OSC${oscNum} Decay set to ${Math.round(decay)}ms`);
                }
                if (sustainSlider) {
                    sustainSlider.value = sustain * 100;
                    const sustainValue = document.getElementById(sustainValueID);
                    if (sustainValue) sustainValue.textContent = `${Math.round(sustain * 100)}%`;
                    // Update internal ADSR
                    if (oscNum === 1 && this.envelope) {
                        this.envelope.sustain = sustain;
                    } else if (oscNum === 2 && this.osc2Envelope) {
                        this.osc2Envelope.sustain = sustain;
                    }
                    console.log(`?? OSC${oscNum} Sustain set to ${Math.round(sustain * 100)}%`);
                }
                if (releaseSlider) {
                    releaseSlider.value = release;
                    const releaseValue = document.getElementById(releaseValueID);
                    if (releaseValue) releaseValue.textContent = `${Math.round(release)}ms`;
                    // Update internal ADSR
                    if (oscNum === 1 && this.envelope) {
                        this.envelope.release = release / 1000;
                    } else if (oscNum === 2 && this.osc2Envelope) {
                        this.osc2Envelope.release = release / 1000;
                    }
                    console.log(`?? OSC${oscNum} Release set to ${Math.round(release)}ms`);
                }

                // Update ADSR values in the internal structure (backup)
                if (this.adsrSettings && this.adsrSettings[`osc${oscNum}`]) {
                    this.adsrSettings[`osc${oscNum}`].attack = attack / 1000;
                    this.adsrSettings[`osc${oscNum}`].decay = decay / 1000;
                    this.adsrSettings[`osc${oscNum}`].sustain = sustain;
                    this.adsrSettings[`osc${oscNum}`].release = release / 1000;
                }
                
                console.log(`?? Randomized OSC${oscNum}: ${randomWave} wave, A:${Math.round(attack)} D:${Math.round(decay)} S:${Math.round(sustain*100)}% R:${Math.round(release)}`);
            }

            randomizeEffects() {
                // Random reverb settings with wider ranges
                const reverbWet = Math.random() * 0.9; // 0-90% wet
                const reverbDecay = 0.3 + Math.random() * 5.7; // 0.3-6 seconds
                const reverbCut = 800 + Math.random() * 19200; // 800Hz-20kHz

                const reverbWetSlider = document.getElementById('reverbWet');
                const reverbDecaySlider = document.getElementById('reverbDecay');
                const reverbCutSlider = document.getElementById('reverbFilterCutoff');

                if (reverbWetSlider) {
                    reverbWetSlider.value = reverbWet * 100;
                    this.reverbWet = reverbWet;
                    const reverbWetValue = document.getElementById('reverbWetValue');
                    if (reverbWetValue) reverbWetValue.textContent = `${Math.round(reverbWet * 100)}%`;
                }
                if (reverbDecaySlider) {
                    reverbDecaySlider.value = reverbDecay;
                    if (this.reverb) this.reverb.decay = reverbDecay;
                    const reverbDecayValue = document.getElementById('reverbDecayValue');
                    if (reverbDecayValue) reverbDecayValue.textContent = `${reverbDecay.toFixed(1)}s`;
                }
                if (reverbCutSlider) {
                    reverbCutSlider.value = reverbCut;
                    if (this.reverbFilterNode) this.reverbFilterNode.frequency.value = reverbCut;
                    const reverbCutValue = document.getElementById('reverbFilterCutoffValue');
                    if (reverbCutValue) reverbCutValue.textContent = `${Math.round(reverbCut)}Hz`;
                }

                // Random panning mode and width
                const panModes = ['center', 'random', 'frequency', 'rotating', 'alternating', 'wide'];
                const panMode = panModes[Math.floor(Math.random() * panModes.length)];
                const panWidth = 0.2 + Math.random() * 0.8; // 20-100% width
                
                const panSelector = document.getElementById('panningMode');
                const panWidthSlider = document.getElementById('panningWidth');
                
                if (panSelector) {
                    panSelector.value = panMode;
                    this.panning.mode = panMode;
                }
                if (panWidthSlider) {
                    panWidthSlider.value = panWidth * 100;
                    this.panning.width = panWidth;
                    const panWidthValue = document.getElementById('panningWidthValue');
                    if (panWidthValue) panWidthValue.textContent = `${Math.round(panWidth * 100)}%`;
                }
                
                console.log(`??? Randomized effects: ${panMode} panning (${Math.round(panWidth * 100)}%), ${reverbDecay.toFixed(1)}s reverb`);
            }
        }

        // Initialize the instrument when the page loads
        let omnichord;
        window.addEventListener('load', () => {
            omnichord = new MicrotonalOmnichord();
            window.omnichord = omnichord; // Make it globally accessible

            // Also expose adjustKeyboardForLogo for resize events
            window.PianoApp = window.PianoApp || {};
            window.PianoApp.adjustKeyboardForLogo = () => {
                if (omnichord && typeof omnichord.adjustKeyboardForLogo === 'function') {
                    omnichord.adjustKeyboardForLogo();
                }
            };
            // Initial adjustment on load
            if (window.PianoApp.adjustKeyboardForLogo) window.PianoApp.adjustKeyboardForLogo();
            
            // Initialize new features
            omnichord.initTutorial();
            omnichord.initRandomDice();
            
            // Add event handler for chord name saving (ensure no root names are saved)
            const saveChordNameBtn = document.getElementById('saveChordName');
            if (saveChordNameBtn) {
                saveChordNameBtn.addEventListener('click', () => {
                    if (omnichord) {
                        omnichord.saveNewChord();
                    }
                });
            }
        });
        
        // Add exit prompt for saving to OMG file
        window.addEventListener('beforeunload', (e) => {
            if (omnichord && (omnichord.chordExtensions.length > 0 || omnichord.lockedChords?.size > 0)) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Would you like to save your session to an OMG file?';
                return e.returnValue;
            }
        });
             // Bottom bar panel toggling (uses existing migrated panel-content elements)
             (function(){
                 const bar=document.getElementById('bottomBar');
                 const host=document.getElementById('panelHost');
                 if(!bar||!host) return;
                 const panels=[...host.querySelectorAll('.panel-content')];
                 let open=null;
                 function show(id){
                     panels.forEach(p=>{p.style.display = (p.dataset.panel===id)?'grid':'none';});
                     host.style.display='block';
                 }
                 function close(){ host.style.display='none'; panels.forEach(p=>p.style.display='none'); open=null; bar.querySelectorAll('.panel-btn').forEach(b=>b.classList.remove('active')); }
                 // Expose programmatic closer on the main controller if available
                 if (window.omnichord) {
                     window.omnichord.closeBottomPanel = close;
                 } else {
                     // If not yet initialized, defer until DOMContentLoaded listeners create it
                     document.addEventListener('omnichord-ready', ()=>{ if (window.omnichord) window.omnichord.closeBottomPanel = close; }, { once:true });
                 }
                 bar.addEventListener('click',e=>{
                     const btn=e.target.closest('.panel-btn'); if(!btn) return;
                     const id=btn.dataset.panel;
                     if(open===id){ close(); return; }
                     open=id; show(id); bar.querySelectorAll('.panel-btn').forEach(b=>b.classList.toggle('active',b===btn));
                 });
                 window.addEventListener('keydown',e=>{ if(e.key==='Escape') close(); });
                 window.addEventListener('click',e=>{ if(open && !host.contains(e.target) && !bar.contains(e.target)) close(); });
             })();
    </script>
</body>
</html>


