<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Microtonal Omnichord</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        .instrument {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        .root-notes-area {
            height: 90px;
            background: rgba(0, 30, 60, 0.9);
            border-bottom: 2px solid #333;
            padding: 10px;
            display: flex;
            align-items: center;
        }

        .strum-area {
            height: 28vh;
            position: relative;
            background: linear-gradient(180deg, #0f3460, #16537e);
            overflow: hidden;
            display: flex;
            padding: 0;
            border: 2px solid #4a6870;
            gap: 0;
        }

        .strum-area:hover {
            border-color: #8fb3d3;
        }

        .chord-palette-area {
            height: 28vh;
            background: linear-gradient(135deg, #0f3460, #1a4d7a);
            border-top: 2px solid #4a6870;
            border-bottom: 2px solid #4a6870;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 0;
        }

        .palette-header {
            height: 40px;
            background: rgba(0, 30, 60, 0.9);
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            font-size: 14px;
            font-weight: bold;
            color: #8fb3d3;
        }

        .clear-palette-btn {
            background: #e94560;
            border: 1px solid #c73650;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.2s;
        }

        .clear-palette-btn:hover {
            background: #c73650;
            transform: scale(1.05);
        }

        .chord-palette {
            flex: 1;
            display: grid;
            align-items: stretch;
            padding: 0;
            gap: 0;
            overflow-x: hidden;
            overflow-y: hidden;
            min-height: 150px;
            width: 100%;
            height: 100%;
        }

        .empty-message {
            width: 100%;
            height: 80px;
            border: 2px dashed #4a6870;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #8fb3d3;
            font-style: italic;
            transition: all 0.3s;
        }

        .empty-hint {
            text-align: center;
            font-size: 12px;
        }

        .palette-column {
            min-height: 200px;
            max-height: 300px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .palette-chord-remove {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background: #e94560;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
            transition: all 0.2s;
        }

        .palette-chord-remove:hover {
            background: #c73650;
            transform: scale(1.1);
        }

        .palette-chord {
            flex: 1;
            max-width: 25%;
            min-width: 80px;
            background: linear-gradient(135deg, #2a4858, #3a5868);
            border: 2px solid #4a6870;
            border-radius: 8px;
            display: flex;
            flex-direction: row;
            align-items: stretch;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            padding: 0;
            overflow: hidden;
            gap: 2px;
            touch-action: none; /* Prevent default touch behaviors */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -webkit-touch-callout: none; /* Prevent iOS callout */
        }

        .palette-chord:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            border-color: #6aa0b0;
        }

        .palette-chord:active {
            transform: translateY(0px) scale(0.98);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .palette-chord.active {
            border-color: #e94560;
            box-shadow: 0 0 15px rgba(233, 69, 96, 0.5);
            background: linear-gradient(135deg, #4a2858, #5a3868);
        }

        /* Touch-specific feedback states for palette chords */
        .palette-chord.touch-pressed {
            transform: translateY(0px) scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #3a5868, #4a6878);
        }

        .palette-chord.touch-long-press {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 20px rgba(106, 160, 176, 0.6);
            border-color: #8ab0c0;
            background: linear-gradient(135deg, #4a6878, #5a7888);
        }

        .palette-chord-name {
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            height: 20px;
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }

        .palette-chord-root {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            height: 15px;
            font-size: 8px;
            color: #8fb3d3;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }

        .palette-chord-strings {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-evenly;
            padding: 25px 4px 20px 4px;
            position: relative;
        }

        .palette-string {
            height: 3px;
            background: linear-gradient(90deg, #34495e, #95a5a6, #34495e);
            border-radius: 1px;
            position: relative;
            cursor: pointer;
            transition: all 0.05s;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            margin: 1px 0;
            flex-shrink: 0;
            overflow: hidden;
        }

        .palette-string:hover {
            transform: scaleY(1.3);
            box-shadow: 0 0 8px rgba(149, 165, 166, 0.5);
        }

        .palette-string.active {
            background: linear-gradient(90deg, #e74c3c, #f39c12, #e74c3c);
            transform: scaleY(1.5);
            box-shadow: 0 0 12px rgba(231, 76, 60, 0.7);
        }

        .palette-string-wave {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.1s;
            background: repeating-linear-gradient(
                90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.3) 25%,
                transparent 50%,
                rgba(255, 255, 255, 0.3) 75%,
                transparent 100%
            );
            background-size: 15px 100%;
            animation: wave-flow 1s linear infinite;
        }

        .palette-string.active .palette-string-wave {
            opacity: 1;
        }

        .palette-chord-remove {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 16px;
            height: 16px;
            background: #e94560;
            border: 1px solid #c73650;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 8px;
            color: white;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .palette-chord:hover .palette-chord-remove {
            opacity: 1;
        }

        .root-notes-area {
            height: 12vh;
            background: rgba(0, 20, 40, 0.9);
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
        }

        .notes-area {
            height: 18vh;
            background: rgba(0, 20, 40, 0.8);
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 6px;
        }

        .control-panel {
            height: calc(100vh - 90px - 28vh - 28vh);
            min-height: 35vh;
            padding: 10px;
            background: rgba(0, 20, 40, 0.9);
            overflow: visible;
            display: grid;
            grid-template-columns: 300px 200px 280px 1fr;
            gap: 15px;
            align-content: start;
            min-width: 0;
            width: 100%;
        }

        .tuning-buttons {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            align-items: center;
        }

        .tuning-btn {
            padding: 6px 8px;
            background: #2a4858;
            border: 1px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 10px;
            white-space: nowrap;
            font-weight: bold;
        }

        .tuning-btn.active {
            background: #4a8fa0;
            border-color: #6aa0b0;
            box-shadow: 0 0 10px rgba(74, 143, 160, 0.5);
        }

        .chord-section {
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 20px;
            margin-bottom: 15px;
            color: #8fb3d3;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        .chord-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 8px;
            margin-bottom: 15px;
        }

        .chord-btn {
            aspect-ratio: 1;
            background: #2a4858;
            border: 2px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            touch-action: none; /* Prevent default touch behaviors */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -webkit-touch-callout: none; /* Prevent iOS callout */
        }

        .chord-btn:hover {
            background: #3a5868;
            transform: scale(1.05);
        }

        .chord-btn:active {
            background: #4a7888;
            transform: scale(0.98);
        }

        .chord-btn.active {
            background: #e74c3c;
            border-color: #c0392b;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.5);
        }

        /* Touch-specific feedback states */
        .chord-btn.touch-pressed {
            background: #4a7888;
            transform: scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .chord-btn.touch-long-press {
            background: #5a8898;
            transform: scale(1.02);
            box-shadow: 0 0 20px rgba(90, 136, 152, 0.6);
            border-color: #6a98a8;
        }

        .quality-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .quality-btn {
            flex: 1;
            padding: 10px;
            background: #2a4858;
            border: 2px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s;
        }

        .quality-btn.active {
            background: #f39c12;
            border-color: #e67e22;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }

        .extension-columns {
            flex: 1;
            display: flex;
            height: 100%;
            gap: 5px;
            padding: 0 10px;
            justify-content: space-between;
        }

        .quality-section {
            display: flex;
            flex-direction: row;
            flex: 1;
            gap: 2px;
            padding: 0 5px;
            border-radius: 8px;
            min-width: 0; /* Allow shrinking */
            max-width: 25%; /* Ensure 4 equal sections */
        }

        .favorites-section {
            display: flex;
            flex-direction: row;
            flex: 1;
            gap: 2px;
            padding: 0 5px;
            border-radius: 8px;
            min-width: 0;
            max-width: 25%;
            border-left: 4px solid #f39c12; /* Orange for favorites */
            background: rgba(243, 156, 18, 0.1);
        }

        .favorites-header {
            position: absolute;
            top: -25px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 10px;
            font-weight: bold;
            color: #f39c12;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .extension-column {
            position: relative;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 0;
            width: 100%;
            cursor: grab;
            transition: all 0.2s ease;
            height: 100%;
        }

        .extension-column:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .extension-column:active {
            cursor: grabbing;
        }

        /* Column Context Menu */
        .column-context-menu {
            position: absolute;
            background: #1a1a2e;
            border: 1px solid #4a6870;
            border-radius: 8px;
            padding: 8px 0;
            min-width: 180px;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: none;
        }

        .context-menu-item {
            padding: 8px 16px;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: #2a4858;
        }

        .context-menu-item.disabled {
            color: #666;
            cursor: not-allowed;
        }

        .context-menu-item.disabled:hover {
            background: transparent;
        }

        .context-menu-separator {
            height: 1px;
            background: #4a6870;
            margin: 4px 0;
        }

        .extension-column:last-child {
            border-right: none;
        }

        .extension-header {
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: bold;
            text-align: center;
            padding: 2px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .extension-header:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Touch feedback styles */
        .touch-pressed {
            background: rgba(233, 69, 96, 0.3) !important;
            transform: scale(0.98);
            transition: background 0.1s, transform 0.1s;
        }

        .touch-long-press {
            background: rgba(233, 69, 96, 0.5) !important;
            transform: scale(1.02);
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
            transition: background 0.2s, transform 0.2s, box-shadow 0.2s;
        }

        .strings-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-evenly;
            padding: 2px 1px;
        }

        .note-label {
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7px;
            color: #8fb3d3;
            text-align: center;
            padding: 1px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .string {
            height: 4px;
            background: linear-gradient(90deg, #34495e, #95a5a6, #34495e);
            border-radius: 2px;
            position: relative;
            cursor: pointer;
            transition: all 0.05s;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            margin: 1px 0;
            flex-shrink: 0;
            overflow: hidden;
        }

        .string:hover {
            transform: scaleY(1.2);
            box-shadow: 0 0 10px rgba(149, 165, 166, 0.5);
        }

        .string.active {
            background: linear-gradient(90deg, #e74c3c, #f39c12, #e74c3c);
            transform: scaleY(1.3);
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.7);
        }

        .string-wave {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.1s;
            background: repeating-linear-gradient(
                90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.3) 25%,
                transparent 50%,
                rgba(255, 255, 255, 0.3) 75%,
                transparent 100%
            );
            background-size: 20px 100%;
            animation: wave-flow 1s linear infinite;
        }

        .string.active .string-wave {
            opacity: 1;
        }

        @keyframes wave-flow {
            0% {
                background-position-x: 0;
            }
            100% {
                background-position-x: 20px;
            }
        }

        .note-labels {
            height: 30px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #8fb3d3;
            text-align: center;
            padding: 2px;
        }

        .frequency-display {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #bdc3c7;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .string:hover .frequency-display {
            opacity: 1;
        }

        .current-chord {
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 25px;
            border-radius: 12px;
            border: 2px solid #4a6870;
            z-index: 1000;
        }

        .current-chord h3 {
            color: #e74c3c;
            margin-bottom: 8px;
            font-size: 24px;
            text-align: center;
        }

        .current-chord div {
            font-size: 16px;
            text-align: center;
            color: #8fb3d3;
        }

        .root-notes-selector {
            display: flex;
            gap: 4px;
            align-items: center;
            justify-content: center;
            width: 100%;
            flex-wrap: wrap;
        }

        .root-notes-selector {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .root-notes-selector .section-title {
            font-size: 18px;
            color: #8fb3d3;
            margin-right: 20px;
            white-space: nowrap;
        }

        .root-chord-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(20px, 1fr));
            grid-template-rows: 1fr;
            gap: 1px;
            flex: 1;
            max-height: 50px;
            width: 100%;
        }

        .root-btn {
            flex: 1;
            min-width: 20px;
            height: 45px;
            background: linear-gradient(145deg, #2c5aa0, #1e3a8a);
            border: 1px solid #4a90e2;
            border-radius: 6px;
            color: white;
            font-weight: bold;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            touch-action: none; /* Prevent default touch behaviors */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -webkit-touch-callout: none; /* Prevent iOS callout */
        }

        .root-btn:hover {
            background: linear-gradient(145deg, #3d6bb5, #2949a0);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .root-btn:active {
            background: linear-gradient(145deg, #1e3a8a, #1a2f70);
            transform: translateY(0px) scale(0.95);
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        /* Touch-specific feedback states for root buttons */
        .root-btn.touch-pressed {
            background: linear-gradient(145deg, #1e3a8a, #1a2f70);
            transform: translateY(0px) scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .root-btn.touch-long-press {
            background: linear-gradient(145deg, #4d7bc5, #3959b0);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(74, 144, 226, 0.6);
            border-color: #6aa0e2;
        }

        .root-btn.active {
            background: linear-gradient(145deg, #f59e0b, #d97706);
            border-color: #fbbf24;
            color: #000;
            font-weight: bold;
        }

        .chord-types-selector {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .chord-types-selector .section-title {
            font-size: 12px;
            color: #8fb3d3;
            margin-right: 10px;
        }

        .quality-selector {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .quality-selector .section-title {
            font-size: 12px;
            color: #8fb3d3;
            margin-right: 10px;
        }

        .volume-control {
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #4a6870;
            display: flex;
            flex-direction: column;
            gap: 12px;
            font-size: 11px;
        }

        .synth-section {
            border: 1px solid rgba(74, 104, 112, 0.5);
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 8px;
            min-width: 0;
            overflow: hidden;
        }

        .synth-section h4 {
            color: #8fb3d3;
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        .envelope-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .envelope-group {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .envelope-group label {
            font-size: 12px;
            color: #8fb3d3;
            font-weight: bold;
        }

        .envelope-slider, .synth-slider {
            width: 100%;
            height: 25px;
            background: #1a1a2e;
            border-radius: 12px;
            outline: none;
            cursor: pointer;
        }

        .envelope-slider::-webkit-slider-thumb, .synth-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4a8fa0;
            cursor: pointer;
            border: 2px solid #6aa0b0;
        }

        .oscillator-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            margin-top: 6px;
        }

        .osc-btn {
            padding: 10px;
            background: #2a4858;
            border: 2px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 6px;
            font-size: 11px;
            transition: all 0.2s;
            text-align: center;
            font-weight: bold;
        }

        .osc-btn.active {
            background: #27ae60;
            border-color: #2ecc71;
            box-shadow: 0 0 8px rgba(39, 174, 96, 0.5);
        }

        .multi-osc-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 6px;
        }

        .osc-group {
            border: 1px solid rgba(74, 104, 112, 0.3);
            border-radius: 4px;
            padding: 6px;
        }

        .osc-group h5 {
            font-size: 8px;
            color: #8fb3d3;
            margin-bottom: 4px;
        }

        .osc-mix-controls {
            display: flex;
            gap: 4px;
            margin-top: 4px;
        }

        .mix-btn {
            flex: 1;
            padding: 3px;
            background: #2a4858;
            border: 1px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 3px;
            font-size: 7px;
            transition: all 0.2s;
        }

        .mix-btn.active {
            background: #f39c12;
            border-color: #e67e22;
        }

        .effects-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .effect-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .effect-group label {
            font-size: 8px;
            color: #8fb3d3;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .slider-value {
            font-size: 7px;
            color: #bdc3c7;
            text-align: center;
        }

        @media (max-width: 768px) {
            .control-panel {
                height: 60px;
                padding: 5px;
                gap: 8px;
            }
            
            .tuning-btn {
                padding: 4px 6px;
                font-size: 10px;
            }
            
            .chord-header {
                height: 30px;
                font-size: 8px;
            }
            
            .string {
                margin: 2px 0;
                height: 5px;
            }
            
            .note-labels {
                height: 25px;
                font-size: 7px;
            }
            
            .volume-control {
                min-width: 120px;
                max-width: 140px;
                padding: 6px;
            }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .control-panel {
                height: 50px;
                padding: 3px;
            }
            
            .chord-header {
                height: 25px;
                font-size: 7px;
            }
            
            .note-labels {
                height: 20px;
                font-size: 6px;
            }
            
            .string {
                margin: 1px 0;
                height: 4px;
            }
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: #2a2a2a;
            color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid #666;
        }

        .add-column-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .add-chord-btn {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .add-chord-btn:hover {
            background: linear-gradient(135deg, #357abd, #2868a3);
            transform: translateY(-2px);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="instrument">
        <!-- Root Notes at Top -->
        <div class="root-notes-area">
            <div class="root-notes-selector">
                <div class="section-title">OMG-nichord</div>
                <div class="root-chord-grid" id="rootGrid"></div>
            </div>
        </div>

        <!-- Fretboard/Strings -->
        <div class="strum-area">
            <div class="extension-columns" id="extensionColumns"></div>
        </div>

        <!-- Custom Chord Palette Area -->
        <div class="chord-palette-area" id="chordPaletteArea">
            <div class="palette-header">
                <span>Custom Chord Palette</span>
                <button class="clear-palette-btn" onclick="omnichord.clearPalette()" title="Clear all chords">🗑️ Clear</button>
            </div>
            <div class="chord-palette" id="chordPalette">
                <div class="empty-message" id="emptyMessage">
                    <div class="empty-hint">Use context menu "Add to Palette" to add chords here</div>
                </div>
            </div>
        </div>

        <!-- Bottom Controls - Full Height Available -->
        <div class="control-panel" style="display: grid; grid-template-columns: 300px 200px 280px 1fr; gap: 15px; padding: 10px; height: calc(100vh - 90px - 28vh - 28vh); min-height: 35vh; font-size: 13px; overflow: visible;">
            <!-- Tuning & Quality & Columns -->
            <div class="synth-section" style="padding: 8px;">
                <h4 style="font-size: 15px; margin-bottom: 8px;">Tuning</h4>
                <div class="tuning-buttons" style="grid-template-columns: repeat(5, 1fr); gap: 3px; margin-bottom: 10px;">
                    <div class="tuning-btn" data-tuning="5" style="font-size: 11px; padding: 4px;">5</div>
                    <div class="tuning-btn" data-tuning="7" style="font-size: 11px; padding: 4px;">7</div>
                    <div class="tuning-btn active" data-tuning="12" style="font-size: 11px; padding: 4px;">12</div>
                    <div class="tuning-btn" data-tuning="15" style="font-size: 11px; padding: 4px;">15</div>
                    <div class="tuning-btn" data-tuning="17" style="font-size: 11px; padding: 4px;">17</div>
                    <div class="tuning-btn" data-tuning="19" style="font-size: 11px; padding: 4px;">19</div>
                    <div class="tuning-btn" data-tuning="22" style="font-size: 11px; padding: 4px;">22</div>
                    <div class="tuning-btn" data-tuning="24" style="font-size: 11px; padding: 4px;">24</div>
                    <div class="tuning-btn" data-tuning="31" style="font-size: 11px; padding: 4px;">31</div>
                    <div class="tuning-btn" data-tuning="34" style="font-size: 11px; padding: 4px;">34</div>
                    <div class="tuning-btn" data-tuning="53" style="font-size: 11px; padding: 4px;">53</div>
                    <div class="tuning-btn" data-tuning="11" style="font-size: 11px; padding: 4px;">CG</div>
                    <div class="tuning-btn" data-tuning="gamelan" style="font-size: 11px; padding: 4px;">Gam</div>
                </div>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; align-items: center;">
                    <div class="quality-btn active" data-quality="major" style="font-size: 11px; padding: 5px;">Maj</div>
                    <div class="quality-btn" data-quality="minor" style="font-size: 11px; padding: 5px;">Min</div>
                    <div class="quality-btn" data-quality="neutral" style="font-size: 11px; padding: 5px;">Neu</div>
                </div>
            </div>

            <!-- Volume & ADSR -->
            <div class="synth-section" style="padding: 8px;">
                <h4 style="font-size: 15px; margin-bottom: 8px;">Vol/ADSR</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <div class="slider-container">
                        <label style="font-size: 11px;">Volume</label>
                        <input type="range" class="synth-slider" id="volumeSlider" min="0" max="10" value="10" style="height: 20px;">
                        <div class="slider-value" id="volumeValue" style="font-size: 10px;">100%</div>
                    </div>
                    <div class="slider-container">
                        <label style="font-size: 11px;">Master</label>
                        <input type="range" class="synth-slider" id="masterVolume" min="0" max="10" value="10" style="height: 20px;">
                        <div class="slider-value" id="masterVolumeValue" style="font-size: 10px;">100%</div>
                    </div>
                    <div class="slider-container">
                        <label style="font-size: 11px;">Attack</label>
                        <input type="range" class="envelope-slider" id="attackSlider" min="3" max="1000" value="5" style="height: 20px;">
                        <div class="slider-value" id="attackValue" style="font-size: 10px;">5ms</div>
                    </div>
                    <div class="slider-container">
                        <label style="font-size: 11px;">Decay</label>
                        <input type="range" class="envelope-slider" id="decaySlider" min="1" max="200" value="30" style="height: 20px;">
                        <div class="slider-value" id="decayValue" style="font-size: 10px;">30ms</div>
                    </div>
                    <div class="slider-container">
                        <label style="font-size: 11px;">Sustain</label>
                        <input type="range" class="envelope-slider" id="sustainSlider" min="0" max="10" value="5" style="height: 20px;">
                        <div class="slider-value" id="sustainValue" style="font-size: 10px;">50%</div>
                    </div>
                    <div class="slider-container">
                        <label style="font-size: 11px;">Release</label>
                        <input type="range" class="envelope-slider" id="releaseSlider" min="0" max="3000" value="1000" style="height: 20px;">
                        <div class="slider-value" id="releaseValue" style="font-size: 10px;">1000ms</div>
                    </div>
                </div>
            </div>

            <!-- Effects: Reverb & Panning -->
            <div class="synth-section" style="padding: 8px;">
                <h4 style="font-size: 15px; margin-bottom: 8px; color: #9b59b6;">Effects</h4>
                <div style="margin-bottom: 10px;">
                    <label style="font-size: 13px; color: #9b59b6;">Reverb</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                        <div class="slider-container">
                            <label style="font-size: 10px;">Wet</label>
                            <input type="range" class="synth-slider" id="reverbWet" min="0" max="10" value="1" style="height: 20px;">
                            <div class="slider-value" id="reverbWetValue" style="font-size: 9px;">10%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size: 10px;">Room</label>
                            <input type="range" class="synth-slider" id="reverbRoom" min="0" max="10" value="5" style="height: 20px;">
                            <div class="slider-value" id="reverbRoomValue" style="font-size: 9px;">50%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size: 10px;">Decay</label>
                            <input type="range" class="synth-slider" id="reverbDecay" min="0" max="100" value="20" style="height: 20px;">
                            <div class="slider-value" id="reverbDecayValue" style="font-size: 9px;">2.0s</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size: 10px;">Cut</label>
                            <input type="range" class="synth-slider" id="reverbFilterCutoff" min="200" max="20000" value="8000" style="height: 20px;">
                            <div class="slider-value" id="reverbFilterCutoffValue" style="font-size: 9px;">8kHz</div>
                        </div>
                    </div>
                </div>
                <div>
                    <label style="font-size: 13px; color: #e74c3c;">Panning</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                        <div class="slider-container">
                            <label style="font-size: 10px;">Mode</label>
                            <select id="panningMode" style="width: 100%; padding: 3px; background: #2a4858; color: #fff; border: 1px solid #4a6870; border-radius: 3px; font-size: 10px; height: 24px;">
                                <option value="center">Center</option>
                                <option value="frequency">Freq</option>
                                <option value="random">Random</option>
                                <option value="rotating">Rotate</option>
                                <option value="alternating">Alt</option>
                            </select>
                        </div>
                        <div class="slider-container">
                            <label style="font-size: 10px;">Width</label>
                            <input type="range" class="synth-slider" id="panningWidth" min="0" max="100" value="80" style="height: 20px;">
                            <div class="slider-value" id="panningWidthValue" style="font-size: 9px;">80%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size: 10px;">Speed</label>
                            <input type="range" class="synth-slider" id="panningSpeed" min="200" max="10000" value="2000" style="height: 20px;">
                            <div class="slider-value" id="panningSpeedValue" style="font-size: 9px;">2.0s</div>
                        </div>
                        <div style="display: flex; align-items: center; justify-content: center;">
                            <div class="mix-btn" id="panningReset" style="font-size: 9px; padding: 4px; cursor: pointer;">Reset</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Oscillators -->
            <div class="synth-section" style="padding: 8px;">
                <h4 style="font-size: 15px; margin-bottom: 8px;">Oscillators</h4>
                <div style="display: grid; grid-template-columns: 1fr 50px 1fr; gap: 8px; align-items: start;">
                    <!-- OSC 1 -->
                    <div>
                        <h5 style="font-size: 12px; margin-bottom: 4px; color: #8fb3d3;">OSC 1</h5>
                        <div class="oscillator-controls" style="grid-template-columns: repeat(5, 1fr); gap: 2px; margin-bottom: 6px;">
                            <div class="osc-btn active" data-wave="sine" data-osc="1" style="font-size: 9px; padding: 3px;">Sin</div>
                            <div class="osc-btn" data-wave="sawtooth" data-osc="1" style="font-size: 9px; padding: 3px;">Saw</div>
                            <div class="osc-btn" data-wave="square" data-osc="1" style="font-size: 9px; padding: 3px;">Sqr</div>
                            <div class="osc-btn" data-wave="triangle" data-osc="1" style="font-size: 9px; padding: 3px;">Tri</div>
                            <div class="osc-btn" data-wave="noise" data-osc="1" style="font-size: 9px; padding: 3px;">Nse</div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                            <div class="slider-container">
                                <label style="font-size: 9px;">Level</label>
                                <input type="range" class="synth-slider" id="osc1Level" min="0" max="10" value="5" style="height: 20px;">
                                <div class="slider-value" id="osc1LevelValue" style="font-size: 9px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size: 9px;">Detune</label>
                                <input type="range" class="synth-slider" id="osc1Detune" min="-50" max="50" value="0" style="height: 20px;">
                                <div class="slider-value" id="osc1DetuneValue" style="font-size: 9px;">0¢</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size: 9px;">Octave</label>
                                <input type="range" class="synth-slider" id="osc1Octave" min="-3" max="3" value="0" style="height: 20px;">
                                <div class="slider-value" id="osc1OctaveValue" style="font-size: 9px;">0</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size: 9px;">Coarse</label>
                                <input type="range" class="synth-slider" id="osc1Coarse" min="-1200" max="1200" value="0" style="height: 20px;">
                                <div class="slider-value" id="osc1CoarseValue" style="font-size: 9px;">0¢</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Mix -->
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 4px; border: 1px solid #f39c12; border-radius: 4px; background: rgba(243, 156, 18, 0.1);">
                        <h5 style="font-size: 9px; margin-bottom: 4px; color: #f39c12;">MIX</h5>
                        <div style="display: flex; flex-direction: column; gap: 2px; width: 100%;">
                            <div class="mix-btn active" data-mix="add" style="font-size: 9px; padding: 3px; text-align: center;">Add</div>
                            <div class="mix-btn" data-mix="ring" style="font-size: 9px; padding: 3px; text-align: center;">Ring</div>
                            <div class="mix-btn" data-mix="fm" style="font-size: 9px; padding: 3px; text-align: center;">FM</div>
                            <div class="mix-btn" data-mix="am" style="font-size: 9px; padding: 3px; text-align: center;">AM</div>
                        </div>
                    </div>
                    
                    <!-- OSC 2 -->
                    <div>
                        <h5 style="font-size: 12px; margin-bottom: 4px; color: #8fb3d3;">OSC 2</h5>
                        <div class="oscillator-controls" style="grid-template-columns: repeat(5, 1fr); gap: 2px; margin-bottom: 6px;">
                            <div class="osc-btn active" data-wave="sine" data-osc="2" style="font-size: 9px; padding: 3px;">Sin</div>
                            <div class="osc-btn" data-wave="sawtooth" data-osc="2" style="font-size: 9px; padding: 3px;">Saw</div>
                            <div class="osc-btn" data-wave="square" data-osc="2" style="font-size: 9px; padding: 3px;">Sqr</div>
                            <div class="osc-btn" data-wave="triangle" data-osc="2" style="font-size: 9px; padding: 3px;">Tri</div>
                            <div class="osc-btn" data-wave="noise" data-osc="2" style="font-size: 9px; padding: 3px;">Nse</div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                            <div class="slider-container">
                                <label style="font-size: 9px;">Level</label>
                                <input type="range" class="synth-slider" id="osc2Level" min="0" max="10" value="5" style="height: 20px;">
                                <div class="slider-value" id="osc2LevelValue" style="font-size: 9px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size: 9px;">Detune</label>
                                <input type="range" class="synth-slider" id="osc2Detune" min="-50" max="50" value="-7" style="height: 20px;">
                                <div class="slider-value" id="osc2DetuneValue" style="font-size: 9px;">-7¢</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size: 9px;">Octave</label>
                                <input type="range" class="synth-slider" id="osc2Octave" min="-3" max="3" value="0" style="height: 20px;">
                                <div class="slider-value" id="osc2OctaveValue" style="font-size: 9px;">0</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size: 9px;">Coarse</label>
                                <input type="range" class="synth-slider" id="osc2Coarse" min="-1200" max="1200" value="0" style="height: 20px;">
                                <div class="slider-value" id="osc2CoarseValue" style="font-size: 9px;">0¢</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- OSC 2 ADSR - Readable Size -->
                <h5 style="font-size: 12px; margin: 8px 0 4px 0; color: #8fb3d3;">OSC 2 ADSR</h5>
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px;">
                    <div class="slider-container">
                        <label style="font-size: 9px;">Attack</label>
                        <input type="range" class="envelope-slider" id="osc2AttackSlider" min="3" max="100" value="5" style="height: 20px;">
                        <div class="slider-value" id="osc2AttackValue" style="font-size: 9px;">5ms</div>
                    </div>
                    <div class="slider-container">
                        <label style="font-size: 9px;">Decay</label>
                        <input type="range" class="envelope-slider" id="osc2DecaySlider" min="1" max="200" value="30" style="height: 20px;">
                        <div class="slider-value" id="osc2DecayValue" style="font-size: 9px;">30ms</div>
                    </div>
                    <div class="slider-container">
                        <label style="font-size: 9px;">Sustain</label>
                        <input type="range" class="envelope-slider" id="osc2SustainSlider" min="0" max="10" value="5" style="height: 20px;">
                        <div class="slider-value" id="osc2SustainValue" style="font-size: 9px;">50%</div>
                    </div>
                    <div class="slider-container">
                        <label style="font-size: 9px;">Release</label>
                        <input type="range" class="envelope-slider" id="osc2ReleaseSlider" min="0" max="3000" value="1000" style="height: 20px;">
                        <div class="slider-value" id="osc2ReleaseValue" style="font-size: 9px;">1000ms</div>
                    </div>
                </div>
            </div>
        </div>

    <!-- Column Management Modal -->
    <div id="columnModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 20px; border-radius: 10px; max-width: 80%; max-height: 80%; overflow-y: auto;">
            <h3>Column Management</h3>
            <div id="columnList" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 20px 0;"></div>
            <div style="margin-top: 20px;">
                <button class="osc-btn" id="closeColumnModal">Close</button>
                <button class="osc-btn" id="addCustomColumn">Add Custom Column</button>
            </div>
        </div>
    </div>

    <!-- Custom Chord Modal -->
    <div id="customChordModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 20px; border-radius: 10px; max-width: 90%; max-height: 90%; overflow-y: auto;">
            <h3>Chord Builder & Favorites</h3>
            
            <!-- Favorites Section -->
            <div style="margin: 20px 0; padding: 15px; border: 1px solid #4a6870; border-radius: 8px; background: rgba(42, 72, 88, 0.3);">
                <h4 style="margin: 0 0 10px 0; color: #f39c12;">⭐ Favorite Chords</h4>
                <div id="favoriteChordsList" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 10px; min-height: 60px;">
                    <!-- Favorite chords will be populated here -->
                </div>
                <div style="font-size: 12px; color: #8fb3d3;">
                    Use context menu "Add to Favorites" to save chord patterns here
                </div>
            </div>
            
            <!-- Chord Creation Section -->
            <div style="margin: 20px 0;">
                <h4 style="margin: 0 0 10px 0; color: #4a90e2;">🎼 Create New Chord</h4>
                <label>Chord Name:</label>
                <input type="text" id="customChordName" style="width: 200px; padding: 5px; margin-left: 10px; background: #2a4858; color: #fff; border: 1px solid #4a6870; border-radius: 4px;">
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 10px;">Select Notes from Current EDO:</label>
                <div style="font-size: 12px; color: #8fb3d3; margin-bottom: 8px;">
                    <span style="color: #4a90e2;">■</span> Major/Minor tones &nbsp;
                    <span style="color: #27ae60;">■</span> Neutral tones &nbsp;
                    <span style="color: #f39c12;">■</span> Quarter-tones &nbsp;
                    <span style="color: #e74c3c;">■</span> Special intervals
                </div>
                <div id="edoNoteSelector" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(45px, 1fr)); gap: 4px; margin-top: 10px; max-height: 400px; overflow-y: auto; padding: 10px; border: 1px solid #4a6870; border-radius: 6px; background: rgba(0, 20, 40, 0.3);"></div>
            </div>
            <div style="margin-top: 20px;">
                <button class="osc-btn" id="closeCustomChordModal">Close</button>
                <button class="osc-btn" id="saveCustomChord">Save Chord</button>
                <button class="osc-btn" id="addToFavoritesBtn" style="background: #f39c12;">⭐ Add to Favorites</button>
            </div>
        </div>
    </div>

    <!-- Palette Chord Context Menu -->
    <div id="paletteChordContextMenu" class="column-context-menu">
        <div class="context-menu-item" data-action="play-chord">
            <span>▶️</span> Play Chord
        </div>
        <div class="context-menu-item" data-action="edit-chord-notes">
            <span>🎵</span> Edit Notes
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="copy-chord">
            <span>📋</span> Copy Chord
        </div>
        <div class="context-menu-item" data-action="move-chord-left">
            <span>⬅️</span> Move Left
        </div>
        <div class="context-menu-item" data-action="move-chord-right">
            <span>➡️</span> Move Right
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="remove-chord">
            <span>🗑️</span> Remove Chord
        </div>
    </div>

    <!-- Column Context Menu -->
    <div id="columnContextMenu" class="column-context-menu">
        <div class="context-menu-item" data-action="rename">
            <span>🏷️</span> Rename Column
        </div>
        <div class="context-menu-item" data-action="copy">
            <span>📋</span> Copy Column
        </div>
        <div class="context-menu-item" data-action="edit-pattern">
            <span>🎵</span> Edit Note Pattern
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="move-left">
            <span>⬅️</span> Move Left
        </div>
        <div class="context-menu-item" data-action="move-right">
            <span>➡️</span> Move Right
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="add-to-favorites">
            <span>⭐</span> Add to Favorites
        </div>
        <div class="context-menu-item" data-action="add-to-palette">
            <span>🎨</span> Add to Custom Palette
        </div>
        <div class="context-menu-item" data-action="hide">
            <span>👁️</span> Hide Column
        </div>
        <div class="context-menu-item" data-action="delete">
            <span>🗑️</span> Delete Column
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="create-custom-chord">
            <span>🎼</span> Create Custom Chord
        </div>
        <div class="context-menu-item" data-action="manage-columns">
            <span>🔧</span> Manage Columns
        </div>
        <div class="context-menu-item" data-action="add-column">
            <span>➕</span> Add New Column
        </div>
    </div>

    <!-- Edit Pattern Modal -->
    <div id="editPatternModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 20px; border-radius: 10px; max-width: 80%; max-height: 80%; overflow-y: auto;">
            <h3 id="editPatternTitle">Edit Note Pattern</h3>
            <div style="margin: 20px 0;">
                <label>Pattern Name:</label>
                <input type="text" id="editPatternName" style="width: 200px; padding: 5px; margin-left: 10px; background: #2a4858; color: #fff; border: 1px solid #4a6870; border-radius: 4px;">
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 10px;">Intervals from Root (semitones):</label>
                <div id="intervalEditor" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; margin-top: 10px;"></div>
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 10px;">Quick Patterns:</label>
                <div style="display: flex; gap: 5px; margin-top: 5px; flex-wrap: wrap;">
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7])">Major</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 3, 7])">Minor</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7, 10])">Dom7</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7, 11])">Maj7</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 3, 7, 10])">m7</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 2, 7])">Sus2</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 5, 7])">Sus4</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7, 9])">6th</button>
                </div>
            </div>
            <div style="margin-top: 20px;">
                <button class="osc-btn" id="closeEditPatternModal">Close</button>
                <button class="osc-btn" id="saveEditPattern">Save Pattern</button>
            </div>
        </div>
    </div>

    <script>
        class MicrotonalOmnichord {I 
            constructor() {
                this.audioContext = null;
                this.gainNode = null;
                this.activeOscillators = new Map();
                this.currentTuning = 12;
                this.currentRoot = 0;
                this.currentQuality = 'major';
                this.volume = 10 * 0.125 / 10; // Convert initial slider value 10 to dB scale (100%)
                this.masterVolume = 10 * 2.0 / 10; // Convert initial slider value 10 to dB scale (100%) - twice as loud as before
                this.isPlayingStrings = false;
                this.triggeredStrings = new Set();
                this.activeTouches = new Map();
                this.gamelanMode = false;
                
                // ADSR envelope settings
                this.envelope = {
                    attack: 0.01,
                    decay: 0.2,
                    sustain: 0.7,
                    release: 0.8
                };
                
                // OSC 2 ADSR envelope settings
                this.osc2Envelope = {
                    attack: 0.005,
                    decay: 0.03,
                    sustain: 0.5,
                    release: 1.0
                };
                
                this.oscillatorType = 'sawtooth';
                
                // Dual oscillator settings with proper dB scaling
                this.oscillators = {
                    osc1: { type: 'sine', detune: 0, level: 5 * 0.125 / 10, octave: 0, coarse: 0 }, // 50% slider = -18dB max
                    osc2: { type: 'sine', detune: -7, level: 5 * 0.125 / 10, octave: 0, coarse: 0 } // 50% slider = -18dB max
                };
                
                this.mixMode = 'add';
                
                // Panning settings
                this.panning = {
                    mode: 'center', // 'center', 'frequency', 'random', 'rotating', 'alternating'
                    width: 0.8, // How wide the stereo field is
                    speed: 2000, // Speed for rotating/alternating modes (ms)
                    rotationAngle: 0, // Current rotation angle
                    alternateState: false // Current side for alternating
                };
                
                // Simple reverb settings
                this.reverb = {
                    wet: 0.01, // 1% reverb by default
                    decay: 2.0, // 2 seconds decay
                    roomSize: 0.5,
                    filterCutoff: 8000
                };
                
                // Audio nodes
                this.reverbNode = null;
                this.wetGainNode = null;
                this.dryGainNode = null;
                this.reverbFilterNode = null;
                
                // Default chord set - minimal start, user can add more
                this.defaultChordExtensions = [
                    { name: 'Triad', extensions: [] },
                    { name: '7', extensions: ['7'] },
                    { name: '6', extensions: ['6'] },
                    { name: 'maj7', extensions: ['maj7'] }
                ];
                
                // Load user's chord configuration or use defaults
                this.chordExtensions = this.loadChordConfiguration() || [...this.defaultChordExtensions];
                
                // Available chord types for adding new columns
                this.availableChordTypes = [
                    { name: 'Triad', extensions: [] },
                    { name: '6', extensions: ['6'] },
                    { name: '7', extensions: ['7'] },
                    { name: 'maj7', extensions: ['maj7'] },
                    { name: '9', extensions: ['9'] },
                    { name: 'sus2', extensions: ['sus2'] },
                    { name: 'sus4', extensions: ['sus4'] },
                    { name: 'add9', extensions: ['add9'] },
                    { name: '11', extensions: ['11'] },
                    { name: '13', extensions: ['13'] },
                    { name: 'aug', extensions: ['aug'] },
                    { name: 'dim', extensions: ['dim'] },
                    { name: '13#11', extensions: ['13', '#11'] },
                    { name: '7#9', extensions: ['7', '#9'] },
                    { name: 'n7', extensions: ['n7'] }, // neutral 7th
                    { name: 'n11', extensions: ['n11'] }, // neutral 11th
                    { name: 'm6', extensions: ['m6'] },
                    { name: 'm7', extensions: ['m7'] },
                    { name: 'm9', extensions: ['m9'] },
                    { name: 'madd9', extensions: ['madd9'] },
                    { name: '7b5', extensions: ['7', 'b5'] },
                    { name: '7#5', extensions: ['7', '#5'] }
                ];
                
                // Initialize palette chords array
                this.paletteChords = JSON.parse(localStorage.getItem('microtonalPaletteChords')) || [];
                
                this.initAudio();
                this.initEventListeners();
                this.generateRootButtons();
                this.generateExtensionColumns();
                this.updateChordDisplay();
                this.setupChordPalette();
            }

            getTuningDisplayName() {
                if (this.gamelanMode) return 'Gamelan';
                switch(this.currentTuning) {
                    case 5: return '5-EDO';
                    case 7: return '7-EDO';
                    case 11: return 'C.Gamma';
                    case 12: return '12-TET';
                    case 15: return '15-EDO';
                    case 17: return '17-EDO';
                    case 19: return '19-TET';
                    case 22: return '22-TET';
                    case 24: return '24-TET';
                    case 31: return '31-TET';
                    case 34: return '34-TET';
                    case 53: return '53-TET';
                    default: return `${this.currentTuning}-TET`;
                }
            }

            async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.value = this.volume;
                    
                    // Create simple reverb
                    this.createReverb();
                    
                    // Create wet/dry gain nodes for reverb
                    this.wetGainNode = this.audioContext.createGain();
                    this.dryGainNode = this.audioContext.createGain();
                    this.wetGainNode.gain.value = this.reverb.wet;
                    this.dryGainNode.gain.value = 1.0 - this.reverb.wet;
                    
                    // Create reverb filter
                    this.reverbFilterNode = this.audioContext.createBiquadFilter();
                    this.reverbFilterNode.type = 'lowpass';
                    this.reverbFilterNode.frequency.value = this.reverb.filterCutoff;
                    this.reverbFilterNode.Q.value = 1;
                    
                    // Connect audio routing: gainNode → dry/wet → reverb → destination
                    this.gainNode.connect(this.dryGainNode);
                    this.gainNode.connect(this.wetGainNode);
                    this.dryGainNode.connect(this.audioContext.destination);
                    this.wetGainNode.connect(this.reverbNode);
                    this.reverbNode.connect(this.reverbFilterNode);
                    this.reverbFilterNode.connect(this.audioContext.destination);
                } catch (error) {
                    console.error('Audio initialization failed:', error);
                }
            }

            createReverb() {
                const convolver = this.audioContext.createConvolver();
                const length = this.audioContext.sampleRate * this.reverb.decay;
                const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const n = length - i;
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(n / length, this.reverb.roomSize);
                    }
                }
                
                convolver.buffer = impulse;
                this.reverbNode = convolver;
            }

            createNoiseSource() {
                const bufferSize = this.audioContext.sampleRate * 1; // 1 second of noise
                const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1; // White noise
                }
                
                const whiteNoise = this.audioContext.createBufferSource();
                whiteNoise.buffer = noiseBuffer;
                whiteNoise.loop = true;
                
                return whiteNoise;
            }

            initEventListeners() {
                // Tuning system selection
                document.querySelectorAll('[data-tuning]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-tuning]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        const tuningValue = btn.dataset.tuning;
                        if (tuningValue === 'gamelan') {
                            // Gamelan pelog scale (7 notes)
                            this.currentTuning = 7;
                            this.gamelanMode = true;
                        } else {
                            this.currentTuning = parseInt(tuningValue);
                            this.gamelanMode = false;
                        }
                        
                        this.generateRootButtons();
                        this.generateExtensionColumns();
                        this.updateChordDisplay();
                    });
                });

                // Quality selection
                document.querySelectorAll('[data-quality]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-quality]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentQuality = btn.dataset.quality;
                        this.generateExtensionColumns();
                        this.updateChordDisplay();
                    });
                });

                // Volume control with value display and dB conversion
                const volumeSlider = document.getElementById('volumeSlider');
                if (volumeSlider) {
                    volumeSlider.addEventListener('input', (e) => {
                        // Convert 0-10 scale to -18dB to 0dB (linear from 0.125 to 1.0)
                        const sliderValue = e.target.value / 10; // 0-1
                        this.volume = sliderValue * 0.356; // Max at -9dB (0.356 linear gain)
                        if (this.gainNode) {
                            this.gainNode.gain.value = this.volume * this.masterVolume;
                        }
                        const volumeValue = document.getElementById('volumeValue');
                        if (volumeValue) {
                            volumeValue.textContent = `${e.target.value * 10}%`;
                        }
                    });
                } else {
                    console.error('volumeSlider not found');
                }

                // ADSR controls with value displays and proper limits
                const attackSlider = document.getElementById('attackSlider');
                if (attackSlider) {
                    attackSlider.addEventListener('input', (e) => {
                        this.envelope.attack = Math.max(0.003, e.target.value / 1000); // 3ms minimum
                        const attackValue = document.getElementById('attackValue');
                        if (attackValue) {
                            attackValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('attackSlider not found');
                }
                
                const decaySlider = document.getElementById('decaySlider');
                if (decaySlider) {
                    decaySlider.addEventListener('input', (e) => {
                        this.envelope.decay = Math.max(0.001, e.target.value / 1000); // 1ms minimum, 200ms max
                        const decayValue = document.getElementById('decayValue');
                        if (decayValue) {
                            decayValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('decaySlider not found');
                }
                
                const sustainSlider = document.getElementById('sustainSlider');
                if (sustainSlider) {
                    sustainSlider.addEventListener('input', (e) => {
                        this.envelope.sustain = e.target.value / 10; // 0-10 scale to 0-1
                        const sustainValue = document.getElementById('sustainValue');
                        if (sustainValue) {
                            sustainValue.textContent = `${e.target.value * 10}%`;
                        }
                    });
                } else {
                    console.error('sustainSlider not found');
                }
                
                const releaseSlider = document.getElementById('releaseSlider');
                if (releaseSlider) {
                    releaseSlider.addEventListener('input', (e) => {
                        this.envelope.release = e.target.value / 1000; // 0-3000ms
                        const releaseValue = document.getElementById('releaseValue');
                        if (releaseValue) {
                            releaseValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('releaseSlider not found');
                }

                // Master Volume control with dB conversion
                const masterVolumeSlider = document.getElementById('masterVolume');
                if (masterVolumeSlider) {
                    masterVolumeSlider.addEventListener('input', (e) => {
                        // Convert 0-10 scale to 0dB to +6dB (linear from 0 to 2.0) - twice as loud as before
                        const sliderValue = e.target.value / 10; // 0-1
                        this.masterVolume = sliderValue * 2.0; // Max at +6dB (2.0 linear gain)
                        if (this.gainNode) {
                            this.gainNode.gain.value = this.volume * this.masterVolume;
                        }
                        const masterVolumeValue = document.getElementById('masterVolumeValue');
                        if (masterVolumeValue) {
                            masterVolumeValue.textContent = `${e.target.value * 10}%`;
                        }
                    });
                } else {
                    console.error('masterVolumeSlider not found');
                }

                // OSC 2 ADSR controls
                const osc2AttackSlider = document.getElementById('osc2AttackSlider');
                if (osc2AttackSlider) {
                    osc2AttackSlider.addEventListener('input', (e) => {
                        this.osc2Envelope.attack = Math.max(0.003, e.target.value / 1000); // 3ms minimum
                        const osc2AttackValue = document.getElementById('osc2AttackValue');
                        if (osc2AttackValue) {
                            osc2AttackValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('osc2AttackSlider not found');
                }
                
                const osc2DecaySlider = document.getElementById('osc2DecaySlider');
                if (osc2DecaySlider) {
                    osc2DecaySlider.addEventListener('input', (e) => {
                        this.osc2Envelope.decay = Math.max(0.001, e.target.value / 1000); // 1ms minimum, 200ms max
                        const osc2DecayValue = document.getElementById('osc2DecayValue');
                        if (osc2DecayValue) {
                            osc2DecayValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('osc2DecaySlider not found');
                }
                
                const osc2SustainSlider = document.getElementById('osc2SustainSlider');
                if (osc2SustainSlider) {
                    osc2SustainSlider.addEventListener('input', (e) => {
                        this.osc2Envelope.sustain = e.target.value / 10; // 0-10 scale to 0-1
                        const osc2SustainValue = document.getElementById('osc2SustainValue');
                        if (osc2SustainValue) {
                            osc2SustainValue.textContent = `${e.target.value * 10}%`;
                        }
                    });
                } else {
                    console.error('osc2SustainSlider not found');
                }
                
                const osc2ReleaseSlider = document.getElementById('osc2ReleaseSlider');
                if (osc2ReleaseSlider) {
                    osc2ReleaseSlider.addEventListener('input', (e) => {
                        this.osc2Envelope.release = e.target.value / 1000; // 0-3000ms
                        const osc2ReleaseValue = document.getElementById('osc2ReleaseValue');
                        if (osc2ReleaseValue) {
                            osc2ReleaseValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('osc2ReleaseSlider not found');
                }

                // Oscillator controls
                document.querySelectorAll('.osc-btn[data-wave]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const osc = btn.dataset.osc;
                        const wave = btn.dataset.wave;
                        
                        // Update active state
                        document.querySelectorAll(`[data-osc="${osc}"]`).forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        this.oscillators[`osc${osc}`].type = wave;
                    });
                });

                // Oscillator detune and level controls
                ['1', '2'].forEach(num => {
                    const detuneSlider = document.getElementById(`osc${num}Detune`);
                    if (detuneSlider) {
                        detuneSlider.addEventListener('input', (e) => {
                            this.oscillators[`osc${num}`].detune = parseInt(e.target.value);
                            const detuneValue = document.getElementById(`osc${num}DetuneValue`);
                            if (detuneValue) {
                                detuneValue.textContent = `${e.target.value}¢`;
                            }
                        });
                    } else {
                        console.error(`osc${num}Detune not found`);
                    }
                    
                    const levelSlider = document.getElementById(`osc${num}Level`);
                    if (levelSlider) {
                        levelSlider.addEventListener('input', (e) => {
                            // Convert 0-10 scale to -18dB to 0dB (linear from 0.125 to 1.0)
                            const sliderValue = e.target.value / 10; // 0-1
                            this.oscillators[`osc${num}`].level = sliderValue * 0.125; // Max at -18dB
                            const levelValue = document.getElementById(`osc${num}LevelValue`);
                            if (levelValue) {
                                levelValue.textContent = `${e.target.value * 10}%`;
                            }
                        });
                    } else {
                        console.error(`osc${num}Level not found`);
                    }
                });

                // Oscillator octave and coarse controls
                ['1', '2'].forEach(num => {
                    const octaveSlider = document.getElementById(`osc${num}Octave`);
                    if (octaveSlider) {
                        octaveSlider.addEventListener('input', (e) => {
                            this.oscillators[`osc${num}`].octave = parseInt(e.target.value);
                            const octaveValue = document.getElementById(`osc${num}OctaveValue`);
                            if (octaveValue) {
                                octaveValue.textContent = e.target.value;
                            }
                        });
                    } else {
                        console.error(`osc${num}Octave not found`);
                    }
                    
                    const coarseSlider = document.getElementById(`osc${num}Coarse`);
                    if (coarseSlider) {
                        coarseSlider.addEventListener('input', (e) => {
                            this.oscillators[`osc${num}`].coarse = parseInt(e.target.value);
                            const coarseValue = document.getElementById(`osc${num}CoarseValue`);
                            if (coarseValue) {
                                coarseValue.textContent = `${e.target.value}¢`;
                            }
                        });
                    } else {
                        console.error(`osc${num}Coarse not found`);
                    }
                });

                // Mix mode controls
                document.querySelectorAll('.mix-btn[data-mix]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.mix-btn[data-mix]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.mixMode = btn.dataset.mix;
                    });
                });

                // Reverb controls
                const reverbWetSlider = document.getElementById('reverbWet');
                if (reverbWetSlider) {
                    reverbWetSlider.addEventListener('input', (e) => {
                        this.reverb.wet = e.target.value / 10; // 0-10 scale to 0-1
                        if (this.wetGainNode && this.dryGainNode) {
                            this.wetGainNode.gain.value = this.reverb.wet;
                            this.dryGainNode.gain.value = 1.0 - this.reverb.wet;
                        }
                        const reverbWetValue = document.getElementById('reverbWetValue');
                        if (reverbWetValue) {
                            reverbWetValue.textContent = `${e.target.value * 10}%`;
                        }
                    });
                } else {
                    console.error('reverbWet slider not found');
                }

                const reverbRoomSlider = document.getElementById('reverbRoom');
                if (reverbRoomSlider) {
                    reverbRoomSlider.addEventListener('input', (e) => {
                        this.reverb.roomSize = e.target.value / 10; // 0-10 scale to 0-1
                        const reverbRoomValue = document.getElementById('reverbRoomValue');
                        if (reverbRoomValue) {
                            reverbRoomValue.textContent = `${e.target.value * 10}%`;
                        }
                        // Recreate reverb with new room size
                        if (this.audioContext) {
                            this.createReverb();
                            // Properly reconnect the reverb chain
                            this.wetGainNode.disconnect();
                            this.reverbFilterNode.disconnect();
                            this.wetGainNode.connect(this.reverbNode);
                            this.reverbNode.connect(this.reverbFilterNode);
                            this.reverbFilterNode.connect(this.audioContext.destination);
                        }
                    });
                } else {
                    console.error('reverbRoom slider not found');
                }
                
                const reverbDecaySlider = document.getElementById('reverbDecay');
                if (reverbDecaySlider) {
                    reverbDecaySlider.addEventListener('input', (e) => {
                        this.reverb.decay = (e.target.value / 100) * 10; // 0-10 seconds
                        const reverbDecayValue = document.getElementById('reverbDecayValue');
                        if (reverbDecayValue) {
                            reverbDecayValue.textContent = `${(this.reverb.decay).toFixed(1)}s`;
                        }
                        // Recreate reverb with new decay time
                        if (this.audioContext) {
                            this.createReverb();
                            // Properly reconnect the reverb chain
                            this.wetGainNode.disconnect();
                            this.reverbFilterNode.disconnect();
                            this.wetGainNode.connect(this.reverbNode);
                            this.reverbNode.connect(this.reverbFilterNode);
                            this.reverbFilterNode.connect(this.audioContext.destination);
                        }
                    });
                } else {
                    console.error('reverbDecay slider not found');
                }
                
                const reverbFilterCutoffSlider = document.getElementById('reverbFilterCutoff');
                if (reverbFilterCutoffSlider) {
                    reverbFilterCutoffSlider.addEventListener('input', (e) => {
                        this.reverb.filterCutoff = parseInt(e.target.value);
                        if (this.reverbFilterNode) {
                            this.reverbFilterNode.frequency.value = this.reverb.filterCutoff;
                        }
                        const reverbFilterCutoffValue = document.getElementById('reverbFilterCutoffValue');
                        if (reverbFilterCutoffValue) {
                            reverbFilterCutoffValue.textContent = `${e.target.value}Hz`;
                        }
                    });
                } else {
                    console.error('reverbFilterCutoff slider not found');
                }

                const reverbFilterResSlider = document.getElementById('reverbFilterRes');
                if (reverbFilterResSlider) {
                    reverbFilterResSlider.addEventListener('input', (e) => {
                        if (this.reverbFilterNode) {
                            this.reverbFilterNode.Q.value = parseFloat(e.target.value);
                        }
                        const reverbFilterResValue = document.getElementById('reverbFilterResValue');
                        if (reverbFilterResValue) {
                            reverbFilterResValue.textContent = e.target.value;
                        }
                    });
                } else {
                    console.error('reverbFilterRes slider not found');
                }

                // Panning controls
                const panningModeSelect = document.getElementById('panningMode');
                if (panningModeSelect) {
                    panningModeSelect.addEventListener('change', (e) => {
                        this.panning.mode = e.target.value;
                        console.log('Panning mode changed to:', this.panning.mode);
                    });
                } else {
                    console.error('panningMode select not found');
                }

                const panningWidthSlider = document.getElementById('panningWidth');
                if (panningWidthSlider) {
                    panningWidthSlider.addEventListener('input', (e) => {
                        this.panning.width = e.target.value / 100; // 0-100% to 0-1
                        const panningWidthValue = document.getElementById('panningWidthValue');
                        if (panningWidthValue) {
                            panningWidthValue.textContent = `${e.target.value}%`;
                        }
                    });
                } else {
                    console.error('panningWidth slider not found');
                }

                const panningSpeedSlider = document.getElementById('panningSpeed');
                if (panningSpeedSlider) {
                    panningSpeedSlider.addEventListener('input', (e) => {
                        this.panning.speed = parseInt(e.target.value);
                        const panningSpeedValue = document.getElementById('panningSpeedValue');
                        if (panningSpeedValue) {
                            panningSpeedValue.textContent = `${(e.target.value / 1000).toFixed(1)}s`;
                        }
                    });
                } else {
                    console.error('panningSpeed slider not found');
                }

                const panningResetBtn = document.getElementById('panningReset');
                if (panningResetBtn) {
                    panningResetBtn.addEventListener('click', () => {
                        this.panning.rotationAngle = 0;
                        this.panning.alternateState = false;
                        console.log('Panning reset');
                    });
                } else {
                    console.error('panningReset button not found');
                }

                // Enhanced string playing with ultra responsiveness (60 FPS optimized)
                const extensionColumns = document.getElementById('extensionColumns');
                
                // Mouse events for strings with optimized performance
                extensionColumns.addEventListener('mousedown', (e) => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    this.isPlayingStrings = true;
                    this.triggeredStrings.clear();
                    this.handleStringTrigger(e);
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isPlayingStrings) {
                        this.handleStringTrigger(e);
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    this.isPlayingStrings = false;
                    this.triggeredStrings.clear();
                    this.stopAllActiveNotes();
                });

                // Touch events for strings
                extensionColumns.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    this.isPlayingStrings = true;
                    this.triggeredStrings.clear();
                    
                    Array.from(e.changedTouches).forEach(touch => {
                        this.activeTouches.set(touch.identifier, touch);
                        this.handleStringTrigger(touch);
                    });
                });
                
                extensionColumns.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.isPlayingStrings) {
                        Array.from(e.changedTouches).forEach(touch => {
                            this.activeTouches.set(touch.identifier, touch);
                            this.handleStringTrigger(touch);
                        });
                    }
                });
                
                extensionColumns.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    Array.from(e.changedTouches).forEach(touch => {
                        this.activeTouches.delete(touch.identifier);
                    });
                    
                    if (this.activeTouches.size === 0) {
                        this.isPlayingStrings = false;
                        this.triggeredStrings.clear();
                        this.stopAllActiveNotes();
                    }
                });
                
                extensionColumns.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    Array.from(e.changedTouches).forEach(touch => {
                        this.activeTouches.delete(touch.identifier);
                    });
                    
                    if (this.activeTouches.size === 0) {
                        this.isPlayingStrings = false;
                        this.triggeredStrings.clear();
                        this.stopAllActiveNotes();
                    }
                });

                // Allow multitouch on control elements - prevent default only on strings
                document.addEventListener('touchstart', (e) => {
                    const target = e.target;
                    if (target.classList.contains('tuning-btn') || 
                        target.classList.contains('chord-btn') || 
                        target.classList.contains('quality-btn') || 
                        target.classList.contains('osc-btn')) {
                        // Don't prevent default on control buttons to allow multitouch
                        return;
                    }
                }, { passive: false });

                // Handle audio context resume on any interaction
                document.addEventListener('click', () => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        console.log('Attempting to resume AudioContext on click...');
                        this.audioContext.resume().then(() => {
                            console.log('AudioContext resumed successfully');
                        });
                    }
                });
                
                document.addEventListener('touchstart', () => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        console.log('Attempting to resume AudioContext on touch...');
                        this.audioContext.resume().then(() => {
                            console.log('AudioContext resumed successfully');
                        });
                    }
                });
                
                document.addEventListener('mousedown', () => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        console.log('Attempting to resume AudioContext on mousedown...');
                        this.audioContext.resume().then(() => {
                            console.log('AudioContext resumed successfully');
                        });
                    }
                });

                // Modal Event Listeners
                const closeColumnModalBtn = document.getElementById('closeColumnModal');
                const closeCustomChordModalBtn = document.getElementById('closeCustomChordModal');
                const addCustomColumnBtn = document.getElementById('addCustomColumn');
                const saveCustomChordBtn = document.getElementById('saveCustomChord');

                if (closeColumnModalBtn) {
                    closeColumnModalBtn.addEventListener('click', () => {
                        document.getElementById('columnModal').style.display = 'none';
                    });
                }

                if (closeCustomChordModalBtn) {
                    closeCustomChordModalBtn.addEventListener('click', () => {
                        document.getElementById('customChordModal').style.display = 'none';
                    });
                }

                if (addCustomColumnBtn) {
                    addCustomColumnBtn.addEventListener('click', () => {
                        document.getElementById('columnModal').style.display = 'none';
                        this.showCustomChordModal();
                    });
                }

                if (saveCustomChordBtn) {
                    saveCustomChordBtn.addEventListener('click', () => {
                        this.saveCustomChord();
                    });
                }

                // Add to favorites button
                const addToFavoritesBtn = document.getElementById('addToFavoritesBtn');
                if (addToFavoritesBtn) {
                    addToFavoritesBtn.addEventListener('click', () => {
                        this.addCurrentChordToFavorites();
                    });
                }

                // Initialize custom chords storage
                this.customChords = JSON.parse(localStorage.getItem('microtonalCustomChords')) || [];
                this.hiddenColumns = JSON.parse(localStorage.getItem('microtonalHiddenColumns')) || [];
                this.favoriteChords = JSON.parse(localStorage.getItem('microtonalFavoriteChords')) || [];
                this.paletteChords = JSON.parse(localStorage.getItem('microtonalPaletteChords')) || [];
                this.currentEditingColumn = null;
                
                // Set up context menu
                this.setupContextMenu();
                
                // Set up fretboard resize functionality
                this.setupFretboardResize();
                
                // Set up chord palette functionality
                this.setupChordPalette();
                
                // Force initial generation
                console.log('Initializing omnichord with tuning:', this.currentTuning);
                setTimeout(() => {
                    this.generateRootButtons();
                    this.generateExtensionColumns();
                    this.renderPaletteChords();
                }, 100);
            }

            setupContextMenu() {
                const contextMenu = document.getElementById('columnContextMenu');
                const paletteContextMenu = document.getElementById('paletteChordContextMenu');
                
                // Touch gesture tracking
                this.touchGestures = {
                    longPressDelay: 300 // milliseconds
                };
                
                // Hide context menu when clicking elsewhere (but not on chord elements)
                document.addEventListener('click', (e) => {
                    // Don't hide menu if clicking on chord elements that should show context menu
                    const isChordElement = e.target.closest('.extension-header') || 
                                          e.target.closest('.extension-column') || 
                                          e.target.closest('.palette-chord');
                    
                    console.log('🔥 Global click handler - isChordElement:', isChordElement, 'target:', e.target);
                    
                    if (!isChordElement && !contextMenu.contains(e.target) && (!paletteContextMenu || !paletteContextMenu.contains(e.target))) {
                        // Use setTimeout to allow context menu to show first
                        setTimeout(() => {
                            console.log('🔥 Hiding context menu via global click handler');
                            contextMenu.style.display = 'none';
                            if (paletteContextMenu) paletteContextMenu.style.display = 'none';
                        }, 10);
                    }
                });

                // Context menu item handlers
                document.querySelectorAll('.context-menu-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const action = e.currentTarget.dataset.action;
                        console.log('🔥 Context menu item clicked:', action);
                        
                        // Use window.omnichord to ensure proper context
                        if (window.omnichord && window.omnichord.handleContextMenuAction) {
                            window.omnichord.handleContextMenuAction(action);
                        } else {
                            console.error('🔥 omnichord instance not available for context menu action!');
                        }
                        
                        contextMenu.style.display = 'none';
                        if (paletteContextMenu) paletteContextMenu.style.display = 'none';
                    });
                });

                // Edit pattern modal handlers
                document.getElementById('closeEditPatternModal').addEventListener('click', () => {
                    document.getElementById('editPatternModal').style.display = 'none';
                });

                document.getElementById('saveEditPattern').addEventListener('click', () => {
                    this.saveEditedPattern();
                });
                
                // Setup touch gestures for all chord elements
                this.setupTouchGestures();
                
                // Add keyboard support for playing chords with numbers 1-0
                this.setupKeyboardInput();
            }
            
            setupKeyboardInput() {
                document.addEventListener('keydown', (e) => {
                    // Only handle number keys 1-0 and only if not typing in an input field
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        return; // Don't interfere with text input
                    }
                    
                    const key = e.key;
                    let chordIndex = -1;
                    
                    // Map number keys to chord indices (1-9, then 0 for 10th chord)
                    if (key >= '1' && key <= '9') {
                        chordIndex = parseInt(key) - 1; // 1 -> 0, 2 -> 1, etc.
                    } else if (key === '0') {
                        chordIndex = 9; // 0 -> 9 (10th chord)
                    }
                    
                    if (chordIndex >= 0) {
                        e.preventDefault();
                        this.playChordByIndex(chordIndex);
                    }
                });
            }
            
            playChordByIndex(index) {
                // First try to play from palette chords
                if (this.paletteChords && index < this.paletteChords.length) {
                    const chord = this.paletteChords[index];
                    console.log(`Playing palette chord ${index + 1}:`, chord.name);
                    this.playPaletteChord(chord);
                    return;
                }
                
                // If no palette chord at that index, try to play from extension columns
                const columns = document.querySelectorAll('.extension-column');
                if (index < columns.length) {
                    const column = columns[index];
                    const header = column.querySelector('.extension-header');
                    if (header) {
                        console.log(`Playing extension chord ${index + 1}:`, header.textContent);
                        // Simulate a click on the column to play the chord
                        const rect = column.getBoundingClientRect();
                        const centerY = rect.top + rect.height / 2;
                        this.playChordStrum(column, { name: header.textContent }, centerY - 10, centerY + 10);
                    }
                } else {
                    console.log(`No chord available at index ${index + 1}`);
                }
            }

            setupTouchGestures() {
                // Add touch gesture support to all chord elements
                this.addTouchGesturesToElements();
                
                // Re-apply gestures when DOM changes (for dynamically added elements)
                const observer = new MutationObserver(() => {
                    this.addTouchGesturesToElements();
                });
                
                observer.observe(document.getElementById('extensionColumns'), {
                    childList: true,
                    subtree: true
                });
                
                observer.observe(document.getElementById('chordPalette'), {
                    childList: true,
                    subtree: true
                });
            }
            
            addTouchGesturesToElements() {
                // Add gestures to chord buttons in extension columns
                document.querySelectorAll('.chord-btn').forEach(btn => {
                    this.addTouchGestureToElement(btn, 'chord');
                    this.addClickGestureToElement(btn, 'chord');
                });
                
                // Add gestures to extension column headers (where context menus should appear)
                const headers = document.querySelectorAll('.extension-header');
                console.log(`Adding touch gestures to ${headers.length} extension headers`);
                headers.forEach(header => {
                    this.addTouchGestureToElement(header, 'chord');
                    this.addClickGestureToElement(header, 'chord');
                });
                
                // Also add click gestures to entire extension columns for easier clicking
                const columns = document.querySelectorAll('.extension-column');
                console.log(`Adding click gestures to ${columns.length} extension columns`);
                columns.forEach(column => {
                    this.addClickGestureToElement(column, 'chord');
                });
                
                // Add gestures to palette chords
                document.querySelectorAll('.palette-chord').forEach(chord => {
                    this.addTouchGestureToElement(chord, 'palette');
                    this.addClickGestureToElement(chord, 'palette');
                });
                
                // Add gestures to root chord buttons
                document.querySelectorAll('.root-btn').forEach(btn => {
                    this.addTouchGestureToElement(btn, 'root');
                    this.addClickGestureToElement(btn, 'root');
                });
            }
            
            addTouchGestureToElement(element, type) {
                // Prevent duplicate listeners
                if (element.dataset.touchGestureAdded) return;
                element.dataset.touchGestureAdded = 'true';
                
                let touchData = {
                    startTime: 0,
                    longPressTimer: null,
                    isLongPress: false
                };
                
                // Store the type for later reference
                element.dataset.touchGestureType = type;
                
                // Touch start
                element.addEventListener('touchstart', (e) => {
                    console.log('Touch start on element:', element.className, 'type:', type);
                    const touch = e.touches[0];
                    touchData.startTime = Date.now();
                    touchData.isLongPress = false;
                    
                    // Add visual feedback for touch press
                    element.classList.add('touch-pressed');
                    
                    // Clear any existing timer
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                    }
                    
                    // Start long press timer
                    touchData.longPressTimer = setTimeout(() => {
                        console.log('Long press triggered on:', element.className);
                        touchData.isLongPress = true;
                        element.classList.remove('touch-pressed');
                        element.classList.add('touch-long-press');
                        this.handleLongPress(element, type, touch.clientX, touch.clientY);
                        
                        // Add haptic feedback if available
                        if (navigator.vibrate) {
                            navigator.vibrate(50);
                        }
                    }, this.touchGestures.longPressDelay);
                    
                    // Only prevent default for extension headers, let root buttons work normally
                    if (type === 'chord' && element.classList.contains('extension-header')) {
                        e.preventDefault();
                    } else if (type === 'palette') {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Touch move - cancel long press if moving too much
                element.addEventListener('touchmove', (e) => {
                    // Cancel long press on any significant movement
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                        touchData.longPressTimer = null;
                        element.classList.remove('touch-pressed');
                    }
                    
                    // Only prevent default for extension headers, let root buttons work normally
                    if (type === 'chord' && element.classList.contains('extension-header')) {
                        e.preventDefault();
                    } else if (type === 'palette') {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Touch end
                element.addEventListener('touchend', (e) => {
                    console.log('Touch end on element:', element.className, 'type:', type);
                    
                    // Clear long press timer
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                        touchData.longPressTimer = null;
                    }
                    
                    // Remove all touch feedback classes
                    element.classList.remove('touch-pressed', 'touch-long-press');
                    
                    // Handle normal tap if not a long press
                    if (!touchData.isLongPress) {
                        if (Date.now() - touchData.startTime < this.touchGestures.longPressDelay) {
                            console.log('Handling normal tap for:', element.className, 'type:', type);
                            this.handleNormalTap(element, type);
                        }
                    }
                    
                    touchData.isLongPress = false;
                    
                    // Only prevent default for extension headers, let root buttons work normally
                    if (type === 'chord' && element.classList.contains('extension-header')) {
                        e.preventDefault();
                    } else if (type === 'palette') {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Touch cancel
                element.addEventListener('touchcancel', (e) => {
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                        touchData.longPressTimer = null;
                    }
                    
                    // Remove all touch feedback classes
                    element.classList.remove('touch-pressed', 'touch-long-press');
                    
                    touchData.isLongPress = false;
                }, { passive: false });
            }
            
            addClickGestureToElement(element, type) {
                // Prevent duplicate listeners
                if (element.dataset.clickGestureAdded) return;
                element.dataset.clickGestureAdded = 'true';
                
                console.log('Adding click gesture to element:', element.className, 'type:', type);
                
                // Add click event listener for regular mouse clicks (using capture phase for higher priority)
                element.addEventListener('click', (e) => {
                    console.log('Click detected on element:', element.className, 'type:', type);
                    
                    // Show context menu for chord headers or extension columns
                    if (type === 'chord' && (element.classList.contains('extension-header') || element.classList.contains('extension-column'))) {
                        console.log('Showing context menu for chord element');
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        // Show context menu on regular click for chord elements
                        this.handleClick(element, type, e.clientX, e.clientY);
                        return false; // Ensure event stops here
                    } else if (type === 'palette') {
                        console.log('Showing context menu for palette chord');
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        // Show context menu for palette chords
                        this.handleClick(element, type, e.clientX, e.clientY);
                        return false; // Ensure event stops here
                    } else {
                        console.log('Not showing context menu for:', type, element.className);
                    }
                    // For root buttons (type === 'root'), let the normal click behavior happen
                }, true); // Use capture phase
                
                // Also add a mousedown listener as backup
                element.addEventListener('mousedown', (e) => {
                    console.log('Mousedown detected on element:', element.className, 'type:', type);
                    
                    // Only handle left click (button 0)
                    if (e.button === 0 && type === 'chord' && (element.classList.contains('extension-header') || element.classList.contains('extension-column'))) {
                        console.log('Left mousedown on chord element, preparing context menu');
                        // Set a flag to show context menu on mouseup
                        element.dataset.showContextMenuOnMouseup = 'true';
                    }
                }, true);
                
                // Add mouseup listener to complete the action
                element.addEventListener('mouseup', (e) => {
                    if (e.button === 0 && element.dataset.showContextMenuOnMouseup === 'true') {
                        console.log('Mouseup detected, showing context menu');
                        delete element.dataset.showContextMenuOnMouseup;
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        this.handleClick(element, type, e.clientX, e.clientY);
                        return false;
                    }
                }, true);
            }
            
            handleClick(element, type, x, y) {
                console.log('handleClick called with:', type, element, 'at position:', x, y);
                
                // Show appropriate context menu based on element type
                if (type === 'chord' && (element.classList.contains('extension-header') || element.classList.contains('extension-column'))) {
                    console.log('Processing chord element click');
                    // Handle extension headers and columns
                    const column = element.classList.contains('extension-column') ? element : element.closest('.extension-column');
                    if (column) {
                        console.log('Found parent column:', column);
                        // Extract the same data as the contextmenu handler would
                        const chordType = column.dataset.chordType;
                        console.log('Chord type:', chordType);
                        // Find the extension index and quality from the structure
                        let columnData = null;
                        
                        // Check if it's a custom chord
                        if (chordType && chordType.startsWith('custom_')) {
                            const customIndex = parseInt(chordType.replace('custom_', ''));
                            const customChord = this.customChords[customIndex];
                            if (customChord) {
                                columnData = {
                                    name: customChord.name,
                                    extensions: [],
                                    quality: 'custom',
                                    id: chordType,
                                    isCustom: true,
                                    originalName: customChord.name,
                                    customIndex: customIndex,
                                    intervals: customChord.notes
                                };
                            }
                        } else {
                            // Regular extension chord - need to determine quality and extension
                            const qualitySection = element.closest('.quality-section');
                            const allQualitySections = Array.from(document.querySelectorAll('.quality-section'));
                            const qualityIndex = allQualitySections.indexOf(qualitySection);
                            const qualities = ['major', 'neutral', 'minor'];
                            const quality = qualities[qualityIndex] || 'major';
                            
                            // Find the extension from the chord type ID
                            const chordIndex = parseInt(chordType);
                            const chordExt = this.chordExtensions[chordIndex];
                            
                            if (chordExt) {
                                const header = column.querySelector('.extension-header');
                                columnData = {
                                    name: header ? header.textContent : chordExt.name,
                                    extensions: chordExt.extensions || [],
                                    quality: quality,
                                    id: chordType,
                                    isCustom: false,
                                    originalName: chordExt.name,
                                    extensionIndex: chordIndex
                                };
                            }
                        }
                        
                        if (columnData) {
                            console.log('Showing context menu for column data:', columnData);
                            this.showColumnContextMenu(x, y, columnData);
                        } else {
                            console.error('Failed to create columnData');
                        }
                    } else {
                        console.error('Could not find parent column');
                    }
                } else if (type === 'palette') {
                    console.log('Processing palette click');
                    const chordData = this.getPaletteChordDataFromElement(element);
                    this.showPaletteContextMenu(x, y, chordData);
                } else {
                    console.log('Unhandled click type:', type);
                }
                // Don't handle 'root' type clicks here - let them work normally
            }
            
            handleLongPress(element, type, x, y) {
                console.log('Long press detected on', type, element);
                
                // Show appropriate context menu based on element type
                if (type === 'chord') {
                    // Check if this is an extension header
                    if (element.classList.contains('extension-header')) {
                        // Get the column data from the parent column
                        const column = element.closest('.extension-column');
                        if (column) {
                            // Extract the same data as the contextmenu handler would
                            const chordType = column.dataset.chordType;
                            // Find the extension index and quality from the structure
                            let columnData = null;
                            
                            // Check if it's a custom chord
                            if (chordType && chordType.startsWith('custom_')) {
                                const customIndex = parseInt(chordType.replace('custom_', ''));
                                const customChord = this.customChords[customIndex];
                                if (customChord) {
                                    columnData = {
                                        name: customChord.name,
                                        extensions: [],
                                        quality: 'custom',
                                        id: chordType,
                                        isCustom: true,
                                        originalName: customChord.name,
                                        customIndex: customIndex,
                                        intervals: customChord.notes
                                    };
                                }
                            } else {
                                // Regular extension chord - need to determine quality and extension
                                const qualitySection = element.closest('.quality-section');
                                const allQualitySections = Array.from(document.querySelectorAll('.quality-section'));
                                const qualityIndex = allQualitySections.indexOf(qualitySection);
                                const qualities = ['major', 'neutral', 'minor'];
                                const quality = qualities[qualityIndex] || 'major';
                                
                                // Find the extension from the chord type ID
                                const chordIndex = parseInt(chordType);
                                const chordExt = this.chordExtensions[chordIndex];
                                
                                if (chordExt) {
                                    columnData = {
                                        name: element.textContent,
                                        extensions: chordExt.extensions || [],
                                        quality: quality,
                                        id: chordType,
                                        isCustom: false,
                                        originalName: chordExt.name,
                                        extensionIndex: chordIndex
                                    };
                                }
                            }
                            
                            if (columnData) {
                                console.log('Showing context menu for:', columnData);
                                this.showColumnContextMenu(x, y, columnData);
                            }
                        }
                    } else {
                        // Fallback to original logic for other chord elements
                        const columnData = this.getColumnDataFromElement(element);
                        this.showColumnContextMenu(x, y, columnData);
                    }
                } else if (type === 'palette') {
                    const chordData = this.getPaletteChordDataFromElement(element);
                    this.showPaletteContextMenu(x, y, chordData);
                } else if (type === 'root') {
                    // Root chords could have their own context menu
                    console.log('Root chord long press - could implement root chord options');
                }
            }
            
            handleNormalTap(element, type) {
                console.log('handleNormalTap called with:', element.className, 'type:', type);
                
                // Handle normal tap based on element type - only show context menu for chord headers and palette
                if (type === 'chord' && element.classList.contains('extension-header')) {
                    console.log('Showing context menu for chord header tap');
                    // Show context menu for chord headers
                    const rect = element.getBoundingClientRect();
                    const x = rect.left + rect.width / 2;
                    const y = rect.top + rect.height / 2;
                    this.handleClick(element, type, x, y);
                } else if (type === 'palette') {
                    console.log('Showing context menu for palette chord tap');
                    // Show context menu for palette chords
                    const rect = element.getBoundingClientRect();
                    const x = rect.left + rect.width / 2;
                    const y = rect.top + rect.height / 2;
                    this.handleClick(element, type, x, y);
                } else if (type === 'root') {
                    console.log('Processing root button tap');
                    // For root buttons, perform normal click behavior
                    const rootBtn = element.closest('.root-btn');
                    if (rootBtn) {
                        // Simulate a normal click to change root note
                        rootBtn.click();
                    }
                } else {
                    console.log('No action for tap on:', element.className, 'type:', type);
                }
            }
            
            getColumnDataFromElement(element) {
                const column = element.closest('[data-chord-type]');
                if (!column) return null;
                
                return {
                    name: column.dataset.chordType,
                    extensions: column.dataset.extensions ? column.dataset.extensions.split(',') : [],
                    element: column
                };
            }
            
            getPaletteChordDataFromElement(element) {
                const chordElement = element.closest('.palette-chord');
                if (!chordElement) return null;
                
                const chordIndex = parseInt(chordElement.dataset.chordIndex);
                return this.paletteChords[chordIndex] || null;
            }
            
            showPaletteContextMenu(x, y, chordData) {
                const contextMenu = document.getElementById('paletteChordContextMenu');
                if (!contextMenu || !chordData) return;
                
                this.currentEditingPaletteChord = chordData;
                
                // Position the menu
                contextMenu.style.left = `${x}px`;
                contextMenu.style.top = `${y}px`;
                contextMenu.style.display = 'block';
            }
            
            handlePaletteContextMenuAction(action) {
                const chordData = this.currentEditingPaletteChord;
                if (!chordData) return;
                
                switch (action) {
                    case 'play-chord':
                        this.playChord(chordData.notes, chordData.root);
                        break;
                    case 'edit-chord-notes':
                        this.editPaletteChordNotes(chordData);
                        break;
                    case 'copy-chord':
                        this.copyPaletteChord(chordData);
                        break;
                    case 'move-chord-left':
                        this.movePaletteChord(chordData, -1);
                        break;
                    case 'move-chord-right':
                        this.movePaletteChord(chordData, 1);
                        break;
                    case 'remove-chord':
                        this.removePaletteChord(chordData);
                        break;
                }
            }

            showColumnContextMenu(x, y, columnData) {
                console.log('🔥 showColumnContextMenu called with:', x, y, columnData);
                const contextMenu = document.getElementById('columnContextMenu');
                if (!contextMenu) {
                    console.error('🔥 Context menu element not found!');
                    return;
                }
                
                console.log('🔥 Context menu element found:', contextMenu);
                
                this.currentEditingColumn = columnData;
                console.log('🔥 Set currentEditingColumn to:', this.currentEditingColumn);
                
                // Position the menu
                contextMenu.style.left = `${x}px`;
                contextMenu.style.top = `${y}px`;
                contextMenu.style.display = 'block';
                console.log('🔥 Context menu positioned at:', x, y, 'display set to block');
                
                // Log the current computed style
                const computedStyle = window.getComputedStyle(contextMenu);
                console.log('🔥 Context menu computed display:', computedStyle.display);
                console.log('🔥 Context menu computed visibility:', computedStyle.visibility);
                console.log('🔥 Context menu computed zIndex:', computedStyle.zIndex);
                
                // Adjust position if menu goes off screen
                const rect = contextMenu.getBoundingClientRect();
                console.log('🔥 Context menu rect:', rect);
                if (rect.right > window.innerWidth) {
                    contextMenu.style.left = `${x - rect.width}px`;
                    console.log('🔥 Adjusted left position to:', x - rect.width);
                }
                if (rect.bottom > window.innerHeight) {
                    contextMenu.style.top = `${y - rect.height}px`;
                    console.log('🔥 Adjusted top position to:', y - rect.height);
                }
            }

            handleContextMenuAction(action) {
                console.log('🔥 handleContextMenuAction called with action:', action);
                console.log('🔥 currentEditingColumn:', this.currentEditingColumn);
                
                if (!this.currentEditingColumn && !['create-custom-chord', 'manage-columns'].includes(action)) {
                    console.error('🔥 No currentEditingColumn set for action:', action);
                    alert('Error: No column selected for this action');
                    return;
                }

                try {
                    switch (action) {
                        case 'rename':
                            console.log('🔥 Calling renameColumn');
                            this.renameColumn();
                            break;
                        case 'copy':
                            console.log('🔥 Calling copyColumn');
                            this.copyColumn();
                            break;
                        case 'edit-pattern':
                            console.log('🔥 Calling editColumnPattern');
                            this.editColumnPattern();
                            break;
                        case 'move-left':
                            console.log('🔥 Calling moveColumn(-1)');
                            this.moveColumn(-1);
                            break;
                        case 'move-right':
                            console.log('🔥 Calling moveColumn(1)');
                            this.moveColumn(1);
                            break;
                        case 'hide':
                            console.log('🔥 Calling hideColumn');
                            this.hideColumn();
                            break;
                        case 'delete':
                            console.log('🔥 Calling deleteColumn');
                            this.deleteColumn();
                            break;
                        case 'add-to-favorites':
                            console.log('🔥 Calling addToFavorites');
                            this.addToFavorites();
                            break;
                        case 'add-to-palette':
                            console.log('🔥 Calling addToPalette');
                            this.addToPalette();
                            break;
                        case 'create-custom-chord':
                            console.log('🔥 Calling showCustomChordModal');
                            this.showCustomChordModal();
                            break;
                        case 'manage-columns':
                            console.log('🔥 Calling showColumnModal');
                            this.showColumnModal();
                            break;
                        case 'add-column':
                            console.log('🔥 Calling addColumn');
                            this.addColumn();
                            break;
                        default:
                            console.log('🔥 Unknown action:', action);
                            alert('Unknown action: ' + action);
                    }
                } catch (error) {
                    console.error('🔥 Error in handleContextMenuAction:', error);
                    alert('Error executing action: ' + error.message);
                }
            }

            // Palette chord context menu actions
            editPaletteChordNotes(chordData) {
                // Open a modal to edit chord notes
                console.log('Editing palette chord notes:', chordData);
                // TODO: Implement chord note editor
            }
            
            copyPaletteChord(chordData) {
                // Create a copy of the chord and add it to the palette
                const copy = {
                    ...chordData,
                    name: chordData.name + ' Copy'
                };
                this.paletteChords.push(copy);
                this.savePaletteChords();
                this.updateChordPalette();
                console.log('Copied palette chord:', copy);
            }
            
            movePaletteChord(chordData, direction) {
                const currentIndex = this.paletteChords.findIndex(chord => 
                    chord.name === chordData.name && 
                    JSON.stringify(chord.notes) === JSON.stringify(chordData.notes)
                );
                
                if (currentIndex === -1) return;
                
                const newIndex = currentIndex + direction;
                if (newIndex < 0 || newIndex >= this.paletteChords.length) return;
                
                // Swap positions
                [this.paletteChords[currentIndex], this.paletteChords[newIndex]] = 
                [this.paletteChords[newIndex], this.paletteChords[currentIndex]];
                
                this.savePaletteChords();
                this.updateChordPalette();
                console.log('Moved palette chord:', direction > 0 ? 'right' : 'left');
            }
            
            removePaletteChord(chordData) {
                const index = this.paletteChords.findIndex(chord => 
                    chord.name === chordData.name && 
                    JSON.stringify(chord.notes) === JSON.stringify(chordData.notes)
                );
                
                if (index !== -1) {
                    this.paletteChords.splice(index, 1);
                    this.savePaletteChords();
                    this.updateChordPalette();
                    console.log('Removed palette chord:', chordData.name);
                }
            }

            setupFretboardResize() {
                const resizeHandle = document.querySelector('.resize-handle');
                const extensionColumns = document.getElementById('extensionColumns');
                let isResizing = false;
                let startY = 0;
                let startHeight = 0;

                if (!resizeHandle || !extensionColumns) return;

                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startY = e.clientY;
                    startHeight = extensionColumns.offsetHeight;
                    document.body.style.cursor = 'ns-resize';
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;
                    
                    const deltaY = e.clientY - startY;
                    const newHeight = Math.max(200, Math.min(800, startHeight + deltaY));
                    
                    // Update container height
                    extensionColumns.style.height = `${newHeight}px`;
                    
                    // Update string spacing by adjusting string height and margin
                    const strings = document.querySelectorAll('.string');
                    const maxStrings = 50; // Approximate max strings per column
                    const stringHeight = Math.max(3, Math.min(8, newHeight / maxStrings - 2));
                    const stringMargin = Math.max(1, Math.min(3, stringHeight * 0.4));
                    
                    strings.forEach(string => {
                        string.style.height = `${stringHeight}px`;
                        string.style.margin = `${stringMargin}px 0`;
                    });
                    
                    e.preventDefault();
                });

                document.addEventListener('mouseup', () => {
                    if (isResizing) {
                        isResizing = false;
                        document.body.style.cursor = '';
                    }
                });

                // Touch support for mobile
                resizeHandle.addEventListener('touchstart', (e) => {
                    isResizing = true;
                    startY = e.touches[0].clientY;
                    startHeight = extensionColumns.offsetHeight;
                    e.preventDefault();
                });

                document.addEventListener('touchmove', (e) => {
                    if (!isResizing) return;
                    
                    const deltaY = e.touches[0].clientY - startY;
                    const newHeight = Math.max(200, Math.min(800, startHeight + deltaY));
                    
                    extensionColumns.style.height = `${newHeight}px`;
                    
                    const strings = document.querySelectorAll('.string');
                    const maxStrings = 50;
                    const stringHeight = Math.max(3, Math.min(8, newHeight / maxStrings - 2));
                    const stringMargin = Math.max(1, Math.min(3, stringHeight * 0.4));
                    
                    strings.forEach(string => {
                        string.style.height = `${stringHeight}px`;
                        string.style.margin = `${stringMargin}px 0`;
                    });
                    
                    e.preventDefault();
                });

                document.addEventListener('touchend', () => {
                    if (isResizing) {
                        isResizing = false;
                    }
                });
            }

            setupChordPalette() {
                // Initial render of palette chords (this will create drop zone if empty)
                this.renderPaletteChords();
            }

            addToPalette(chordData) {
                // Always add chords to palette, even duplicates for chord progressions
                // Add a unique ID to track individual instances
                const chordWithId = {
                    ...chordData,
                    paletteId: Date.now() + Math.random() // Unique identifier for this instance
                };
                
                this.paletteChords.push(chordWithId);
                localStorage.setItem('microtonalPaletteChords', JSON.stringify(this.paletteChords));
                console.log(`Added "${chordData.fullName}" to palette (${this.paletteChords.length} total chords)`);
                this.renderPaletteChords();
            }

            removeFromPalette(index) {
                if (index >= 0 && index < this.paletteChords.length) {
                    const removedChord = this.paletteChords.splice(index, 1)[0];
                    localStorage.setItem('microtonalPaletteChords', JSON.stringify(this.paletteChords));
                    this.renderPaletteChords();
                    console.log(`Removed "${removedChord.fullName}" from palette`);
                }
            }

            clearPalette() {
                if (confirm('Clear all chords from the palette?')) {
                    this.paletteChords = [];
                    localStorage.setItem('microtonalPaletteChords', JSON.stringify(this.paletteChords));
                    this.renderPaletteChords();
                }
            }

            renderPaletteChords() {
                const chordPalette = document.getElementById('chordPalette');
                if (!chordPalette) return;
                
                // Clear existing chords
                chordPalette.innerHTML = '';
                
                if (this.paletteChords.length === 0) {
                    // Show empty message when no chords
                    const emptyMessage = document.createElement('div');
                    emptyMessage.className = 'empty-message';
                    emptyMessage.id = 'emptyMessage';
                    emptyMessage.innerHTML = '<div class="empty-hint">Use context menu "Add to Palette" to add chords here</div>';
                    chordPalette.appendChild(emptyMessage);
                } else {
                    // Set up dynamic grid layout to stretch across full page width with no gaps
                    const numChords = this.paletteChords.length;
                    chordPalette.style.display = 'grid';
                    chordPalette.style.gridTemplateColumns = `repeat(${numChords}, 1fr)`;
                    chordPalette.style.gap = '0';
                    chordPalette.style.width = '100%';
                    chordPalette.style.height = '100%';
                    chordPalette.style.padding = '0';
                    
                    // Render palette chords as exact copies of main fretboard columns
                    this.paletteChords.forEach((chord, index) => {
                        const paletteColumn = document.createElement('div');
                        paletteColumn.className = 'extension-column palette-column';
                        paletteColumn.dataset.index = index;
                        paletteColumn.style.border = '1px solid #4a6870';
                        paletteColumn.style.borderRadius = '0';
                        paletteColumn.style.background = 'linear-gradient(135deg, #2a4858, #3a5868)';
                        paletteColumn.style.width = '100%';
                        paletteColumn.style.height = '100%';
                        paletteColumn.style.position = 'relative';
                        paletteColumn.style.cursor = 'pointer';
                        paletteColumn.style.margin = '0';
                        paletteColumn.style.padding = '0';
                        
                        // Make the entire column strummable with high-resolution tracking
                        let isStruming = false;
                        let strumStartY = 0;
                        let strumEndY = 0;
                        let lastStrumTime = 0;
                        let lastStrumY = 0;
                        
                        // Add strum functionality to the entire column
                        const addStrumming = (element) => {
                            element.addEventListener('mousedown', (e) => {
                                e.preventDefault();
                                isStruming = true;
                                strumStartY = e.clientY;
                                strumEndY = e.clientY;
                                lastStrumY = e.clientY;
                                lastStrumTime = performance.now();
                                element.style.transform = 'scale(1.02)';
                                element.style.borderColor = '#8fb3d3';
                            });
                            
                            element.addEventListener('mousemove', (e) => {
                                if (isStruming) {
                                    const currentTime = performance.now();
                                    const currentY = e.clientY;
                                    const deltaY = Math.abs(currentY - lastStrumY);
                                    const timeDelta = currentTime - lastStrumTime;
                                    
                                    // High-resolution tracking: trigger on 3px movement OR 16ms time (60fps)
                                    if (deltaY >= 3 || timeDelta >= 16) {
                                        strumEndY = currentY;
                                        this.playChordStrum(paletteColumn, chord, lastStrumY, strumEndY);
                                        lastStrumY = currentY;
                                        lastStrumTime = currentTime;
                                    }
                                }
                            });
                            
                            element.addEventListener('mouseup', (e) => {
                                if (isStruming) {
                                    strumEndY = e.clientY;
                                    if (Math.abs(strumEndY - lastStrumY) >= 2) {
                                        this.playChordStrum(paletteColumn, chord, lastStrumY, strumEndY);
                                    }
                                }
                                isStruming = false;
                                element.style.transform = 'scale(1)';
                                element.style.borderColor = '#4a6870';
                            });
                            
                            element.addEventListener('mouseleave', (e) => {
                                if (isStruming) {
                                    strumEndY = e.clientY;
                                    if (Math.abs(strumEndY - lastStrumY) >= 2) {
                                        this.playChordStrum(paletteColumn, chord, lastStrumY, strumEndY);
                                    }
                                }
                                isStruming = false;
                                element.style.transform = 'scale(1)';
                                element.style.borderColor = '#4a6870';
                            });
                            
                            // Touch support for mobile with high-resolution tracking
                            element.addEventListener('touchstart', (e) => {
                                e.preventDefault();
                                isStruming = true;
                                strumStartY = e.touches[0].clientY;
                                strumEndY = e.touches[0].clientY;
                                lastStrumY = e.touches[0].clientY;
                                lastStrumTime = performance.now();
                                element.style.transform = 'scale(1.02)';
                                element.style.borderColor = '#8fb3d3';
                            });
                            
                            element.addEventListener('touchmove', (e) => {
                                if (isStruming) {
                                    const currentTime = performance.now();
                                    const currentY = e.touches[0].clientY;
                                    const deltaY = Math.abs(currentY - lastStrumY);
                                    const timeDelta = currentTime - lastStrumTime;
                                    
                                    // High-resolution tracking for touch
                                    if (deltaY >= 2 || timeDelta >= 16) {
                                        strumEndY = currentY;
                                        this.playChordStrum(paletteColumn, chord, lastStrumY, strumEndY);
                                        lastStrumY = currentY;
                                        lastStrumTime = currentTime;
                                    }
                                }
                            });
                            
                            element.addEventListener('touchend', (e) => {
                                if (isStruming && e.changedTouches.length > 0) {
                                    const finalY = e.changedTouches[0].clientY;
                                    if (Math.abs(finalY - lastStrumY) >= 2) {
                                        this.playChordStrum(paletteColumn, chord, lastStrumY, finalY);
                                    }
                                }
                                isStruming = false;
                                element.style.transform = 'scale(1)';
                                element.style.borderColor = '#4a6870';
                            });
                        };
                        
                        // Create header (same as main fretboard)
                        const header = document.createElement('div');
                        header.className = 'extension-header';
                        header.textContent = chord.fullName;
                        header.style.background = chord.isCustom ? '#6366f1' : 'rgba(0, 0, 0, 0.8)';
                        header.style.color = '#fff';
                        header.style.fontWeight = 'bold';
                        header.style.fontSize = '11px';
                        header.style.padding = '6px';
                        header.style.textAlign = 'center';
                        header.style.lineHeight = '1.2';
                        
                        // Add simple left-click handler for context menu
                        header.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            console.log('Palette header CLICKED:', chord.fullName);
                            this.showPaletteContextMenu(e.clientX, e.clientY, chord);
                        });
                        
                        // Add right-click handler too
                        header.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            console.log('Palette header RIGHT-CLICKED:', chord.fullName);
                            this.showPaletteContextMenu(e.clientX, e.clientY, chord);
                        });
                        
                        // Position header on top with highest priority
                        header.style.position = 'relative';
                        header.style.zIndex = '9999';
                        header.style.pointerEvents = 'all';
                        header.style.cursor = 'pointer';
                        header.style.userSelect = 'none';
                        
                        // Add tuning indicator for locked chords
                        if (chord.tuningName) {
                            header.innerHTML = `${chord.fullName}<br><span style="font-size: 8px; color: #f39c12;">${chord.tuningName}</span>`;
                        }
                        
                        // Create strings container (same as main fretboard)
                        const stringsContainer = document.createElement('div');
                        stringsContainer.className = 'strings-column';
                        stringsContainer.style.height = 'calc(100% - 60px)'; // Account for header and labels
                        
                        // Generate chord intervals using locked settings
                        let intervals = [];
                        
                        // Temporarily switch to locked settings for frequency calculation
                        const originalTuning = this.currentTuning;
                        const originalGamelanMode = this.gamelanMode;
                        const originalRoot = this.currentRoot;
                        
                        if (chord.lockedTuning !== undefined) {
                            this.currentTuning = chord.lockedTuning;
                        }
                        if (chord.lockedGamelanMode !== undefined) {
                            this.gamelanMode = chord.lockedGamelanMode;
                        }
                        if (chord.lockedRoot !== undefined) {
                            this.currentRoot = chord.lockedRoot;
                        }
                        
                        if (chord.isCustom) {
                            // For custom chords, use the stored intervals
                            intervals = chord.intervals || chord.notes || [];
                        } else {
                            // For standard chords, use the extensions from the chord data
                            const originalQuality = this.currentQuality;
                            this.currentQuality = chord.quality || 'major';
                            intervals = this.getChordIntervals(chord.extensions || []);
                            this.currentQuality = originalQuality;
                        }
                        
                        // Generate strings for multiple octaves
                        const stringFreqs = [];
                        for (let octave = 2; octave <= 8; octave++) {
                            intervals.forEach(interval => {
                                let step;
                                if (chord.isCustom) {
                                    // For custom chords, translate 12-TET to current tuning
                                    const translatedStep = this.translateSemitoneToTuning ? this.translateSemitoneToTuning(interval) : interval;
                                    step = (chord.rootNote + translatedStep) % this.currentTuning;
                                } else {
                                    step = (chord.rootNote + interval) % this.currentTuning;
                                }
                                const freq = this.getFrequency(step, octave);
                                stringFreqs.push({ freq, step, octave, interval });
                            });
                        }
                        
                        // Restore original settings
                        this.currentTuning = originalTuning;
                        this.gamelanMode = originalGamelanMode;
                        this.currentRoot = originalRoot;
                        
                        // Sort by frequency and create strings
                        stringFreqs.sort((a, b) => a.freq - b.freq);
                        
                        // Calculate responsive string sizing for palette
                        const paletteHeight = 200; // minHeight of palette-column
                        const availableHeight = paletteHeight - 60; // Account for header and labels
                        const numStrings = stringFreqs.length;
                        const maxStringHeight = Math.min(6, Math.max(2, availableHeight / numStrings - 1));
                        const stringMargin = Math.max(0.5, maxStringHeight * 0.2);
                        
                        stringFreqs.forEach((stringData, stringIndex) => {
                            const stringElement = document.createElement('div');
                            stringElement.className = 'string';
                            stringElement.dataset.index = `palette_${index}_${stringIndex}`;
                            stringElement.dataset.column = `palette_${index}`;
                            stringElement.dataset.paletteIndex = index;
                            stringElement.dataset.stringIndex = stringIndex;
                            stringElement.dataset.frequency = stringData.freq;
                            stringElement.dataset.noteIndex = stringData.step;
                            
                            // Color strings based on their role in the chord
                            let hue = 0;
                            if (stringData.interval === 0) hue = 240; // Root - blue
                            else if (stringData.interval === 2 || stringData.interval === 3 || stringData.interval === 4) hue = 120; // 3rd - green  
                            else if (stringData.interval === 7) hue = 60; // 5th - yellow
                            else if (stringData.interval === 9 || stringData.interval === 10) hue = 300; // 6th - magenta
                            else if (stringData.interval === 11 || stringData.interval === 12) hue = 180; // 7th - cyan
                            else if (stringData.interval === 14) hue = 30; // 9th - orange
                            else hue = 0; // Extensions - red
                            
                            stringElement.style.backgroundColor = `hsl(${hue}, 70%, 50%)`;
                            stringElement.style.opacity = '0.8';
                            stringElement.style.height = `${maxStringHeight}px`;
                            stringElement.style.margin = `${stringMargin}px 0`;
                            stringElement.style.borderRadius = '2px';
                            stringElement.style.cursor = 'pointer';
                            stringElement.title = `${this.getNoteName ? this.getNoteName(stringData.step) : `Note ${stringData.step}`} - ${stringData.freq.toFixed(1)}Hz`;
                            
                            stringsContainer.appendChild(stringElement);
                        });
                        
                        // Create note labels at bottom (same as main fretboard)
                        const noteLabels = document.createElement('div');
                        noteLabels.className = 'note-labels';
                        noteLabels.textContent = this.getNoteName ? this.getNoteName(chord.rootNote) : `Note ${chord.rootNote}`;
                        noteLabels.style.textAlign = 'center';
                        noteLabels.style.padding = '4px';
                        noteLabels.style.fontSize = '10px';
                        noteLabels.style.color = '#8fb3d3';
                        
                        // Create remove button
                        const removeBtn = document.createElement('div');
                        removeBtn.className = 'palette-chord-remove';
                        removeBtn.innerHTML = '×';
                        removeBtn.style.position = 'absolute';
                        removeBtn.style.top = '-5px';
                        removeBtn.style.right = '-5px';
                        removeBtn.style.width = '20px';
                        removeBtn.style.height = '20px';
                        removeBtn.style.backgroundColor = '#e94560';
                        removeBtn.style.color = 'white';
                        removeBtn.style.borderRadius = '50%';
                        removeBtn.style.display = 'flex';
                        removeBtn.style.alignItems = 'center';
                        removeBtn.style.justifyContent = 'center';
                        removeBtn.style.cursor = 'pointer';
                        removeBtn.style.fontSize = '14px';
                        removeBtn.style.fontWeight = 'bold';
                        removeBtn.style.zIndex = '10';
                        removeBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.removeFromPalette(index);
                        });
                        
                        paletteColumn.appendChild(header);
                        paletteColumn.appendChild(stringsContainer);
                        paletteColumn.appendChild(noteLabels);
                        paletteColumn.appendChild(removeBtn);
                        
                        // Apply strumming ONLY to the strings container, NOT the header
                        addStrumming(stringsContainer);
                        
                        chordPalette.appendChild(paletteColumn);
                    });
                }
                
                // Add simple click handlers after rendering
                setTimeout(() => this.addSimpleClickHandlers(), 100);
            }

            playPaletteChord(chord) {
                // Use locked settings from when the chord was dragged
                const originalRoot = this.currentRoot;
                const originalQuality = this.currentQuality;
                const originalTuning = this.currentTuning;
                const originalGamelanMode = this.gamelanMode;
                
                // Temporarily switch to the chord's locked settings
                this.currentRoot = chord.lockedRoot || chord.root;
                this.currentQuality = chord.quality;
                if (chord.lockedTuning !== undefined) {
                    this.currentTuning = chord.lockedTuning;
                }
                if (chord.lockedGamelanMode !== undefined) {
                    this.gamelanMode = chord.lockedGamelanMode;
                }
                
                // Generate intervals for this chord using locked settings
                let intervals;
                if (chord.intervals) {
                    // Custom chord with specific intervals
                    intervals = chord.intervals.map(interval => {
                        const translatedStep = this.translateSemitoneToTuning(interval);
                        return (this.currentRoot + translatedStep) % this.currentTuning;
                    });
                } else {
                    // Standard chord with extensions
                    const chordIntervals = this.getChordIntervals(chord.extensions);
                    intervals = chordIntervals.map(interval => 
                        (this.currentRoot + interval) % this.currentTuning
                    );
                }
                
                // Play the chord for 1 second with proper ADSR routing
                const baseOctave = 4;
                intervals.forEach(step => {
                    const freq = this.getFrequency(step, baseOctave);
                    // Create a dummy element for proper ADSR handling
                    const dummyElement = { classList: { add: () => {}, remove: () => {} } };
                    this.playFrequency(freq, dummyElement);
                });
                
                // Stop all notes after 1 second
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 1000);
                
                // Restore original settings
                this.currentRoot = originalRoot;
                this.currentQuality = originalQuality;
                this.currentTuning = originalTuning;
                this.gamelanMode = originalGamelanMode;
                
                console.log(`Played chord: ${chord.fullName} (${chord.tuningName || 'current tuning'})`);
            }

            renameColumn() {
                const newName = prompt('Enter new column name:', this.currentEditingColumn.name);
                if (newName && newName.trim()) {
                    this.currentEditingColumn.name = newName.trim();
                    this.updateColumnInStorage();
                    this.generateExtensionColumns();
                }
            }

            copyColumn() {
                // Create a copy of the current column as a new chord extension (not custom chord)
                const baseName = this.currentEditingColumn.originalName || this.currentEditingColumn.name.replace(/^(Maj|Neu|Min)/, '');
                const columnCopy = {
                    name: `${baseName} Copy`,
                    extensions: [...(this.currentEditingColumn.extensions || [])],
                    intervals: this.currentEditingColumn.intervals || null
                };
                
                // Add to chord extensions so it gets all 3 flavors
                this.chordExtensions.push(columnCopy);
                this.saveChordConfiguration();
                this.generateExtensionColumns();
                
                console.log(`Copied column: ${columnCopy.name}`);
            }

            editColumnPattern() {
                const modal = document.getElementById('editPatternModal');
                const title = document.getElementById('editPatternTitle');
                const nameInput = document.getElementById('editPatternName');
                
                title.textContent = `Edit Pattern: ${this.currentEditingColumn.name}`;
                nameInput.value = this.currentEditingColumn.name;
                
                this.setupIntervalEditor();
                modal.style.display = 'block';
            }

            setupIntervalEditor() {
                const editor = document.getElementById('intervalEditor');
                editor.innerHTML = '';
                
                // Create interval input fields for common intervals
                const intervals = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
                
                intervals.forEach(interval => {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `interval_${interval}`;
                    checkbox.value = interval;
                    
                    const label = document.createElement('label');
                    label.htmlFor = `interval_${interval}`;
                    label.textContent = interval;
                    label.style.cssText = 'display: flex; align-items: center; gap: 5px; padding: 5px; background: #16213e; border-radius: 3px; cursor: pointer;';
                    
                    label.prepend(checkbox);
                    editor.appendChild(label);
                });
            }

            setQuickPattern(intervals) {
                // Clear all checkboxes
                document.querySelectorAll('#intervalEditor input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                
                // Check the specified intervals
                intervals.forEach(interval => {
                    const checkbox = document.getElementById(`interval_${interval}`);
                    if (checkbox) checkbox.checked = true;
                });
            }

            saveEditedPattern() {
                const nameInput = document.getElementById('editPatternName');
                const selectedIntervals = Array.from(document.querySelectorAll('#intervalEditor input[type="checkbox"]:checked'))
                    .map(cb => parseInt(cb.value))
                    .sort((a, b) => a - b);

                if (selectedIntervals.length === 0) {
                    alert('Please select at least one interval.');
                    return;
                }

                // Update the column
                this.currentEditingColumn.name = nameInput.value;
                this.currentEditingColumn.intervals = selectedIntervals;
                
                this.updateColumnInStorage();
                document.getElementById('editPatternModal').style.display = 'none';
                this.generateExtensionColumns();
            }

            moveColumn(direction) {
                const currentId = this.currentEditingColumn.id || this.currentEditingColumn.name.toLowerCase();
                const currentIndex = this.chordExtensions.findIndex(ext => 
                    ext.name.toLowerCase() === currentId || ext.name === this.currentEditingColumn.name
                );
                
                if (currentIndex === -1) return;
                
                const newIndex = currentIndex + direction;
                if (newIndex < 0 || newIndex >= this.chordExtensions.length) return;
                
                // Swap the chord extensions
                [this.chordExtensions[currentIndex], this.chordExtensions[newIndex]] = 
                [this.chordExtensions[newIndex], this.chordExtensions[currentIndex]];
                
                // Save configuration
                this.saveChordConfiguration();
                
                // Regenerate columns
                this.generateExtensionColumns();
                
                console.log(`Moved column ${this.currentEditingColumn.name} ${direction > 0 ? 'right' : 'left'}`);
            }

            loadChordConfiguration() {
                try {
                    const saved = localStorage.getItem('microtonalChordConfig');
                    return saved ? JSON.parse(saved) : null;
                } catch (e) {
                    console.error('Error loading chord configuration:', e);
                    return null;
                }
            }

            saveChordConfiguration() {
                try {
                    localStorage.setItem('microtonalChordConfig', JSON.stringify(this.chordExtensions));
                } catch (e) {
                    console.error('Error saving chord configuration:', e);
                }
            }

            addColumn() {
                // Show modal to select chord type
                this.showAddColumnModal();
            }

            showAddColumnModal() {
                // Create modal for adding new column
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 800px;">
                        <h3>Add New Chord Column</h3>
                        <div style="display: flex; gap: 20px;">
                            <div style="flex: 1;">
                                <h4>Preset Chords</h4>
                                <div class="add-column-grid">
                                    ${this.availableChordTypes.map(chord => `
                                        <button class="add-chord-btn" data-chord='${JSON.stringify(chord)}'>
                                            ${chord.name}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <h4>Create Custom Chord</h4>
                                <div style="margin-bottom: 15px;">
                                    <label>Chord Name:</label>
                                    <input type="text" id="customChordName" placeholder="My Chord" style="width: 100%; padding: 5px; margin-top: 5px;">
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <label>Select Notes (0-11 semitones):</label>
                                    <div id="noteSelector" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 10px;">
                                        ${Array.from({length: 12}, (_, i) => `
                                            <label style="display: flex; align-items: center; gap: 5px; padding: 8px; background: #333; border-radius: 4px; cursor: pointer;">
                                                <input type="checkbox" value="${i}" class="note-checkbox" style="cursor: pointer;">
                                                <span class="note-label">${this.getNoteNameFromSemitone(i)}</span>
                                                <button type="button" class="preview-btn" data-note="${i}" style="margin-left: auto; padding: 2px 6px; font-size: 10px; background: #555; border: none; color: white; border-radius: 3px; cursor: pointer;">♪</button>
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <button type="button" id="previewChord" class="osc-btn" style="width: 100%;">🎵 Preview Full Chord</button>
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <button type="button" id="createCustomChord" class="osc-btn" style="width: 100%; background: #059669;">Create Custom Chord</button>
                                </div>
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                        </div>
                    </div>
                `;
                
                // Add event listeners for preset chord selection
                modal.querySelectorAll('.add-chord-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const chordData = JSON.parse(e.target.dataset.chord);
                        this.addChordColumn(chordData);
                        modal.remove();
                    });
                });
                
                // Add event listeners for custom chord creation
                const previewButtons = modal.querySelectorAll('.preview-btn');
                previewButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const note = parseInt(e.target.dataset.note);
                        this.previewNote(note);
                    });
                });
                
                const previewChordBtn = modal.querySelector('#previewChord');
                previewChordBtn.addEventListener('click', () => {
                    this.previewSelectedChord(modal);
                });
                
                const createCustomBtn = modal.querySelector('#createCustomChord');
                createCustomBtn.addEventListener('click', () => {
                    this.createCustomChordFromModal(modal);
                });
                
                document.body.appendChild(modal);
                
                // Close on ESC
                const closeOnEsc = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', closeOnEsc);
                    }
                };
                document.addEventListener('keydown', closeOnEsc);
            }

            getNoteNameFromSemitone(semitone) {
                const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                return notes[semitone];
            }

            previewNote(semitone) {
                // Calculate frequency for the note (using C4 as base)
                const baseFreq = 261.63; // C4
                const frequency = baseFreq * Math.pow(2, semitone / 12);
                
                // Play the note briefly
                this.playFrequency(frequency, 0.5); // 0.5 second duration
                
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 500);
            }

            previewSelectedChord(modal) {
                const selectedNotes = Array.from(modal.querySelectorAll('.note-checkbox:checked'))
                    .map(cb => parseInt(cb.value))
                    .sort((a, b) => a - b);
                
                if (selectedNotes.length === 0) {
                    alert('Please select at least one note to preview.');
                    return;
                }
                
                // Play all selected notes as a chord
                const baseFreq = 261.63; // C4
                selectedNotes.forEach(semitone => {
                    const frequency = baseFreq * Math.pow(2, semitone / 12);
                    this.playFrequency(frequency, 1.0); // 1 second duration
                });
                
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 1000);
            }

            createCustomChordFromModal(modal) {
                const chordName = modal.querySelector('#customChordName').value.trim();
                const selectedNotes = Array.from(modal.querySelectorAll('.note-checkbox:checked'))
                    .map(cb => parseInt(cb.value))
                    .sort((a, b) => a - b);
                
                if (!chordName) {
                    alert('Please enter a chord name.');
                    return;
                }
                
                if (selectedNotes.length === 0) {
                    alert('Please select at least one note.');
                    return;
                }
                
                // Create custom chord data
                const customChordData = {
                    name: chordName,
                    extensions: [], // Custom chords don't use extensions
                    intervals: selectedNotes,
                    isCustomPattern: true
                };
                
                this.addChordColumn(customChordData);
                modal.remove();
            }

            addChordColumn(chordData) {
                if (chordData.isCustomPattern) {
                    // Handle custom chord with specific intervals
                    if (!this.customChords) this.customChords = [];
                    
                    const customChord = {
                        name: chordData.name,
                        notes: chordData.intervals
                    };
                    
                    this.customChords.push(customChord);
                    localStorage.setItem('microtonalCustomChords', JSON.stringify(this.customChords));
                } else {
                    // Handle standard chord extension
                    this.chordExtensions.push({ ...chordData });
                    this.saveChordConfiguration();
                }
                
                // Regenerate columns
                this.generateExtensionColumns();
                
                console.log(`Added new chord column: ${chordData.name}`);
            }

            exportChordConfiguration() {
                const config = {
                    chordExtensions: this.chordExtensions,
                    customChords: this.customChords || [],
                    hiddenColumns: this.hiddenColumns || [],
                    exportDate: new Date().toISOString(),
                    version: '1.0'
                };
                
                const dataStr = JSON.stringify(config, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `microtonal-omnichord-config-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
            }

            importChordConfiguration(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const config = JSON.parse(e.target.result);
                        
                        if (config.chordExtensions) {
                            this.chordExtensions = config.chordExtensions;
                        }
                        if (config.customChords) {
                            this.customChords = config.customChords;
                            localStorage.setItem('microtonalCustomChords', JSON.stringify(this.customChords));
                        }
                        if (config.hiddenColumns) {
                            this.hiddenColumns = config.hiddenColumns;
                            localStorage.setItem('microtonalHiddenColumns', JSON.stringify(this.hiddenColumns));
                        }
                        
                        this.saveChordConfiguration();
                        this.generateExtensionColumns();
                        
                        alert('Configuration imported successfully!');
                    } catch (error) {
                        alert('Error importing configuration: Invalid file format');
                        console.error('Import error:', error);
                    }
                };
                reader.readAsText(file);
                
                // Reset file input
                event.target.value = '';
            }

            resetToDefaults() {
                if (confirm('Reset to default chord configuration? This will remove all custom columns and clear any cached issues.')) {
                    // Clear all storage to fix any cached issues like "Maj Copy"
                    localStorage.removeItem('microtonalChordConfig');
                    localStorage.removeItem('microtonalCustomChords');
                    localStorage.removeItem('microtonalHiddenColumns');
                    
                    // Reset to clean defaults
                    this.chordExtensions = [...this.defaultChordExtensions];
                    this.customChords = [];
                    this.hiddenColumns = [];
                    this.currentEditingColumn = null;
                    
                    // Force complete regeneration
                    this.generateExtensionColumns();
                    
                    alert('Reset to default configuration - any cached issues should be resolved');
                }
            }

            hideColumn() {
                if (!this.hiddenColumns) this.hiddenColumns = [];
                const columnId = this.currentEditingColumn.id || this.currentEditingColumn.name.toLowerCase();
                
                if (!this.hiddenColumns.includes(columnId)) {
                    this.hiddenColumns.push(columnId);
                    localStorage.setItem('microtonalHiddenColumns', JSON.stringify(this.hiddenColumns));
                    this.generateExtensionColumns();
                }
            }

            addToFavorites() {
                if (!this.favoriteChords) this.favoriteChords = [];
                
                const favoriteChord = {
                    name: this.currentEditingColumn.name,
                    originalName: this.currentEditingColumn.originalName || this.currentEditingColumn.name,
                    extensions: this.currentEditingColumn.extensions || [],
                    quality: this.currentEditingColumn.quality,
                    intervals: this.currentEditingColumn.intervals,
                    root: this.currentRoot, // Store current root note
                    isCustom: this.currentEditingColumn.isCustom || false,
                    addedAt: Date.now()
                };
                
                // Check if already in favorites
                const exists = this.favoriteChords.some(fav => 
                    fav.name === favoriteChord.name && 
                    fav.quality === favoriteChord.quality &&
                    fav.root === favoriteChord.root
                );
                
                if (!exists) {
                    this.favoriteChords.push(favoriteChord);
                    localStorage.setItem('microtonalFavoriteChords', JSON.stringify(this.favoriteChords));
                    this.generateExtensionColumns();
                    console.log(`Added "${favoriteChord.name}" to favorites with root ${this.getNoteNames()[favoriteChord.root]}`);
                } else {
                    alert('This chord with this root is already in favorites!');
                }
            }

            addCurrentChordToFavorites() {
                const chordName = document.getElementById('customChordName').value.trim();
                if (!chordName) {
                    alert('Please enter a chord name first!');
                    return;
                }
                
                const selectedNotes = this.getSelectedNotes();
                if (selectedNotes.length === 0) {
                    alert('Please select at least one note!');
                    return;
                }
                
                if (!this.favoriteChords) this.favoriteChords = [];
                
                const favoriteChord = {
                    name: chordName,
                    originalName: chordName,
                    extensions: [],
                    quality: this.currentQuality,
                    intervals: selectedNotes,
                    notes: selectedNotes,
                    root: this.currentRoot,
                    isCustom: true,
                    addedAt: Date.now(),
                    tuning: this.currentTuning
                };
                
                // Check if already in favorites
                const exists = this.favoriteChords.some(fav => 
                    fav.name === favoriteChord.name && 
                    fav.quality === favoriteChord.quality &&
                    fav.root === favoriteChord.root
                );
                
                if (!exists) {
                    this.favoriteChords.push(favoriteChord);
                    localStorage.setItem('microtonalFavoriteChords', JSON.stringify(this.favoriteChords));
                    this.updateFavoritesDisplay();
                    console.log(`Added "${favoriteChord.name}" to favorites`);
                    alert(`Added "${favoriteChord.name}" to favorites!`);
                } else {
                    alert('This chord is already in favorites!');
                }
            }
            
            updateFavoritesDisplay() {
                const favoritesList = document.getElementById('favoriteChordsList');
                if (!favoritesList) return;
                
                favoritesList.innerHTML = '';
                
                if (!this.favoriteChords || this.favoriteChords.length === 0) {
                    favoritesList.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #8fb3d3; font-style: italic; padding: 20px;">No favorite chords yet</div>';
                    return;
                }
                
                this.favoriteChords.forEach((chord, index) => {
                    const chordElement = document.createElement('div');
                    chordElement.style.cssText = `
                        background: linear-gradient(135deg, #f39c12, #e67e22);
                        border: 1px solid #d68910;
                        border-radius: 6px;
                        padding: 8px;
                        text-align: center;
                        cursor: pointer;
                        font-size: 12px;
                        color: #fff;
                        position: relative;
                        transition: all 0.2s ease;
                        user-select: none;
                    `;
                    
                    chordElement.innerHTML = `
                        <div style="font-weight: bold;">${chord.name}</div>
                        <div style="font-size: 10px; opacity: 0.8;">${this.getNoteNames()[chord.root] || 'C'} ${chord.quality}</div>
                        <div style="position: absolute; top: 2px; right: 2px; background: rgba(0,0,0,0.3); border-radius: 50%; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; font-size: 10px; cursor: pointer;" class="remove-favorite" data-index="${index}">×</div>
                    `;
                    
                    // Play chord on click
                    chordElement.addEventListener('click', (e) => {
                        if (e.target.classList.contains('remove-favorite')) return;
                        this.playChord(chord.intervals || chord.notes, chord.root);
                    });
                    
                    // Hover effects
                    chordElement.addEventListener('mouseenter', () => {
                        chordElement.style.transform = 'scale(1.05)';
                        chordElement.style.boxShadow = '0 4px 12px rgba(243, 156, 18, 0.4)';
                    });
                    
                    chordElement.addEventListener('mouseleave', () => {
                        chordElement.style.transform = 'scale(1)';
                        chordElement.style.boxShadow = 'none';
                    });
                    
                    favoritesList.appendChild(chordElement);
                });
                
                // Add remove functionality
                favoritesList.addEventListener('click', (e) => {
                    if (e.target.classList.contains('remove-favorite')) {
                        const index = parseInt(e.target.dataset.index);
                        this.removeFavoriteChord(index);
                    }
                });
            }
            
            removeFavoriteChord(index) {
                if (confirm('Remove this chord from favorites?')) {
                    this.favoriteChords.splice(index, 1);
                    localStorage.setItem('microtonalFavoriteChords', JSON.stringify(this.favoriteChords));
                    this.updateFavoritesDisplay();
                }
            }
            
            getSelectedNotes() {
                const selector = document.getElementById('edoNoteSelector');
                if (!selector) return [];
                
                const selectedButtons = selector.querySelectorAll('.note-btn.selected');
                return Array.from(selectedButtons).map(btn => parseInt(btn.dataset.note));
            }

            removeFromFavorites() {
                if (this.currentEditingColumn.favoriteIndex !== undefined) {
                    const favoriteName = this.favoriteChords[this.currentEditingColumn.favoriteIndex].name;
                    this.favoriteChords.splice(this.currentEditingColumn.favoriteIndex, 1);
                    localStorage.setItem('microtonalFavoriteChords', JSON.stringify(this.favoriteChords));
                    this.generateExtensionColumns();
                    console.log(`Removed "${favoriteName}" from favorites`);
                }
            }

            addToPalette() {
                if (!this.paletteChords) this.paletteChords = [];
                
                const noteNames = this.getNoteNames();
                const rootName = noteNames[this.currentRoot] || this.currentRoot;
                
                const paletteChord = {
                    name: this.currentEditingColumn.name,
                    fullName: `${rootName}${this.currentEditingColumn.name}`,
                    extensions: this.currentEditingColumn.extensions || [],
                    quality: this.currentEditingColumn.quality || 'major',
                    rootNote: this.currentRoot,
                    originalName: this.currentEditingColumn.originalName || this.currentEditingColumn.name,
                    isCustom: this.currentEditingColumn.isCustom || false,
                    intervals: this.currentEditingColumn.intervals || [],
                    root: this.currentRoot
                };
                
                // Always allow adding chords to create sequences
                this.paletteChords.push(paletteChord);
                localStorage.setItem('microtonalPaletteChords', JSON.stringify(this.paletteChords));
                this.renderPaletteChords();
                console.log(`Added "${paletteChord.fullName}" to palette`);
            }

            deleteColumn() {
                console.log('🔥 deleteColumn called, currentEditingColumn:', this.currentEditingColumn);
                
                if (!this.currentEditingColumn) {
                    console.error('🔥 No currentEditingColumn set for deleteColumn');
                    alert('Error: No column selected for deletion');
                    return;
                }
                
                if (this.currentEditingColumn.isCustom) {
                    console.log('🔥 Deleting custom chord:', this.currentEditingColumn.name);
                    if (confirm(`Delete custom column "${this.currentEditingColumn.name}"?`)) {
                        const index = this.customChords.findIndex(chord => chord.name === this.currentEditingColumn.name);
                        console.log('🔥 Found custom chord at index:', index);
                        if (index !== -1) {
                            this.customChords.splice(index, 1);
                            localStorage.setItem('microtonalCustomChords', JSON.stringify(this.customChords));
                            console.log('🔥 Custom chord deleted, regenerating columns');
                            this.generateExtensionColumns();
                        } else {
                            console.error('🔥 Custom chord not found for deletion');
                            alert('Error: Custom chord not found for deletion');
                        }
                    }
                } else {
                    console.log('🔥 Deleting standard chord:', this.currentEditingColumn.originalName || this.currentEditingColumn.name);
                    // Allow deleting standard chord columns too
                    if (confirm(`Delete column "${this.currentEditingColumn.originalName || this.currentEditingColumn.name}"? This will remove all 3 flavors (Maj/Neu/Min) permanently.`)) {
                        // Use extension index if available, otherwise find by name
                        let index = -1;
                        if (this.currentEditingColumn.extensionIndex !== undefined) {
                            index = this.currentEditingColumn.extensionIndex;
                            console.log('🔥 Using extensionIndex:', index);
                        } else {
                            const searchName = this.currentEditingColumn.originalName || this.currentEditingColumn.name;
                            index = this.chordExtensions.findIndex(ext => 
                                ext.name === searchName || ext.name.toLowerCase() === searchName.toLowerCase()
                            );
                            console.log('🔥 Found extension by name at index:', index);
                        }
                        
                        if (index !== -1 && index < this.chordExtensions.length) {
                            console.log('🔥 Deleting chord extension at index:', index);
                            this.chordExtensions.splice(index, 1);
                            this.saveChordConfiguration();
                            this.generateExtensionColumns();
                            console.log(`🔥 Deleted chord extension at index ${index}`);
                        } else {
                            console.error('🔥 Could not find chord extension to delete:', this.currentEditingColumn);
                            alert('Error: Could not find chord extension to delete');
                        }
                    }
                }
            }

            updateColumnInStorage() {
                if (this.currentEditingColumn.isCustom) {
                    const index = this.customChords.findIndex(chord => chord.name === this.currentEditingColumn.originalName || this.currentEditingColumn.name);
                    if (index !== -1) {
                        this.customChords[index].name = this.currentEditingColumn.name;
                        if (this.currentEditingColumn.intervals) {
                            this.customChords[index].notes = this.currentEditingColumn.intervals;
                        }
                        localStorage.setItem('microtonalCustomChords', JSON.stringify(this.customChords));
                    }
                }
            }

            getNotesFromExtensions(extensions) {
                // Convert chord extensions to note intervals
                const intervals = this.getChordIntervals(extensions);
                return intervals;
            }

            // Column Management Functions
            showColumnModal() {
                const modal = document.getElementById('columnModal');
                const columnList = document.getElementById('columnList');
                columnList.innerHTML = '';

                // Add standard chord types matching the chordExtensions array
                const standardColumns = ['maj', 'min', '6', '7', 'maj7', '9', 'sus2', 'sus4', 'add9', '13#11', '7#9', 'n7', 'n11'];
                const chordNames = ['Major Triad', 'Minor Triad', '6th', '7th', 'Major 7th', '9th', 'Sus2', 'Sus4', 'Add9', '13#11', '7#9', 'Neutral 7th', 'Neutral 11th'];
                
                standardColumns.forEach((chord, index) => {
                    const isHidden = this.hiddenColumns && this.hiddenColumns.includes(chord);
                    const div = document.createElement('div');
                    div.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 5px; background: #16213e; border-radius: 5px;';
                    div.innerHTML = `
                        <input type="checkbox" id="col_${chord}" ${isHidden ? '' : 'checked'}>
                        <label for="col_${chord}" style="flex: 1;">${chordNames[index]}</label>
                    `;
                    
                    div.querySelector('input').addEventListener('change', (e) => {
                        this.toggleColumnVisibility(chord, e.target.checked);
                    });
                    
                    columnList.appendChild(div);
                });

                // Add custom chords if any exist
                if (this.customChords && this.customChords.length > 0) {
                    this.customChords.forEach((customChord, index) => {
                        const isHidden = this.hiddenColumns && this.hiddenColumns.includes(`custom_${index}`);
                        const div = document.createElement('div');
                        div.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 5px; background: #16213e; border-radius: 5px;';
                        div.innerHTML = `
                            <input type="checkbox" id="col_custom_${index}" ${isHidden ? '' : 'checked'}>
                            <label for="col_custom_${index}" style="flex: 1;">${customChord.name}</label>
                            <button class="osc-btn" style="padding: 2px 8px; font-size: 10px;" onclick="omnichord.deleteCustomChord(${index})">Delete</button>
                        `;
                        
                        div.querySelector('input').addEventListener('change', (e) => {
                            this.toggleColumnVisibility(`custom_${index}`, e.target.checked);
                        });
                        
                        columnList.appendChild(div);
                    });
                }

                modal.style.display = 'block';
            }

            showCustomChordModal() {
                const modal = document.getElementById('customChordModal');
                const edoNoteSelector = document.getElementById('edoNoteSelector');
                edoNoteSelector.innerHTML = '';
                
                // Update favorites display
                this.updateFavoritesDisplay();
                
                // Create note selection grid based on current EDO
                const edoSize = this.gamelanMode ? 7 : this.currentTuning;
                
                for (let i = 0; i < edoSize; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'osc-btn';
                    btn.style.cssText = 'padding: 8px 4px; font-size: 11px; min-height: 40px; display: flex; flex-direction: column; align-items: center; justify-content: center;';
                    btn.dataset.note = i;
                    
                    // Calculate cents for interval display
                    let cents;
                    if (this.gamelanMode) {
                        cents = this.gamelanScale[i] || 0;
                    } else {
                        cents = Math.round((i * 1200) / this.currentTuning);
                    }
                    
                    // Determine highlighting based on interval type
                    let bgColor = '#2a4858'; // Default background
                    let borderColor = '#4a6870';
                    let noteText = i.toString();
                    let centsText = `${cents}¢`;
                    
                    if (this.currentTuning === 12) {
                        // 12-EDO: highlight chromatic notes
                        if ([0, 2, 4, 5, 7, 9, 11].includes(i)) {
                            bgColor = '#4a90e2'; // Major/Minor scale tones
                            borderColor = '#6aa0b0';
                        }
                    } else if (this.currentTuning === 24) {
                        // 24-EDO: highlight quarter-tone relationships
                        if (i % 2 === 0) {
                            bgColor = '#4a90e2'; // 12-EDO equivalent
                            borderColor = '#6aa0b0';
                        } else {
                            bgColor = '#f39c12'; // Quarter-tones
                            borderColor = '#e67e22';
                        }
                    } else if (this.currentTuning === 31) {
                        // 31-EDO: highlight just intonation approximations
                        if ([0, 5, 10, 13, 18, 23, 28].includes(i)) {
                            bgColor = '#4a90e2'; // JI major scale approximation
                            borderColor = '#6aa0b0';
                        } else if ([0, 8, 13, 16, 21, 26, 28].includes(i)) {
                            bgColor = '#27ae60'; // JI minor scale approximation
                            borderColor = '#2ecc71';
                        }
                    } else if (this.currentTuning === 53) {
                        // 53-EDO: highlight various scales
                        if ([0, 9, 17, 22, 31, 40, 48].includes(i)) {
                            bgColor = '#4a90e2'; // Diatonic approximation
                            borderColor = '#6aa0b0';
                        } else if ([0, 14, 22, 27, 36, 44, 48].includes(i)) {
                            bgColor = '#27ae60'; // Alternative scales
                            borderColor = '#2ecc71';
                        }
                    }
                    
                    btn.style.background = bgColor;
                    btn.style.borderColor = borderColor;
                    btn.innerHTML = `<div style="font-weight: bold;">${noteText}</div><div style="font-size: 9px; opacity: 0.8;">${centsText}</div>`;
                    
                    btn.addEventListener('click', () => {
                        btn.classList.toggle('active');
                        if (btn.classList.contains('active')) {
                            btn.style.background = '#e74c3c';
                            btn.style.borderColor = '#c0392b';
                        } else {
                            btn.style.background = bgColor;
                            btn.style.borderColor = borderColor;
                        }
                    });
                    
                    edoNoteSelector.appendChild(btn);
                }
                
                modal.style.display = 'block';
            }

            toggleColumnVisibility(columnId, visible) {
                if (visible) {
                    this.hiddenColumns = this.hiddenColumns.filter(id => id !== columnId);
                } else {
                    if (!this.hiddenColumns.includes(columnId)) {
                        this.hiddenColumns.push(columnId);
                    }
                }
                localStorage.setItem('microtonalHiddenColumns', JSON.stringify(this.hiddenColumns));
                this.generateExtensionColumns();
            }

            saveCustomChord() {
                const name = document.getElementById('customChordName').value.trim();
                const selectedNotes = Array.from(document.querySelectorAll('#edoNoteSelector .osc-btn.active'))
                    .map(btn => parseInt(btn.dataset.note))
                    .sort((a, b) => a - b);

                if (!name || selectedNotes.length === 0) {
                    alert('Please enter a chord name and select at least one note.');
                    return;
                }

                const customChord = { 
                    name, 
                    intervals: selectedNotes,
                    tuning: this.currentTuning,
                    gamelanMode: this.gamelanMode
                };
                
                this.customChords.push(customChord);
                localStorage.setItem('microtonalCustomChords', JSON.stringify(this.customChords));
                
                document.getElementById('customChordModal').style.display = 'none';
                document.getElementById('customChordName').value = '';
                
                // Clear selections
                document.querySelectorAll('#edoNoteSelector .osc-btn.active').forEach(btn => {
                    btn.classList.remove('active');
                    btn.style.background = btn.dataset.originalBg || '#2a4858';
                    btn.style.borderColor = btn.dataset.originalBorder || '#4a6870';
                });
                
                this.generateExtensionColumns();
            }

            deleteCustomChord(index) {
                if (confirm('Delete this custom chord?')) {
                    this.customChords.splice(index, 1);
                    localStorage.setItem('microtonalCustomChords', JSON.stringify(this.customChords));
                    this.generateExtensionColumns();
                    this.showColumnModal(); // Refresh the modal
                }
            }

            updateChordDisplay() {
                // Chord display removed for cleaner interface
            }

            translateSemitoneToTuning(semitone) {
                // Translate 12-TET semitone to nearest step in current tuning
                // This ensures custom chords sound close in different tunings
                const exactStep = (semitone / 12) * this.currentTuning;
                return Math.round(exactStep) % this.currentTuning;
            }

            generateRootButtons() {
                const rootGrid = document.getElementById('rootGrid');
                rootGrid.innerHTML = '';
                
                const noteNames = this.getNoteNames();
                
                for (let i = 0; i < this.currentTuning; i++) {
                    const btn = document.createElement('div');
                    btn.className = 'root-btn';
                    if (i === this.currentRoot) btn.classList.add('active');
                    btn.textContent = noteNames[i] || i;
                    btn.dataset.root = i;
                    
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('#rootGrid .root-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentRoot = i;
                        this.generateExtensionColumns();
                        this.updateChordDisplay();
                    });
                    
                    rootGrid.appendChild(btn);
                }
            }

            getNoteNames() {
                if (this.gamelanMode) {
                    // Gamelan pelog note names
                    return ['Bem', 'Gulu', 'Dada', 'Pelog', 'Lima', 'Nem', 'Barang'];
                }
                
                const names12 = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                if (this.currentTuning === 12) return names12;
                
                // For small EDO systems, use simple numbering
                if (this.currentTuning <= 17) {
                    const names = [];
                    for (let i = 0; i < this.currentTuning; i++) {
                        names.push(i.toString());
                    }
                    return names;
                }
                
                // For microtonal tunings, create names based on 12-TET with accidentals
                const baseNotes = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
                const microAccidentals = ['', '¼#', '½#', '¾#', '#', '#¼#', '#½#', '#¾#', '##'];
                const names = [];
                
                for (let i = 0; i < this.currentTuning; i++) {
                    // Map each step to nearest 12-TET note with microtonal accidental
                    const centsFromC = (i * 1200) / this.currentTuning;
                    const semitones = centsFromC / 100;
                    
                    // Find nearest base note
                    const baseNoteIndex = Math.floor(semitones / 1.71428571); // 12/7 semitones per base note
                    const baseName = baseNotes[baseNoteIndex % 7];
                    
                    // Calculate deviation in quarter-tones
                    const targetSemitone = semitones;
                    const baseSemitone = this.getBaseSemitone(baseNoteIndex % 7);
                    const deviation = targetSemitone - baseSemitone;
                    
                    // Convert to quarter-tone accidental
                    const quarterTones = Math.round(deviation * 4);
                    const accidentalIndex = Math.max(0, Math.min(8, quarterTones + 4));
                    
                    names.push(baseName + microAccidentals[accidentalIndex]);
                }
                
                return names;
            }

            getBaseSemitone(noteIndex) {
                // C=0, D=2, E=4, F=5, G=7, A=9, B=11
                const semitones = [0, 2, 4, 5, 7, 9, 11];
                return semitones[noteIndex];
            }

            getCentValue(step) {
                if (this.gamelanMode) {
                    // Gamelan pelog scale approximation in cents from root
                    const gamelanCents = [0, 136, 348, 560, 704, 840, 1056]; // 7-note pelog scale
                    return gamelanCents[step % 7] + (Math.floor(step / 7) * 1200);
                }
                return (step * 1200) / this.currentTuning;
            }

            getFrequency(step, octave = 4) {
                const cents = this.getCentValue(step);
                const baseFreq = 440 * Math.pow(2, (octave - 4)); // A4 = 440Hz
                return baseFreq * Math.pow(2, cents / 1200);
            }

            generateChordPattern(extensions) {
                // Generate a pattern of chord intervals
                const intervals = this.getChordIntervals(extensions);
                return intervals;
            }

            getTuningDivisions() {
                return this.currentTuning;
            }

            getNoteName(noteIndex) {
                const noteNames = this.getNoteNames();
                return noteNames[noteIndex] || noteIndex.toString();
            }

            getChordIntervals(extensions = []) {
                let intervals = [0]; // Root
                
                // Base triad
                switch (this.currentQuality) {
                    case 'major':
                        intervals.push(Math.round(4 * this.currentTuning / 12)); // Major third
                        intervals.push(Math.round(7 * this.currentTuning / 12)); // Perfect fifth
                        break;
                    case 'minor':
                        intervals.push(Math.round(3 * this.currentTuning / 12)); // Minor third
                        intervals.push(Math.round(7 * this.currentTuning / 12)); // Perfect fifth
                        break;
                    case 'neutral':
                        intervals.push(Math.round(3.5 * this.currentTuning / 12)); // Neutral third
                        intervals.push(Math.round(7 * this.currentTuning / 12)); // Perfect fifth
                        break;
                }
                
                // Apply extensions
                extensions.forEach(ext => {
                    switch (ext) {
                        case '6':
                            intervals.push(Math.round(9 * this.currentTuning / 12));
                            break;
                        case '7':
                            intervals.push(Math.round(10 * this.currentTuning / 12));
                            break;
                        case 'maj7':
                            intervals.push(Math.round(11 * this.currentTuning / 12));
                            break;
                        case '9':
                            intervals.push(Math.round(10 * this.currentTuning / 12)); // Add 7th first
                            intervals.push(Math.round(14 * this.currentTuning / 12)); // Then 9th
                            break;
                        case 'sus2':
                            intervals = intervals.filter(i => i !== Math.round(4 * this.currentTuning / 12) && i !== Math.round(3 * this.currentTuning / 12) && i !== Math.round(3.5 * this.currentTuning / 12));
                            intervals.push(Math.round(2 * this.currentTuning / 12));
                            break;
                        case 'sus4':
                            intervals = intervals.filter(i => i !== Math.round(4 * this.currentTuning / 12) && i !== Math.round(3 * this.currentTuning / 12) && i !== Math.round(3.5 * this.currentTuning / 12));
                            intervals.push(Math.round(5 * this.currentTuning / 12));
                            break;
                        case 'add9':
                            intervals.push(Math.round(14 * this.currentTuning / 12));
                            break;
                        case '13':
                            intervals.push(Math.round(10 * this.currentTuning / 12)); // Add 7th
                            intervals.push(Math.round(21 * this.currentTuning / 12)); // Add 13th
                            break;
                        case '#11':
                            intervals.push(Math.round(18 * this.currentTuning / 12)); // #11
                            break;
                        case '7#9':
                            intervals.push(Math.round(10 * this.currentTuning / 12)); // 7th
                            intervals.push(Math.round(15 * this.currentTuning / 12)); // #9 (raised 9th)
                            break;
                        case '#9':
                            intervals.push(Math.round(15 * this.currentTuning / 12)); // #9 (raised 9th)
                            break;
                        case 'n7':
                            intervals.push(Math.round(10.5 * this.currentTuning / 12)); // neutral 7th
                            break;
                        case 'n11':
                            intervals.push(Math.round(16.5 * this.currentTuning / 12)); // neutral 11th
                            break;
                    }
                });
                
                return [...new Set(intervals)].sort((a, b) => a - b);
            }

            generateExtensionColumns() {
                console.log('Generating extension columns for tuning:', this.currentTuning);
                const container = document.getElementById('extensionColumns');
                
                // Clear container completely to remove any leftover columns
                container.innerHTML = '';
                container.style.display = 'flex';
                container.style.gap = '0px';
                container.style.width = '100%';
                container.style.height = '100%';
                
                const noteNames = this.getNoteNames();
                const qualities = ['major', 'neutral', 'minor']; // Major (blue), Neutral (green), Minor (red)
                const qualityShorts = ['Maj', 'Neu', 'Min'];
                const qualityColors = [
                    { bg: '#1e40af', border: '#3b82f6' },  // Blue for Major
                    { bg: '#059669', border: '#10b981' }, // Green for Neutral  
                    { bg: '#dc2626', border: '#ef4444' }  // Red for Minor
                ];
                
                // Initialize hiddenColumns if not exists
                if (!this.hiddenColumns) {
                    this.hiddenColumns = [];
                }
                
                // Map chord extensions to identifiers for hiding
                const chordIds = this.chordExtensions.map((chord, index) => {
                    // Create unique IDs for all chord types including newly added ones
                    const id = chord.name.toLowerCase().replace(/\s+/g, '_');
                    console.log(`Mapping chord ${index}: "${chord.name}" -> ID: "${id}"`);
                    return id;
                });
                
                // Filter visible chord extensions
                const visibleExtensions = this.chordExtensions.filter((chordExt, index) => {
                    const chordId = chordIds[index];
                    const isVisible = !this.hiddenColumns.includes(chordId);
                    console.log(`Extension ${index}: "${chordExt.name}" (ID: ${chordId}) - Visible: ${isVisible}`);
                    return isVisible;
                });
                
                console.log('Visible extensions:', visibleExtensions.length);
                
                // Create 3 major sections (one for each quality) that fill the width equally
                qualities.forEach((quality, qualityIndex) => {
                    // Create a section container for this quality
                    const qualitySection = document.createElement('div');
                    qualitySection.className = 'quality-section';
                    qualitySection.style.flex = '1'; // Each quality takes equal width
                    qualitySection.style.display = 'flex';
                    qualitySection.style.gap = '0';
                    qualitySection.style.height = '100%';
                    
                    // Add colored border to distinguish sections
                    qualitySection.style.borderLeft = `4px solid ${qualityColors[qualityIndex].border}`;
                    
                    // Add all visible chord extensions for this quality
                    visibleExtensions.forEach((chordExt, extensionIndex) => {
                        const column = document.createElement('div');
                        column.className = 'extension-column';
                        column.dataset.chordType = chordIds[this.chordExtensions.indexOf(chordExt)];
                        column.style.flex = '1'; // Each column takes equal width within its quality section
                        column.style.height = '100%';
                        column.style.border = '1px solid ' + qualityColors[qualityIndex].border;
                        column.style.borderRadius = '0';
                        column.style.margin = '0';
                        column.style.padding = '0';
                        
                        // Create header with quality prefix and color coding
                        const header = document.createElement('div');
                        header.className = 'extension-header';
                        const qualityPrefix = qualityShorts[qualityIndex];
                        header.textContent = chordExt.name === 'Triad' ? qualityPrefix : `${qualityPrefix}${chordExt.name}`;
                        
                        // Add simple left-click handler for context menu
                        header.addEventListener('click', (e) => {
                            console.log('🔥 REGULAR HEADER CLICKED:', chordExt.name, 'Quality:', quality);
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            
                            // Direct call to global omnichord instance
                            if (window.omnichord && window.omnichord.showColumnContextMenu) {
                                const currentExtensionIndex = this.chordExtensions.indexOf(chordExt);
                                const columnData = {
                                    name: header.textContent,
                                    extensions: chordExt.extensions || [],
                                    quality: quality,
                                    id: chordIds[currentExtensionIndex],
                                    isCustom: false,
                                    originalName: chordExt.name,
                                    extensionIndex: currentExtensionIndex
                                };
                                
                                console.log('🔥 Calling showColumnContextMenu with:', columnData);
                                window.omnichord.showColumnContextMenu(e.clientX, e.clientY, columnData);
                            } else {
                                console.error('🔥 omnichord instance not available!');
                            }
                        });
                        
                        // Add right-click handler too
                        header.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            console.log('Header RIGHT-CLICKED:', chordExt.name, 'Quality:', quality);
                            
                            const currentExtensionIndex = this.chordExtensions.indexOf(chordExt);
                            const columnData = {
                                name: header.textContent,
                                extensions: chordExt.extensions || [],
                                quality: quality,
                                id: chordIds[currentExtensionIndex],
                                isCustom: false,
                                originalName: chordExt.name,
                                extensionIndex: currentExtensionIndex
                            };
                            
                            console.log('Showing context menu for right-click:', columnData);
                            this.showColumnContextMenu(e.clientX, e.clientY, columnData);
                        });
                        
                        // Add left-click handler for header (same as context menu)
                        header.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            
                            console.log('Header LEFT-CLICKED:', chordExt.name, 'Quality:', quality);
                            
                            const currentExtensionIndex = this.chordExtensions.indexOf(chordExt);
                            const columnData = {
                                name: header.textContent,
                                extensions: chordExt.extensions || [],
                                quality: quality,
                                id: chordIds[currentExtensionIndex],
                                isCustom: false,
                                originalName: chordExt.name,
                                extensionIndex: currentExtensionIndex
                            };
                            
                            console.log('Showing context menu for LEFT CLICK:', columnData);
                            this.showColumnContextMenu(e.clientX, e.clientY, columnData);
                        }, true); // Use capture phase
                        
                        // Color coding by quality (blue/green/red)
                        const qualityColor = qualityColors[qualityIndex];
                        header.style.backgroundColor = qualityColor.bg;
                        header.style.borderColor = qualityColor.border;
                        header.style.color = 'white';
                        header.style.border = `1px solid ${qualityColor.border}`;
                        
                        // Position header on top with highest priority
                        header.style.position = 'relative';
                        header.style.zIndex = '9999';
                        header.style.pointerEvents = 'all';
                        header.style.cursor = 'pointer';
                        header.style.userSelect = 'none';
                        
                        column.appendChild(header);
                        
                        // Create strings container
                        const stringsContainer = document.createElement('div');
                        stringsContainer.className = 'strings-column';
                        
                        // Generate chord intervals for this extension and quality
                        const originalQuality = this.currentQuality;
                        this.currentQuality = quality; // Temporarily set quality
                        const intervals = this.getChordIntervals(chordExt.extensions);
                        this.currentQuality = originalQuality; // Restore original
                        
                        // Generate strings for 7 octaves (2-8) of the chord notes
                        const stringFreqs = [];
                        for (let octave = 2; octave <= 8; octave++) {
                            intervals.forEach(interval => {
                                const step = (this.currentRoot + interval) % this.currentTuning;
                                const freq = this.getFrequency(step, octave);
                                stringFreqs.push({ freq, step, octave, interval });
                            });
                        }
                        
                        // Sort by frequency and create strings
                        stringFreqs.sort((a, b) => a.freq - b.freq);
                        
                        stringFreqs.forEach((stringData, index) => {
                            const string = document.createElement('div');
                            string.className = 'string';
                            string.dataset.frequency = stringData.freq;
                            string.dataset.column = qualityIndex * visibleExtensions.length + extensionIndex; // Unique column index
                            string.dataset.index = `${qualityIndex}-${extensionIndex}-${index}`;
                            
                            // Color strings based on their role in the chord with quality tint
                            let hue = 0;
                            if (stringData.interval === 0) hue = 240; // Root - blue
                            else if (stringData.interval === 2 || stringData.interval === 3) hue = 120; // 3rd - green  
                            else if (stringData.interval === 4) hue = 60; // 5th - yellow
                            else if (stringData.interval === 6) hue = 300; // 6th - magenta
                            else if (stringData.interval === 7) hue = 180; // 7th - cyan
                            else if (stringData.interval === 9) hue = 30; // 9th - orange
                            else hue = 0; // Extensions - red
                            
                            string.style.backgroundColor = `hsl(${hue}, 70%, 50%)`;
                            string.style.opacity = '0.8';
                            string.title = `${noteNames[stringData.step]} - ${stringData.freq.toFixed(1)}Hz`;
                            
                            stringsContainer.appendChild(string);
                        });
                        
                        column.appendChild(stringsContainer);
                        
                        // Add the same high-resolution strumming as custom chords
                        let isStruming = false;
                        let strumStartY = 0;
                        let strumEndY = 0;
                        let lastStrumTime = 0;
                        let lastStrumY = 0;
                        
                        const addStrumming = (element) => {
                            element.addEventListener('mousedown', (e) => {
                                // If clicking on header, show context menu instead of strumming
                                if (e.target.classList.contains('extension-header') || e.target.closest('.extension-header')) {
                                    console.log('Header clicked in strumming handler!');
                                    e.preventDefault();
                                    e.stopPropagation();
                                    
                                    // Find the header element
                                    const header = e.target.classList.contains('extension-header') ? 
                                                 e.target : e.target.closest('.extension-header');
                                    
                                    // Find the parent column
                                    const column = header.closest('.extension-column');
                                    if (!column) return;
                                    
                                    // Get column data
                                    const chordType = column.dataset.chordType;
                                    let columnData = null;
                                    
                                    // Check if it's a custom chord
                                    if (chordType && chordType.startsWith('custom_')) {
                                        const customIndex = parseInt(chordType.replace('custom_', ''));
                                        const customChord = this.customChords[customIndex];
                                        if (customChord) {
                                            columnData = {
                                                name: customChord.name,
                                                extensions: [],
                                                quality: 'custom',
                                                id: chordType,
                                                isCustom: true,
                                                originalName: customChord.name,
                                                customIndex: customIndex,
                                                intervals: customChord.notes
                                            };
                                        }
                                    } else {
                                        // Regular extension chord
                                        const qualitySection = column.closest('.quality-section');
                                        const allQualitySections = Array.from(document.querySelectorAll('.quality-section'));
                                        const qualityIndex = allQualitySections.indexOf(qualitySection);
                                        const qualities = ['major', 'neutral', 'minor'];
                                        const quality = qualities[qualityIndex] || 'major';
                                        
                                        // Find the extension from the chord type ID
                                        const chordIndex = parseInt(chordType);
                                        const chordExt = this.chordExtensions[chordIndex];
                                        
                                        if (chordExt) {
                                            columnData = {
                                                name: header.textContent,
                                                extensions: chordExt.extensions || [],
                                                quality: quality,
                                                id: chordType,
                                                isCustom: false,
                                                originalName: chordExt.name,
                                                extensionIndex: chordIndex
                                            };
                                        }
                                    }
                                    
                                    if (columnData) {
                                        console.log('Showing context menu from strumming handler:', columnData);
                                        this.showColumnContextMenu(e.clientX, e.clientY, columnData);
                                    }
                                    return;
                                }
                                
                                e.preventDefault();
                                isStruming = true;
                                strumStartY = e.clientY;
                                strumEndY = e.clientY;
                                lastStrumY = e.clientY;
                                lastStrumTime = performance.now();
                                element.style.transform = 'scale(1.02)';
                                element.style.borderColor = '#8fb3d3';
                            });
                            
                            element.addEventListener('mousemove', (e) => {
                                if (isStruming) {
                                    const currentTime = performance.now();
                                    const currentY = e.clientY;
                                    const deltaY = Math.abs(currentY - lastStrumY);
                                    const timeDelta = currentTime - lastStrumTime;
                                    
                                    // High-resolution tracking: trigger on 3px movement OR 16ms time (60fps)
                                    if (deltaY >= 3 || timeDelta >= 16) {
                                        strumEndY = currentY;
                                        const chordData = { name: chordExt.name, quality: quality };
                                        this.playChordStrum(column, chordData, lastStrumY, strumEndY);
                                        lastStrumY = currentY;
                                        lastStrumTime = currentTime;
                                    }
                                }
                            });
                            
                            element.addEventListener('mouseup', (e) => {
                                if (isStruming) {
                                    strumEndY = e.clientY;
                                    if (Math.abs(strumEndY - lastStrumY) >= 2) {
                                        const chordData = { name: chordExt.name, quality: quality };
                                        this.playChordStrum(column, chordData, lastStrumY, strumEndY);
                                    }
                                }
                                isStruming = false;
                                element.style.transform = 'scale(1)';
                                element.style.borderColor = qualityColor.border;
                            });
                            
                            element.addEventListener('mouseleave', (e) => {
                                if (isStruming) {
                                    strumEndY = e.clientY;
                                    if (Math.abs(strumEndY - lastStrumY) >= 2) {
                                        const chordData = { name: chordExt.name, quality: quality };
                                        this.playChordStrum(column, chordData, lastStrumY, strumEndY);
                                    }
                                }
                                isStruming = false;
                                element.style.transform = 'scale(1)';
                                element.style.borderColor = qualityColor.border;
                            });
                            
                            // Touch support for mobile with high-resolution tracking
                            element.addEventListener('touchstart', (e) => {
                                // Don't interfere with header touching
                                if (e.target.classList.contains('extension-header') || e.target.closest('.extension-header')) {
                                    return;
                                }
                                e.preventDefault();
                                isStruming = true;
                                strumStartY = e.touches[0].clientY;
                                strumEndY = e.touches[0].clientY;
                                lastStrumY = e.touches[0].clientY;
                                lastStrumTime = performance.now();
                                element.style.transform = 'scale(1.02)';
                                element.style.borderColor = '#8fb3d3';
                            });
                            
                            element.addEventListener('touchmove', (e) => {
                                // Don't interfere with header touching
                                if (e.target.classList.contains('extension-header') || e.target.closest('.extension-header')) {
                                    return;
                                }
                                if (isStruming) {
                                    const currentTime = performance.now();
                                    const currentY = e.touches[0].clientY;
                                    const deltaY = Math.abs(currentY - lastStrumY);
                                    const timeDelta = currentTime - lastStrumTime;
                                    
                                    // High-resolution tracking for touch
                                    if (deltaY >= 2 || timeDelta >= 16) {
                                        strumEndY = currentY;
                                        const chordData = { name: chordExt.name, quality: quality };
                                        this.playChordStrum(column, chordData, lastStrumY, strumEndY);
                                        lastStrumY = currentY;
                                        lastStrumTime = currentTime;
                                    }
                                }
                            });
                            
                            element.addEventListener('touchend', (e) => {
                                // Don't interfere with header touching
                                if (e.target.classList.contains('extension-header') || e.target.closest('.extension-header')) {
                                    return;
                                }
                                if (isStruming && e.changedTouches.length > 0) {
                                    const finalY = e.changedTouches[0].clientY;
                                    if (Math.abs(finalY - lastStrumY) >= 2) {
                                        const chordData = { name: chordExt.name, quality: quality };
                                        this.playChordStrum(column, chordData, lastStrumY, finalY);
                                    }
                                }
                                isStruming = false;
                                element.style.transform = 'scale(1)';
                                element.style.borderColor = qualityColor.border;
                            });
                        };
                        
                        // Apply strumming ONLY to the strings container, NOT the header
                        addStrumming(stringsContainer);
                        
                        qualitySection.appendChild(column);
                    });
                    
                    container.appendChild(qualitySection);
                });

                // Add custom chord columns if any exist
                if (this.customChords && this.customChords.length > 0) {
                    this.customChords.forEach((customChord, customIndex) => {
                        if (this.hiddenColumns.includes(`custom_${customIndex}`)) return;
                        
                        const column = document.createElement('div');
                        column.className = 'extension-column';
                        
                        // Create header for custom chord
                        const header = document.createElement('div');
                        header.className = 'extension-header';
                        header.textContent = customChord.name;
                        header.style.backgroundColor = '#6366f1'; // Purple for custom
                        header.style.borderColor = '#8b5cf6';
                        header.style.color = 'white';
                        header.style.border = '1px solid #8b5cf6';
                        
                        // Position header on top with highest priority
                        header.style.position = 'relative';
                        header.style.zIndex = '9999';
                        header.style.pointerEvents = 'all';
                        header.style.cursor = 'pointer';
                        header.style.userSelect = 'none';
                        
                        // Add simple left-click handler for context menu
                        header.addEventListener('click', (e) => {
                            console.log('🔥 CUSTOM HEADER CLICKED:', customChord.name);
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            
                            // Direct call to global omnichord instance
                            if (window.omnichord && window.omnichord.showColumnContextMenu) {
                                const columnData = {
                                    name: customChord.name,
                                    extensions: [],
                                    quality: 'custom',
                                    id: `custom_${customIndex}`,
                                    isCustom: true,
                                    originalName: customChord.name,
                                    customIndex: customIndex,
                                    intervals: customChord.notes
                                };
                                
                                console.log('🔥 Calling showColumnContextMenu for custom with:', columnData);
                                window.omnichord.showColumnContextMenu(e.clientX, e.clientY, columnData);
                            } else {
                                console.error('🔥 omnichord instance not available for custom!');
                            }
                        });
                        
                        // Add right-click handler too
                        header.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            console.log('Custom header RIGHT-CLICKED:', customChord.name);
                            
                            const columnData = {
                                name: customChord.name,
                                extensions: [],
                                quality: 'custom',
                                id: `custom_${customIndex}`,
                                isCustom: true,
                                originalName: customChord.name,
                                customIndex: customIndex,
                                intervals: customChord.notes
                            };
                            
                            console.log('Showing context menu for custom right-click:', columnData);
                            this.showColumnContextMenu(e.clientX, e.clientY, columnData);
                        });
                        
                        column.appendChild(header);
                        
                        // Create strings container
                        const stringsContainer = document.createElement('div');
                        stringsContainer.className = 'strings-column';
                        
                        // Generate strings for custom chord notes
                        const stringFreqs = [];
                        for (let octave = 2; octave <= 8; octave++) {
                            customChord.notes.forEach(note => {
                                // Translate 12-TET semitone to current tuning's nearest neighbor
                                const translatedStep = this.translateSemitoneToTuning(note);
                                const step = (this.currentRoot + translatedStep) % this.currentTuning;
                                const freq = this.getFrequency(step, octave);
                                stringFreqs.push({ freq, step, octave, note: translatedStep });
                            });
                        }
                        
                        // Sort by frequency and create strings
                        stringFreqs.sort((a, b) => a.freq - b.freq);
                        
                        stringFreqs.forEach((stringData, index) => {
                            const string = document.createElement('div');
                            string.className = 'string';
                            string.dataset.frequency = stringData.freq;
                            string.dataset.column = `custom_${customIndex}`;
                            string.dataset.index = `custom_${customIndex}_${index}`;
                            
                            // Purple theme for custom chords
                            string.style.backgroundColor = '#8b5cf6';
                            string.style.opacity = '0.8';
                            string.title = `${noteNames[stringData.step]} - ${stringData.freq.toFixed(1)}Hz`;
                            
                            stringsContainer.appendChild(string);
                        });
                        
                        column.appendChild(stringsContainer);
                        container.appendChild(column);
                    });
                }
                
                // Re-add touch gestures to newly created elements
                this.addTouchGesturesToElements();
                
                // Add simple mousedown context menu triggers to all extension headers
                this.addSimpleClickHandlers();
            }
            
            addSimpleClickHandlers() {
                console.log('Adding simple click handlers to all extension headers');
                
                // Handle extension column headers
                document.querySelectorAll('.extension-header').forEach(header => {
                    // Remove any existing simple click handler to avoid duplicates
                    if (header.simpleClickAdded) return;
                    header.simpleClickAdded = true;
                    
                    console.log('Adding simple click to header:', header.textContent);
                    
                    header.addEventListener('mousedown', (e) => {
                        console.log('MOUSEDOWN on header:', header.textContent);
                        
                        // Only handle left mouse button
                        if (e.button !== 0) return;
                        
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Find the parent column to get data
                        const column = header.closest('.extension-column');
                        if (!column) {
                            console.error('No parent column found');
                            return;
                        }
                        
                        // Get column data
                        const chordType = column.dataset.chordType;
                        let columnData = null;
                        
                        // Check if it's a custom chord
                        if (chordType && chordType.startsWith('custom_')) {
                            const customIndex = parseInt(chordType.replace('custom_', ''));
                            const customChord = this.customChords[customIndex];
                            if (customChord) {
                                columnData = {
                                    name: customChord.name,
                                    extensions: [],
                                    quality: 'custom',
                                    id: chordType,
                                    isCustom: true,
                                    originalName: customChord.name,
                                    customIndex: customIndex,
                                    intervals: customChord.notes
                                };
                            }
                        } else {
                            // Regular extension chord
                            const qualitySection = column.closest('.quality-section');
                            const allQualitySections = Array.from(document.querySelectorAll('.quality-section'));
                            const qualityIndex = allQualitySections.indexOf(qualitySection);
                            const qualities = ['major', 'neutral', 'minor'];
                            const quality = qualities[qualityIndex] || 'major';
                            
                            // Find the extension from the chord type ID
                            const chordIndex = parseInt(chordType);
                            const chordExt = this.chordExtensions[chordIndex];
                            
                            if (chordExt) {
                                columnData = {
                                    name: header.textContent,
                                    extensions: chordExt.extensions || [],
                                    quality: quality,
                                    id: chordType,
                                    isCustom: false,
                                    originalName: chordExt.name,
                                    extensionIndex: chordIndex
                                };
                            }
                        }
                        
                        if (columnData) {
                            console.log('Showing context menu for mousedown:', columnData);
                            this.showColumnContextMenu(e.clientX, e.clientY, columnData);
                        } else {
                            console.error('Failed to create columnData from mousedown');
                        }
                    });
                    
                    // Also add touchstart for mobile
                    header.addEventListener('touchstart', (e) => {
                        console.log('TOUCHSTART on header:', header.textContent);
                        
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Find the parent column to get data
                        const column = header.closest('.extension-column');
                        if (!column) return;
                        
                        // Get column data (same logic as mousedown)
                        const chordType = column.dataset.chordType;
                        let columnData = null;
                        
                        if (chordType && chordType.startsWith('custom_')) {
                            const customIndex = parseInt(chordType.replace('custom_', ''));
                            const customChord = this.customChords[customIndex];
                            if (customChord) {
                                columnData = {
                                    name: customChord.name,
                                    extensions: [],
                                    quality: 'custom',
                                    id: chordType,
                                    isCustom: true,
                                    originalName: customChord.name,
                                    customIndex: customIndex,
                                    intervals: customChord.notes
                                };
                            }
                        } else {
                            const qualitySection = column.closest('.quality-section');
                            const allQualitySections = Array.from(document.querySelectorAll('.quality-section'));
                            const qualityIndex = allQualitySections.indexOf(qualitySection);
                            const qualities = ['major', 'neutral', 'minor'];
                            const quality = qualities[qualityIndex] || 'major';
                            
                            const chordIndex = parseInt(chordType);
                            const chordExt = this.chordExtensions[chordIndex];
                            
                            if (chordExt) {
                                columnData = {
                                    name: header.textContent,
                                    extensions: chordExt.extensions || [],
                                    quality: quality,
                                    id: chordType,
                                    isCustom: false,
                                    originalName: chordExt.name,
                                    extensionIndex: chordIndex
                                };
                            }
                        }
                        
                        if (columnData) {
                            console.log('Showing context menu for touchstart:', columnData);
                            const touch = e.touches[0];
                            this.showColumnContextMenu(touch.clientX, touch.clientY, columnData);
                        }
                    }, { passive: false });
                });
                
                // Handle palette chord headers
                document.querySelectorAll('.palette-chord .extension-header').forEach(header => {
                    if (header.simplePaletteClickAdded) return;
                    header.simplePaletteClickAdded = true;
                    
                    header.addEventListener('mousedown', (e) => {
                        if (e.button !== 0) return;
                        
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const paletteChord = header.closest('.palette-chord');
                        if (paletteChord) {
                            const chordIndex = parseInt(paletteChord.dataset.chordIndex);
                            const chordData = this.paletteChords[chordIndex];
                            if (chordData) {
                                console.log('Showing palette context menu for mousedown:', chordData);
                                this.showPaletteContextMenu(e.clientX, e.clientY, chordData);
                            }
                        }
                    });
                    
                    header.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const paletteChord = header.closest('.palette-chord');
                        if (paletteChord) {
                            const chordIndex = parseInt(paletteChord.dataset.chordIndex);
                            const chordData = this.paletteChords[chordIndex];
                            if (chordData) {
                                const touch = e.touches[0];
                                this.showPaletteContextMenu(touch.clientX, touch.clientY, chordData);
                            }
                        }
                    }, { passive: false });
                });
            }

            stopAllActiveNotes() {
                // Gradually stop all oscillators with natural release
                this.activeOscillators.forEach((noteInfo, noteId) => {
                    if (noteInfo.envelope && noteInfo.osc) {
                        const currentTime = this.audioContext.currentTime;
                        // Apply release phase
                        noteInfo.envelope.gain.cancelScheduledValues(currentTime);
                        noteInfo.envelope.gain.setValueAtTime(noteInfo.envelope.gain.value, currentTime);
                        noteInfo.envelope.gain.linearRampToValueAtTime(0, currentTime + this.envelope.release);
                        
                        // Stop oscillator after release
                        setTimeout(() => {
                            if (noteInfo.osc) {
                                try {
                                    noteInfo.osc.stop();
                                } catch(e) {}
                            }
                            this.activeOscillators.delete(noteId);
                        }, this.envelope.release * 1000 + 100);
                    }
                });
            }

            handleStringTrigger(event, touchId = null) {
                const elements = document.elementsFromPoint(event.clientX, event.clientY);
                const stringElement = elements.find(el => el.classList.contains('string'));
                
                if (stringElement) {
                    const stringIndex = stringElement.dataset.index;
                    const column = parseInt(stringElement.dataset.column) || stringElement.dataset.column;
                    const trackingSet = touchId !== null ? 
                        this.activeTouches.get(touchId)?.triggeredStrings : 
                        this.triggeredStrings;
                    
                    // Throttle triggering per string to avoid audio spam but maintain responsiveness
                    const now = performance.now();
                    const lastTrigger = stringElement.lastTriggerTime || 0;
                    const minInterval = 10; // 10ms minimum between triggers per string
                    
                    if (now - lastTrigger > minInterval) {
                        this.currentPlayingColumn = column;
                        const frequency = parseFloat(stringElement.dataset.frequency);
                        this.playFrequency(frequency, stringElement);
                        this.updateCurrentChord(column);
                        
                        stringElement.lastTriggerTime = now;
                        
                        // Add to tracking for cleanup
                        if (trackingSet) {
                            trackingSet.add(stringIndex);
                            // Quick removal to allow retriggering
                            setTimeout(() => {
                                trackingSet.delete(stringIndex);
                            }, 20);
                        }
                    }
                }
            }

            updateCurrentChord(column) {
                // Chord display removed for cleaner interface
            }

            playChordStrum(columnElement, chordData, startY, endY) {
                // Get all strings in the column
                const strings = Array.from(columnElement.querySelectorAll('.string'));
                if (strings.length === 0) return;
                
                // Calculate which strings to play based on start and end positions
                const columnRect = columnElement.getBoundingClientRect();
                const relativeStartY = startY - columnRect.top;
                const relativeEndY = endY - columnRect.top;
                
                // Determine strum direction and range
                const strumDown = relativeEndY > relativeStartY;
                const minY = Math.min(relativeStartY, relativeEndY);
                const maxY = Math.max(relativeStartY, relativeEndY);
                
                // Filter strings that fall within the strum range
                const stringsToPlay = strings.filter(string => {
                    const stringRect = string.getBoundingClientRect();
                    const stringY = stringRect.top + stringRect.height / 2 - columnRect.top;
                    return stringY >= minY && stringY <= maxY;
                });
                
                if (stringsToPlay.length === 0) return;
                
                // Sort strings by position for directional strumming
                stringsToPlay.sort((a, b) => {
                    const aY = a.getBoundingClientRect().top;
                    const bY = b.getBoundingClientRect().top;
                    return strumDown ? aY - bY : bY - aY;
                });
                
                // Much faster strum for high-speed playing - 8ms between strings
                const strumDelay = 8; 
                
                stringsToPlay.forEach((string, index) => {
                    setTimeout(() => {
                        const frequency = parseFloat(string.dataset.frequency);
                        if (frequency && !isNaN(frequency)) {
                            this.playFrequency(frequency, string);
                            
                            // Minimal visual feedback for speed
                            string.style.transform = 'scale(1.05)';
                            string.style.boxShadow = '0 0 5px rgba(255, 255, 255, 0.4)';
                            
                            setTimeout(() => {
                                string.style.transform = 'scale(1)';
                                string.style.boxShadow = 'none';
                            }, 100);
                        }
                    }, index * strumDelay);
                });
                
                // Much shorter note duration for clean fast strumming
                setTimeout(() => {
                    stringsToPlay.forEach(string => {
                        const frequency = parseFloat(string.dataset.frequency);
                        if (frequency && !isNaN(frequency)) {
                            this.stopFrequency(frequency, string);
                        }
                    });
                }, 200 + (stringsToPlay.length * strumDelay)); // Very short duration
            }

            playFrequency(frequency, element) {
                // If oscillator already exists, stop it first to prevent overlap
                if (this.activeOscillators.has(frequency)) {
                    this.stopFrequency(frequency, element);
                }
                
                if (!this.audioContext) return;
                
                // Create dual oscillators (or noise sources) with separate envelopes
                let osc1, osc2;
                const osc1Envelope = this.audioContext.createGain();
                const osc2Envelope = this.audioContext.createGain();
                const osc1Gain = this.audioContext.createGain();
                const osc2Gain = this.audioContext.createGain();
                const finalMixer = this.audioContext.createGain();
                
                // Create oscillator 1 (or noise)
                if (this.oscillators.osc1.type === 'noise') {
                    osc1 = this.createNoiseSource();
                } else {
                    osc1 = this.audioContext.createOscillator();
                    osc1.type = this.oscillators.osc1.type;
                    const totalDetune1 = this.oscillators.osc1.detune + this.oscillators.osc1.coarse;
                    const freq1 = frequency * Math.pow(2, this.oscillators.osc1.octave + (totalDetune1 / 1200));
                    osc1.frequency.setValueAtTime(freq1, this.audioContext.currentTime);
                }
                
                // Create oscillator 2 (or noise)
                if (this.oscillators.osc2.type === 'noise') {
                    osc2 = this.createNoiseSource();
                } else {
                    osc2 = this.audioContext.createOscillator();
                    osc2.type = this.oscillators.osc2.type;
                    const totalDetune2 = this.oscillators.osc2.detune + this.oscillators.osc2.coarse;
                    const freq2 = frequency * Math.pow(2, this.oscillators.osc2.octave + (totalDetune2 / 1200));
                    osc2.frequency.setValueAtTime(freq2, this.audioContext.currentTime);
                }
                
                // Set oscillator levels (include master volume in the calculation)
                const totalVolume = this.volume * this.masterVolume;
                osc1Gain.gain.value = this.oscillators.osc1.level * totalVolume;
                osc2Gain.gain.value = this.oscillators.osc2.level * totalVolume;
                
                // Connect oscillators through their individual envelopes
                osc1.connect(osc1Gain);
                osc1Gain.connect(osc1Envelope);
                
                osc2.connect(osc2Gain);
                osc2Gain.connect(osc2Envelope);
                
                // Connect based on mix mode
                if (this.mixMode === 'add') {
                    // Simple addition
                    osc1Envelope.connect(finalMixer);
                    osc2Envelope.connect(finalMixer);
                } else if (this.mixMode === 'ring') {
                    // Ring modulation - osc2 modulates osc1's amplitude
                    const ringMod = this.audioContext.createGain();
                    osc2Envelope.connect(ringMod.gain);
                    osc1Envelope.connect(ringMod);
                    ringMod.connect(finalMixer);
                } else if (this.mixMode === 'fm') {
                    // Frequency modulation - osc2 modulates osc1's frequency
                    if (osc1.frequency) { // Only if osc1 is not noise
                        osc2Gain.gain.value = 100; // FM amount
                        osc2Envelope.connect(osc1.frequency);
                    }
                    osc1Envelope.connect(finalMixer);
                } else {
                    // Default to add
                    osc1Envelope.connect(finalMixer);
                    osc2Envelope.connect(finalMixer);
                }
                
                const currentTime = this.audioContext.currentTime;
                
                // Create panner and apply panning based on mode (BEFORE reverb)
                const panner = this.audioContext.createStereoPanner();
                let panValue = 0; // Default center
                
                switch (this.panning.mode) {
                    case 'frequency':
                        // Pan based on frequency (low = left, high = right)
                        const logFreq = Math.log2(frequency / 220); // A3 as reference
                        panValue = Math.max(-1, Math.min(1, logFreq * 0.3)) * this.panning.width;
                        break;
                    case 'random':
                        // Random panning
                        panValue = (Math.random() * 2 - 1) * this.panning.width;
                        break;
                    case 'rotating':
                        // Rotating panning
                        this.panning.rotationAngle += 0.1;
                        panValue = Math.sin(this.panning.rotationAngle) * this.panning.width;
                        break;
                    case 'alternating':
                        // Alternating left/right
                        this.panning.alternateState = !this.panning.alternateState;
                        panValue = (this.panning.alternateState ? 1 : -1) * this.panning.width;
                        break;
                    default:
                        // Center
                        panValue = 0;
                        break;
                }
                
                panner.pan.setValueAtTime(panValue, currentTime);
                
                // Connect: finalMixer → panner → gainNode (gainNode routes to reverb)
                finalMixer.connect(panner);
                panner.connect(this.gainNode);
                
                // OSC 1 ADSR envelope (master ADSR)
                const osc1AttackTime = currentTime + this.envelope.attack;
                const osc1DecayTime = osc1AttackTime + this.envelope.decay;
                
                osc1Envelope.gain.setValueAtTime(0, currentTime);
                osc1Envelope.gain.linearRampToValueAtTime(1, osc1AttackTime); // Attack
                osc1Envelope.gain.linearRampToValueAtTime(this.envelope.sustain, osc1DecayTime); // Decay to sustain
                
                // OSC 2 ADSR envelope (separate OSC 2 ADSR)
                const osc2AttackTime = currentTime + this.osc2Envelope.attack;
                const osc2DecayTime = osc2AttackTime + this.osc2Envelope.decay;
                
                osc2Envelope.gain.setValueAtTime(0, currentTime);
                osc2Envelope.gain.linearRampToValueAtTime(1, osc2AttackTime); // Attack
                osc2Envelope.gain.linearRampToValueAtTime(this.osc2Envelope.sustain, osc2DecayTime); // Decay to sustain
                
                osc1.start();
                osc2.start();
                
                // Auto-release timeout (use longer of the two attack+decay times)
                const maxEnvelopeTime = Math.max(
                    this.envelope.attack + this.envelope.decay,
                    this.osc2Envelope.attack + this.osc2Envelope.decay
                );
                const releaseTimeout = setTimeout(() => {
                    this.stopFrequency(frequency, element);
                }, (maxEnvelopeTime + 1) * 1000);
                
                // Store oscillator data
                this.activeOscillators.set(frequency, { 
                    osc1, 
                    osc2, 
                    osc1Envelope,
                    osc2Envelope,
                    finalMixer,
                    panner,
                    osc1Gain,
                    osc2Gain,
                    releaseTimeout,
                    startTime: currentTime
                });
                element.classList.add('active');
            }

            stopFrequency(frequency, element) {
                const osc = this.activeOscillators.get(frequency);
                if (!osc) return;
                
                const { osc1, osc2, osc1Envelope, osc2Envelope, releaseTimeout } = osc;
                
                // Clear auto-release timeout
                if (releaseTimeout) {
                    clearTimeout(releaseTimeout);
                }
                
                // Remove from active oscillators immediately to prevent overlap
                this.activeOscillators.delete(frequency);
                
                try {
                    const currentTime = this.audioContext.currentTime;
                    
                    // Apply OSC 1 release envelope
                    osc1Envelope.gain.cancelScheduledValues(currentTime);
                    osc1Envelope.gain.setValueAtTime(osc1Envelope.gain.value, currentTime);
                    osc1Envelope.gain.linearRampToValueAtTime(0, currentTime + this.envelope.release);
                    
                    // Apply OSC 2 release envelope
                    osc2Envelope.gain.cancelScheduledValues(currentTime);
                    osc2Envelope.gain.setValueAtTime(osc2Envelope.gain.value, currentTime);
                    osc2Envelope.gain.linearRampToValueAtTime(0, currentTime + this.osc2Envelope.release);
                    
                    // Stop oscillators after the longer of the two release times
                    const maxReleaseTime = Math.max(this.envelope.release, this.osc2Envelope.release);
                    osc1.stop(currentTime + maxReleaseTime);
                    osc2.stop(currentTime + maxReleaseTime);
                    
                    // Clean up visual indicator
                    setTimeout(() => {
                        element.classList.remove('active');
                    }, maxReleaseTime * 1000 + 50);
                } catch (error) {
                    console.warn('Error stopping oscillator:', error);
                    element.classList.remove('active');
                }
            }

            stopAllStrings() {
                // Stop all currently playing oscillators with proper release
                for (const [frequency, oscData] of this.activeOscillators) {
                    const { osc1, osc2, osc1Envelope, osc2Envelope, releaseTimeout } = oscData;
                    
                    if (releaseTimeout) {
                        clearTimeout(releaseTimeout);
                    }
                    
                    try {
                        const currentTime = this.audioContext.currentTime;
                        
                        // Apply OSC 1 release envelope
                        osc1Envelope.gain.cancelScheduledValues(currentTime);
                        osc1Envelope.gain.setValueAtTime(osc1Envelope.gain.value, currentTime);
                        osc1Envelope.gain.linearRampToValueAtTime(0, currentTime + this.envelope.release);
                        
                        // Apply OSC 2 release envelope
                        osc2Envelope.gain.cancelScheduledValues(currentTime);
                        osc2Envelope.gain.setValueAtTime(osc2Envelope.gain.value, currentTime);
                        osc2Envelope.gain.linearRampToValueAtTime(0, currentTime + this.osc2Envelope.release);
                        
                        // Stop oscillators after the longer of the two release times
                        const maxReleaseTime = Math.max(this.envelope.release, this.osc2Envelope.release);
                        osc1.stop(currentTime + maxReleaseTime);
                        osc2.stop(currentTime + maxReleaseTime);
                    } catch (error) {
                        console.warn('Error stopping oscillator:', error);
                    }
                }
                
                // Clear all tracking
                this.activeOscillators.clear();
                this.triggeredStrings.clear();
                
                // Remove visual indicators
                document.querySelectorAll('.string.active').forEach(el => {
                    el.classList.remove('active');
                });
            }
        }

        // Initialize the instrument when the page loads
        let omnichord;
        window.addEventListener('load', () => {
            omnichord = new MicrotonalOmnichord();
            window.omnichord = omnichord; // Make it globally accessible
        });
    </script>
</body>
</html>