<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Microtonal Omnichord</title>
    <!-- Retro font (Oswald) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root { --retro-font: 'Oswald','Arial Narrow','Helvetica Neue',Arial,sans-serif; }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            font-family: var(--retro-font) !important;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        .instrument {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        .root-notes-area {
            height: 260px; /* sync with later override */
            background: rgba(0, 30, 60, 0.9);
            border-bottom: 2px solid #333;
            padding: 10px;
            display: flex;
            align-items: flex-start;
        }

        .strum-area {
            flex: 1 1 auto; /* fill remaining vertical space */
            position: relative;
            background: linear-gradient(180deg, #0f3460, #16537e);
            overflow: hidden;
            display: flex;
            padding: 0;
            border: 2px solid #4a6870;
            gap: 0;
            min-height: 200px;
        }

        .strum-area:hover {
            border-color: #8fb3d3;
        }



        .empty-hint {
            text-align: center;
            font-size: 12px;
        }

        .palette-column {
            min-height: 200px;
            max-height: 300px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .palette-chord-remove {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background: #e94560;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
            transition: all 0.2s;
        }

        .palette-chord-remove:hover {
            background: #c73650;
            transform: scale(1.1);
        }

        .palette-chord {
            flex: 1;
            max-width: 25%;
            min-width: 80px;
            background: linear-gradient(135deg, #2a4858, #3a5868);
            border: 2px solid #4a6870;
            border-radius: 8px;
            display: flex;
            flex-direction: row;
            align-items: stretch;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            padding: 0;
            overflow: hidden;
            gap: 2px;
            touch-action: none; /* Prevent default touch behaviors */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -webkit-touch-callout: none; /* Prevent iOS callout */
        }

        .palette-chord:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            border-color: #6aa0b0;
        }

        .palette-chord:active {
            transform: translateY(0px) scale(0.98);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .palette-chord.active {
            border-color: #e94560;
            box-shadow: 0 0 15px rgba(233, 69, 96, 0.5);
            background: linear-gradient(135deg, #4a2858, #5a3868);
        }

        /* Touch-specific feedback states for palette chords */
        .palette-chord.touch-pressed {
            transform: translateY(0px) scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #3a5868, #4a6878);
        }

        .palette-chord.touch-long-press {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 20px rgba(106, 160, 176, 0.6);
            border-color: #8ab0c0;
            background: linear-gradient(135deg, #4a6878, #5a7888);
        }

        .palette-chord-name {
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            height: 20px;
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }

        .palette-chord-root {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            height: 15px;
            font-size: 8px;
            color: #8fb3d3;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }

        .palette-chord-strings {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-evenly;
            padding: 25px 4px 20px 4px;
            position: relative;
        }

        .palette-string {
            height: 3px;
            background: linear-gradient(90deg, #34495e, #95a5a6, #34495e);
            border-radius: 1px;
            position: relative;
            cursor: pointer;
            transition: all 0.05s;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            margin: 1px 0;
            flex-shrink: 0;
            overflow: hidden;
        }

        .palette-string:hover {
            transform: scaleY(1.3);
            box-shadow: 0 0 8px rgba(149, 165, 166, 0.5);
        }

        .palette-string.active {
            background: linear-gradient(90deg, #e74c3c, #f39c12, #e74c3c);
            transform: scaleY(1.5);
            box-shadow: 0 0 12px rgba(231, 76, 60, 0.7);
        }

        .palette-string-wave {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.1s;
            background: repeating-linear-gradient(
                90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.3) 25%,
                transparent 50%,
                rgba(255, 255, 255, 0.3) 75%,
                transparent 100%
            );
            background-size: 15px 100%;
            animation: wave-flow 1s linear infinite;
        }

        .palette-string.active .palette-string-wave {
            opacity: 1;
        }

        .palette-chord-remove {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 16px;
            height: 16px;
            background: #e94560;
            border: 1px solid #c73650;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 8px;
            color: white;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .palette-chord:hover .palette-chord-remove {
            opacity: 1;
        }

        .root-notes-area {
            height: 260px; /* enlarged to fit circular keyboard + microtone lanes */
            flex: 0 0 260px; /* lock vertical allocation */
            background: rgba(0, 20, 40, 0.9);
            border-bottom: 1px solid #333;
            display: flex;
            align-items: flex-start; /* keep keyboard pinned to top to avoid jump when regenerating */
            justify-content: center; /* center horizontally */
            padding: 8px 8px 0 8px;
            position: relative;
        }

        .clear-triads-container {
            display: flex;
            align-items: center;
        }

        .clear-triads-btn {
            background: linear-gradient(135deg, #e94560, #c73650);
            border: 1px solid #c73650;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .clear-triads-btn:hover {
            background: linear-gradient(135deg, #c73650, #a52a42);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

        .clear-triads-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .notes-area {
            height: 18vh;
            background: rgba(0, 20, 40, 0.8);
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 6px;
        }

        .control-panel {
            height: calc(100vh - 90px - 28vh - 28vh);
            min-height: 35vh;
            padding: 10px;
            background: rgba(0, 20, 40, 0.9);
            overflow: visible;
            display: grid;
            grid-template-columns: 300px 200px 280px 1fr;
            gap: 15px;
            align-content: start;
            min-width: 0;
            width: 100%;
        }

        .tuning-buttons {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            align-items: center;
        }

        .tuning-btn {
            padding: 6px 8px;
            background: #2a4858;
            border: 1px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 10px;
            white-space: nowrap;
            font-weight: bold;
        }

        .tuning-btn.active {
            background: #4a8fa0;
            border-color: #6aa0b0;
            box-shadow: 0 0 10px rgba(74, 143, 160, 0.5);
        }

        .chord-section {
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 20px;
            margin-bottom: 15px;
            color: #8fb3d3;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        .chord-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 8px;
            margin-bottom: 15px;
        }

        .chord-btn {
            aspect-ratio: 1;
            background: #2a4858;
            border: 2px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            touch-action: none; /* Prevent default touch behaviors */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -webkit-touch-callout: none; /* Prevent iOS callout */
        }

        .chord-btn:hover {
            background: #3a5868;
            transform: scale(1.05);
        }

        .chord-btn:active {
            background: #4a7888;
            transform: scale(0.98);
        }

        .chord-btn.active {
            background: #e74c3c;
            border-color: #c0392b;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.5);
        }

        /* Touch-specific feedback states */
        .chord-btn.touch-pressed {
            background: #4a7888;
            transform: scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .chord-btn.touch-long-press {
            background: #5a8898;
            transform: scale(1.02);
            box-shadow: 0 0 20px rgba(90, 136, 152, 0.6);
            border-color: #6a98a8;
        }

        .quality-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .quality-btn {
            flex: 1;
            padding: 10px;
            background: #2a4858;
            border: 2px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s;
        }

        .quality-btn.active {
            background: #f39c12;
            border-color: #e67e22;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }

        .extension-columns {
            flex: 1;
            display: flex;
            height: 100%;
            min-height: 0; /* allow children to shrink vertically */
            gap: 0;
            padding: 0;
            justify-content: stretch;
        }

        .quality-section {
            display: flex;
            flex-direction: row;
            flex: 1;
            gap: 2px;
            padding: 0;
            border-radius: 0;
            min-width: 0; /* Allow shrinking */
            max-width: 33.33%; /* Ensure 3 equal sections */
        }

        .extension-column {
            position: relative;
            border-right: none;
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0; /* allow strings to shrink when header grows */
            min-width: 0;
            width: 100%;
            cursor: grab;
            transition: all 0.2s ease;
            height: 100%;
        }

        .extension-column:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .extension-column:active {
            cursor: grabbing;
        }

        /* Context menus removed for clean interface */

        .extension-column:last-child {
            border-right: none;
        }

        .extension-header {
            height: auto; /* allow header to grow when buttons wrap */
            min-height: 56px;
            max-height: none;
            background: rgba(0, 0, 0, 0.5);
            /* Subtle root tint overlay, if provided */
            background-image: var(--root-tint-gradient, none);
            background-repeat: no-repeat;
            background-size: cover;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 13px;
            font-weight: bold;
            text-align: center;
            padding: 10px 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            position: relative;
            transition: background 0.2s, transform 0.1s;
            z-index: 100;
            user-select: none;
            border-radius: 4px 4px 0 0;
            margin: 2px 2px 0 2px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            flex-wrap: wrap;
            align-content: flex-start; /* stack rows from the top when wrapping */
        }

        .chord-name {
            flex: 1;
            text-align: center;
        }

        .lock-button {
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s;
            margin-left: 6px;
            flex-shrink: 0;
            z-index: 100;
            position: relative;
            pointer-events: auto;
            touch-action: manipulation;
        }

        .lock-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .lock-button.locked {
            background: #4CAF50;
            border-color: #45a049;
            color: #fff;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
        }

    /* piano-lock button styles removed */

        .chord-action-button {
            width: 34px;
            height: 34px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s;
            margin-left: 6px;
            flex-shrink: 0;
            pointer-events: auto;
            touch-action: manipulation;
        }

        .chord-action-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        /* High-contrast styling for per-chord transpose arrows */
        .chord-action-button.transpose-up,
        .chord-action-button.transpose-down {
            background: rgba(17, 24, 39, 0.85); /* slate-900 */
            border-color: rgba(255, 255, 255, 0.35);
            color: #ffffff;
        }
        .chord-action-button.transpose-up:hover,
        .chord-action-button.transpose-down:hover {
            background: rgba(31, 41, 55, 0.95); /* slate-800 */
            border-color: rgba(255, 255, 255, 0.55);
        }

        .chord-action-button.edit {
            background: rgba(33, 150, 243, 0.2);
            border-color: rgba(33, 150, 243, 0.5);
        }

    /* delete button styling removed; delete is via upward drag */

        .chord-action-button.duplicate {
            background: rgba(156, 39, 176, 0.2);
            border-color: rgba(156, 39, 176, 0.5);
        }

        .header-buttons {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: auto;
            pointer-events: auto;
            z-index: 99;
            position: relative;
            flex-wrap: wrap;
            row-gap: 6px;
        }

        .extension-header:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

        .extension-header:active {
            transform: translateY(0);
            background: rgba(255, 255, 255, 0.2);
        }

        /* Touch feedback styles */
        .touch-pressed {
            background: rgba(233, 69, 96, 0.3) !important;
            transform: scale(0.98);
            transition: background 0.1s, transform 0.1s;
        }

        .touch-long-press {
            background: rgba(233, 69, 96, 0.5) !important;
            transform: scale(1.02);
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
            transition: background 0.2s, transform 0.2s, box-shadow 0.2s;
        }

        .strings-column {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            padding: 0; /* no inner gaps */
            overflow: hidden; /* Prevent scrollbars */
            min-height: 0; /* allow shrinking when header grows */
            box-sizing: border-box;
            /* High-contrast backdrop for neon strings */
            background: #000000;
            /* Subtle root tint overlay, if provided */
            background-image: var(--root-tint-gradient, none);
            background-repeat: no-repeat;
            background-size: cover;
        }

        .note-label {
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7px;
            color: #8fb3d3;
            text-align: center;
            padding: 1px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Hit area fills the lane from string to string (no gaps) */
        .string {
            position: relative;
            cursor: pointer;
            display: flex;
            align-items: center; /* center the visible core */
            justify-content: stretch;
            flex: 1 1 0;
            margin: 0; /* no gaps */
            padding: 0; /* keep tight */
            overflow: visible; /* allow glow to bloom */
        }

        /* The actual visible 4px neon line lives inside the hit area */
        .string-core {
            position: relative;
            width: 100%;
            height: 4px; /* visual thickness */
            border-radius: 2px;
            transition: transform 0.08s ease, box-shadow 0.1s ease, opacity 0.1s ease, filter 0.1s ease;
            transform-origin: center;
            will-change: transform;
            pointer-events: none; /* events on the hit area (.string) */
        }

        .string:hover .string-core {
            transform: scaleY(1.2);
            filter: brightness(1.05);
        }

        .string.active .string-core {
            transform: scaleY(1.25);
            filter: brightness(1.15);
        }

    .string-wave {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.1s;
            background: repeating-linear-gradient(
                90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.3) 25%,
                transparent 50%,
                rgba(255, 255, 255, 0.3) 75%,
                transparent 100%
            );
            background-size: 20px 100%;
            animation: wave-flow 1s linear infinite;
        }

    .string.active .string-wave {
            opacity: 1;
        }

        @keyframes wave-flow {
            0% {
                background-position-x: 0;
            }
            100% {
                background-position-x: 20px;
            }
        }

        /* Subtle vertical vibration tied to frequency (period set via --vib-period) */
        @keyframes vibrate-y {
            0% { transform: translateY(0) scaleY(1); }
            25% { transform: translateY(-1px) scaleY(1.07); }
            50% { transform: translateY(0) scaleY(1); }
            75% { transform: translateY(1px) scaleY(1.07); }
            100% { transform: translateY(0) scaleY(1); }
        }

        .string-core.vibrating {
            animation: vibrate-y var(--vib-period, 60ms) ease-in-out infinite;
        }

        .note-labels {
            height: 30px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #8fb3d3;
            text-align: center;
            padding: 2px;
        }

        .frequency-display {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #bdc3c7;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .string:hover .frequency-display {
            opacity: 1;
        }

        .current-chord {
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 25px;
            border-radius: 12px;
            border: 2px solid #4a6870;
            z-index: 1000;
        }

        .current-chord h3 {
            color: #e74c3c;
            margin-bottom: 8px;
            font-size: 24px;
            text-align: center;
        }

        .current-chord div {
            font-size: 16px;
            text-align: center;
            color: #8fb3d3;
        }

        .root-notes-selector {
            display: flex;
            gap: 4px;
            align-items: center;
            justify-content: center;
            width: 100%;
            flex-wrap: wrap;
        }

        .root-notes-selector {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .root-notes-selector .section-title {
            font-size: 18px;
            color: #8fb3d3;
            margin-right: 20px;
            white-space: nowrap;
        }

        .root-chord-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(20px, 1fr));
            grid-template-rows: 1fr;
            gap: 1px;
            flex: 1;
            width: 100%;
            max-height: none !important;
            height: 100% !important;
            position: relative;
        }

        .root-btn {
            flex: 1;
            min-width: 20px;
            height: 45px;
            background: linear-gradient(145deg, #2c5aa0, #1e3a8a);
            border: 1px solid #4a90e2;
            border-radius: 6px;
            color: white;
            font-weight: bold;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            touch-action: none; /* Prevent default touch behaviors */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -webkit-touch-callout: none; /* Prevent iOS callout */
        }

        .root-btn:hover {
            background: linear-gradient(145deg, #3d6bb5, #2949a0);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .root-btn:active {
            background: linear-gradient(145deg, #1e3a8a, #1a2f70);
            transform: translateY(0px) scale(0.95);
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        /* Touch-specific feedback states for root buttons */
        .root-btn.touch-pressed {
            background: linear-gradient(145deg, #1e3a8a, #1a2f70);
            transform: translateY(0px) scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .root-btn.touch-long-press {
            background: linear-gradient(145deg, #4d7bc5, #3959b0);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 20px rgba(74, 144, 226, 0.6);
            border-color: #6aa0e2;
        }

        .root-btn.active {
            background: linear-gradient(145deg, #f59e0b, #d97706);
            border-color: #fbbf24;
            color: #000;
            font-weight: bold;
        }

        /* ================= Piano Keyboard Revamp (Top Row) ================ */
        .piano-keyboard {
            position: relative;
            width: 66.666vw; /* fixed 2/3 viewport width */
            max-width: 1500px; /* cap width on large screens */
            height: 200px; /* fixed height */
            margin: 12px auto 8px auto; /* centered near top */
            user-select: none;
            background: transparent; /* remove purple rectangle so keys float on blue */
            border-radius: 8px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.7);
            overflow: hidden;
            /* scaling removed */
            padding-top: 4px; /* slight top padding so glow/outline never alters outer box */
            padding-left: 48px; /* left gutter so transpose buttons never cover first key */
        }
        /* Reserve vertical space inside for active glow so layout never shifts */
        .piano-keyboard .white-key.root-btn,
        .piano-keyboard .black-key.root-btn,
        .piano-keyboard .edo-dot { will-change: transform; }
        /* Neutralize any accidental layout influence from outlines */
        .piano-keyboard .white-key.root-btn.active,
        .piano-keyboard .black-key.root-btn.active,
        .piano-keyboard .edo-dot.active { outline-offset: 0; }
    /* Light currently active chord tones on the keyboard */
    .piano-keyboard .chord-tone { filter: brightness(1.25) contrast(1.1); box-shadow: 0 0 12px 3px rgba(255,255,200,0.5); }
        /* Prevent reflow on hover/active transitions */
        .piano-keyboard .white-key.root-btn,
        .piano-keyboard .black-key.root-btn { position:absolute; }
        /* Hardware accelerate transforms for smoother glow without jitter */
    .piano-keyboard, .piano-keyboard * { backface-visibility:hidden; }
        /* ===== Branding ===== */
    .logo-inline { position:fixed; top:14px; left:20px; z-index:9500; font-family: var(--retro-font); font-weight:600; font-size:32px; letter-spacing:1px; line-height:1; display:flex; align-items:center; gap:6px; pointer-events:none; user-select:none; color:#ffffff; text-shadow:0 0 8px rgba(255,255,255,0.7), 0 0 16px rgba(120,180,255,0.4); animation: logoPulse 3.2s ease-in-out infinite; }
    .logo-inline span { color:#fff; }
    @keyframes logoPulse { 0%,100% { text-shadow:0 0 4px rgba(255,255,255,0.4),0 0 10px rgba(140,180,255,0.25); opacity:0.92; } 50% { text-shadow:0 0 10px rgba(255,255,255,0.9),0 0 24px rgba(140,180,255,0.55); opacity:1; } }
    .piano-keyboard .by-fastfast { position:absolute; top:10px; right:16px; font-family: var(--retro-font); font-size:16px; font-weight:600; color:#ffffff; text-shadow:0 0 6px rgba(255,255,255,0.35), 0 0 12px rgba(120,140,255,0.45); opacity:0.95; pointer-events:auto; user-select:none; }
        /* Allow only the last four letters (FAST) to be clickable */
        .piano-keyboard .by-fastfast .fastfast-link { pointer-events:auto; color:#cde4ff; text-decoration:underline dotted; cursor:pointer; }
        @media (max-width: 900px){
            .logo-inline { font-size:26px; }
            .piano-keyboard .by-fastfast { font-size:13px; top:12px; }
        }
        /* Ensure retro font everywhere */
        button, .root-btn, .extension-header, .control-panel, input, select, .edo-dot { font-family: var(--retro-font) !important; }
        /* Base circle key */
        .piano-keyboard .white-key.root-btn,
        .piano-keyboard .black-key.root-btn {
            position:absolute;
            width:70px;
            height:70px;
            z-index:2; /* keep keys above micro dots so labels (like B) remain visible */
            border-radius:50%;
            display:flex;
            align-items:center;
            justify-content:center;
            font-size:14px;
            font-weight:bold;
            cursor:pointer;
            transform:translate(-50%, -50%);
            transition:filter .15s, transform .1s;
            box-shadow:0 4px 10px rgba(0,0,0,0.6), inset 0 -4px 6px rgba(0,0,0,0.4);
        }
        .piano-keyboard .white-key.root-btn {
            background:radial-gradient(circle at 30% 30%, #ffffff, #d9d9d9 60%, #bdbdbd);
            color:#222;
            top:78%; /* bring upward so full circle visible */
        }
        .piano-keyboard .white-key.root-btn.disabled { filter:grayscale(60%) brightness(0.8); opacity:.6; }
        .piano-keyboard .white-key.root-btn.active { outline:3px solid #ffd046; box-shadow:0 0 14px 4px rgba(255,208,70,0.7); }
        .piano-keyboard .black-key.root-btn {
            background:radial-gradient(circle at 30% 30%, #444, #111 65%, #000);
            color:#eee;
            top:26%; /* adjust for reduced height */
            width:68px;
            height:68px;
        }
        .piano-keyboard .black-key.root-btn.disabled { filter:grayscale(60%) brightness(0.6); opacity:.55; }
        .piano-keyboard .black-key.root-btn.active { outline:3px solid #9d6bff; box-shadow:0 0 16px 4px rgba(157,107,255,0.8); }
        .piano-keyboard .white-key.root-btn:active, .piano-keyboard .black-key.root-btn:active { transform:translate(-50%, -50%) scale(.94); }
        .piano-keyboard .white-key.root-btn:hover, .piano-keyboard .black-key.root-btn:hover { filter:brightness(1.15); }

        /* Legacy microtone overlay removal */
        .piano-keyboard .microtone-key.root-btn { display:none; }
        .piano-keyboard .microtone-key.root-btn span { pointer-events:none; }

        /* 96-EDO microtone dot system */
        .piano-keyboard .edo-dot {
            position:absolute;
            width:26px;
            height:26px;
            z-index:1; /* ensure dots don't obscure white/black key labels */
            border-radius:50%;
            transform:translateX(-50%);
            box-shadow:0 1px 3px rgba(0,0,0,0.6), inset 0 0 3px rgba(255,255,255,0.4);
            cursor:pointer;
            display:flex;
            align-items:center;
            justify-content:center;
            font-size:11px;
            font-weight:bold;
            color:#fff;
            text-shadow:0 1px 2px rgba(0,0,0,0.9);
            padding:2px;
            box-sizing:border-box;
        }
        .piano-keyboard .edo-dot.blue { background:radial-gradient(circle at 30% 30%, #6fa9ff, #2563eb 60%, #1e3a8a); }
        .piano-keyboard .edo-dot.green { background:radial-gradient(circle at 30% 30%, #5ef0b2, #0d9e6f 60%, #065f46); }
        .piano-keyboard .edo-dot.red { background:radial-gradient(circle at 30% 30%, #ff9a9a, #dc2626 60%, #7f1d1d); }
    .piano-keyboard .edo-dot.active { outline:2px solid #fff; box-shadow:0 0 10px 4px rgba(255,255,255,0.9); filter:brightness(1.2); }
    .piano-keyboard .edo-dot.red.active { box-shadow:0 0 12px 5px rgba(220,38,38,0.9),0 0 6px 3px rgba(255,255,255,0.8); }
    .piano-keyboard .edo-dot.green.active { box-shadow:0 0 12px 5px rgba(13,158,111,0.9),0 0 6px 3px rgba(255,255,255,0.8); }
    .piano-keyboard .edo-dot.blue.active { box-shadow:0 0 12px 5px rgba(37,99,235,0.9),0 0 6px 3px rgba(255,255,255,0.8); }
    /* Chord-builder selection glow (non-root) */
    .piano-keyboard .edo-dot.selected { outline:3px solid #f39c12; box-shadow:0 0 14px 5px rgba(243,156,18,0.85),0 0 6px 3px rgba(255,255,255,0.5); filter:brightness(1.15); }
        /* Vertical lanes (percent from top of keyboard height) */
    /* Updated vertical lane centers to match reference image (from top to bottom: black, blue, green, red, white) */
    .piano-keyboard .edo-lane-blue  { top:39%; }
    .piano-keyboard .edo-lane-green { top:52%; }
    .piano-keyboard .edo-lane-red   { top:65%; }

        /* ================================================================== */

        /* Chord creation mode styles */
        .chord-creation-mode .root-notes-area {
            background: rgba(0, 60, 30, 0.9);
            border-color: #2E8B57;
        }

        .chord-creation-mode .root-notes-area::before {
            content: "?? Select intervals for your chord - Click root buttons to add/remove notes";
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #90EE90;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 8px;
            border-radius: 4px;
            z-index: 10;
        }

        .chord-creation-mode .root-btn {
            background: #2a4858;
            border-color: #4a6870;
        }

        .chord-creation-mode .root-btn:hover {
            background: #3a5868;
            border-color: #5a7880;
        }

        .chord-creation-mode .root-btn.selected {
            background: #e74c3c;
            border-color: #c0392b;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.7);
        }

        .chord-creation-mode .root-btn.preview {
            background: #f39c12;
            border-color: #e67e22;
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }

        .chord-types-selector {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .chord-types-selector .section-title {
            font-size: 12px;
            color: #8fb3d3;
            margin-right: 10px;
        }

        .quality-selector {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .quality-selector .section-title {
            font-size: 12px;
            color: #8fb3d3;
            margin-right: 10px;
        }

        .volume-control {
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #4a6870;
            display: flex;
            flex-direction: column;
            gap: 12px;
            font-size: 11px;
        }


        .osc-btn {
            padding: 10px;
            background: #2a4858;
            border: 2px solid #4a6870;
            color: #fff;
            cursor: pointer;
            border-radius: 6px;
            font-size: 11px;
            transition: all 0.2s;
            text-align: center;
            font-weight: bold;
        }

        /* Square, tappable oscillator shape buttons */
        .oscillator-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(54px, 1fr));
            gap: 8px;
        }
        .oscillator-controls .osc-btn {
            padding: 0 !important; /* override inline paddings */
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px !important;
            border-radius: 10px;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .osc-btn.active {
            background: #27ae60;
            border-color: #2ecc71;
            box-shadow: 0 0 8px rgba(39, 174, 96, 0.5);
        }

        .multi-osc-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 6px;
        }

        .osc-group {
            border: 1px solid rgba(74, 104, 112, 0.3);
            border-radius: 4px;
            padding: 6px;
        }

        .osc-group h5 {
            font-size: 8px;
            color: #8fb3d3;
            margin-bottom: 4px;
        }

        .osc-mix-controls {
            display: flex;
            gap: 4px;
            margin-top: 4px;
        }

        .effects-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .effect-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .effect-group label {
            font-size: 8px;
            color: #8fb3d3;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .slider-value {
            font-size: 9px;
            color: #bdc3c7;
            text-align: center;
        }

        @media (max-width: 768px) {
            .control-panel {
                height: 60px;
                padding: 5px;
                gap: 8px;
            }
            
            .tuning-btn {
                padding: 4px 6px;
                font-size: 10px;
            }
            
            .chord-header {
                height: 30px;
                font-size: 8px;
            }
            
            .string {
                margin: 0.2px 0;
                height: 1px;
            }
            
            .note-labels {
                height: 25px;
                font-size: 7px;
            }
            
            .volume-control {
                min-width: 120px;
                max-width: 140px;
                padding: 6px;
            }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .control-panel {
                height: 50px;
                padding: 3px;
            }
            
            .chord-header {
                height: 25px;
                font-size: 7px;
            }
            
            .note-labels {
                height: 20px;
                font-size: 6px;
            }
            
            .string {
                margin: 0.2px 0;
                height: 1px;
            }
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: #2a2a2a;
            color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid #666;
        }

        .add-column-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .add-chord-btn {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .add-chord-btn:hover {
            background: linear-gradient(135deg, #357abd, #2868a3);
            transform: translateY(-2px);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        /* Tutorial System Styles */
        .tutorial-highlight {
            box-shadow: 0 0 20px #8fb3d3, 0 0 40px #8fb3d3, 0 0 60px #8fb3d3 !important;
            border: 3px solid #8fb3d3 !important;
            filter: brightness(1.5) contrast(1.2) !important;
            position: relative !important;
            z-index: 9500 !important;
            background: rgba(143, 179, 211, 0.15) !important;
            border-radius: 8px !important;
        }

        #tutorialOverlay {
            backdrop-filter: blur(2px);
        }

        #tutorialBox {
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-height: 80vh;
            overflow-y: auto;
            position: fixed !important;
            top: 50px !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            z-index: 2010 !important;
        }

        #tutorialButton, #randomDiceButton {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        #tutorialButton:hover, #randomDiceButton:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        #randomDiceButton {
            transition: transform 0.6s ease;
        }

        /* Add pulsing animation for tutorial and dice buttons */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(143, 179, 211, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(143, 179, 211, 0); }
            100% { box-shadow: 0 0 0 0 rgba(143, 179, 211, 0); }
        }

        #tutorialButton {
            animation: pulse 2s infinite;
        }

        @keyframes diceRoll {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(720deg); }
        }

        /* Drag & drop chord boxes */
        .extension-column.dragging {
            opacity: 0.98;
            cursor: grabbing;
        }
        .extension-column.placeholder {
            background: rgba(255,255,255,0.06);
        }
        .extension-column.delete-intent .extension-header {
            background: #8b1e1e !important;
            border-color: #ef4444 !important;
        }
    </style>
</head>
<body>
    <!-- Global Logo (fixed on blue background) -->
    <div class="logo-inline"><span class="omg">OMG</span><span class="nichord">- nichord</span></div>
    <!-- Bottom control bar -->
    <div id="bottomBar" style="position:fixed;bottom:0;left:0;right:0;height:50px;display:flex;align-items:center;justify-content:flex-start;gap:14px;padding:0 18px;background:#081a28;border-top:2px solid #123447;z-index:600;font-family:var(--retro-font);">
        <!-- New global create chord button (moved out of TUNING panel) -->
        <button id="createNewChordBtn" class="panel-btn" title="Add a new custom chord" style="font-weight:bold;padding:6px 10px;">+</button>
        <!-- EDO quick control (5–52) -->
        <div style="display:flex;align-items:center;gap:6px;">
            <span style="font-size:12px;color:#9db6c8;">EDO</span>
            <input id="edoQuickInput" type="number" min="5" max="52" value="24" title="Steps per octave" style="width:56px;background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:4px 6px;font-size:12px;" />
        </div>
        <button class="panel-btn" data-panel="osc">OSCILLATORS</button>
        <button class="panel-btn" data-panel="fx">EFFECTS</button>
        <button id="openTextChordParserBtn" class="panel-btn" title="Type or paste a chord sequence" style="margin-left:6px;">SEQUENCE</button>
        <div style="margin-left:auto;display:flex;align-items:center;gap:12px;">
            <button id="bottomSaveSeqBtn" class="panel-btn" title="Save current chord sequence as preset" style="padding:6px 10px;background:#10b981;border-color:#34d399;">💾</button>
            <button id="bottomImportOMGBtn" class="panel-btn" title="Import .OMG session" style="padding:6px 10px;background:#9b59b6;border-color:#8e44ad;">📂</button>
            <button id="bottomExportOMGBtn" class="panel-btn" title="Export full session (.OMG)" style="padding:6px 10px;background:#f59e0b;border-color:#fbbf24;">⬇️</button>
            <label for="voicingSpanMode" style="font-size:11px;color:#9db6c8;">VOICING</label>
            <select id="voicingSpanMode" style="background:#2a4858;color:#e8f5ff;border:1px solid #4a6870;border-radius:4px;padding:4px 6px;font-size:11px;">
                <option value="split-two">Split extended chords across 2 octaves</option>
                <option value="compact-one" selected>Fit extended chords within one octave</option>
            </select>
            <label for="masterVolume" style="font-size:11px;color:#9db6c8;">MASTER</label>
            <input type="range" id="masterVolume" min="0" max="10" value="10" style="width:140px; accent-color:#2d9c5d;">
            <span id="masterVolumeValue" style="font-size:11px; color:#b7d4e6; width:38px; text-align:right;">100%</span>
        </div>
    </div>
    <div id="panelHost" style="position:fixed;bottom:54px;left:12px;width:min(95vw, 780px);max-height:55vh;background:#0b2536;border:2px solid #15506a;border-radius:10px;box-shadow:0 -6px 22px rgba(0,0,0,0.55);padding:18px 20px;display:none;overflow-y:auto;z-index:650;font-family:var(--retro-font);">
        <!-- Control Panels migrated here -->
        <div class="panel-content" data-panel="tuning" style="display:none; gap:15px; grid-template-columns:300px;">
            <div class="synth-section" id="tuningSelector" style="padding:8px;">
                <h4 style="font-size:15px; margin-bottom:8px;">EDO Configuration</h4>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:10px;">
                    <div class="slider-container">
                        <label style="font-size:11px;">Divisions</label>
                        <input type="number" id="edoDivisions" min="5" max="52" value="24" style="width:100%; padding:4px; background:#2a4858; color:#fff; border:1px solid #4a6870; border-radius:4px; font-size:11px;">
                    </div>
                </div>
                <div style="margin-bottom:10px;">
                    <!-- Tuning panel now focuses only on tuning and session; basic chords moved to Sequence modal. -->
                    <button id="resetChordsBtn" class="osc-btn" style="width:100%; font-size:12px; padding:8px; background:#e74c3c; border-color:#c0392b; margin-top:5px;">Clear Unlocked</button>
                </div>
                <div style="margin-bottom:10px; display:flex; gap:5px;">
                    <button id="saveSessionBtn" class="osc-btn" style="flex:1; font-size:11px; padding:6px; background:#3498db; border-color:#2980b9;">💾</button>
                    <button id="loadSessionBtn" class="osc-btn" style="flex:1; font-size:11px; padding:6px; background:#9b59b6; border-color:#8e44ad;">📂</button>
                    <input type="file" id="loadSessionInput" accept=".omg" style="display:none;">
                </div>
            </div>
        </div>
    <!-- Master panel removed; single master slider now on bar -->
        <div class="panel-content" data-panel="fx" style="display:none;">
            <div class="synth-section" id="effectsSection" style="padding:8px;">
                <h4 style="font-size:15px; margin-bottom:8px; color:#9b59b6;">Effects</h4>
                <div style="margin-bottom:10px;">
                    <label style="font-size:13px; color:#9b59b6;">Reverb</label>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                        <div class="slider-container">
                            <label style="font-size:10px;">Wet</label>
                            <input type="range" class="synth-slider" id="reverbWet" min="0" max="10" value="1" style="height:20px;">
                            <div class="slider-value" id="reverbWetValue" style="font-size:9px;">10%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Room</label>
                            <input type="range" class="synth-slider" id="reverbRoom" min="0" max="10" value="5" style="height:20px;">
                            <div class="slider-value" id="reverbRoomValue" style="font-size:9px;">50%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Decay</label>
                            <input type="range" class="synth-slider" id="reverbDecay" min="0" max="100" value="20" style="height:20px;">
                            <div class="slider-value" id="reverbDecayValue" style="font-size:9px;">2.0s</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Cut</label>
                            <input type="range" class="synth-slider" id="reverbFilterCutoff" min="200" max="20000" value="8000" style="height:20px;">
                            <div class="slider-value" id="reverbFilterCutoffValue" style="font-size:9px;">8kHz</div>
                        </div>
                    </div>
                </div>
                <div>
                    <label style="font-size:13px; color:#e74c3c;">Panning</label>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                        <div class="slider-container">
                            <label style="font-size:10px;">Mode</label>
                            <select id="panningMode" style="width:100%; padding:3px; background:#2a4858; color:#fff; border:1px solid #4a6870; border-radius:3px; font-size:10px; height:24px;">
                                <option value="center">Center</option>
                                <option value="frequency">Freq</option>
                                <option value="random">Random</option>
                                <option value="rotating">Rotate</option>
                                <option value="alternating">Alt</option>
                            </select>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Width</label>
                            <input type="range" class="synth-slider" id="panningWidth" min="0" max="100" value="80" style="height:20px;">
                            <div class="slider-value" id="panningWidthValue" style="font-size:9px;">80%</div>
                        </div>
                        <div class="slider-container">
                            <label style="font-size:10px;">Speed</label>
                            <input type="range" class="synth-slider" id="panningSpeed" min="200" max="10000" value="2000" style="height:20px;">
                            <div class="slider-value" id="panningSpeedValue" style="font-size:9px;">2.0s</div>
                        </div>
                        <div style="display:flex; align-items:center; justify-content:center;">
                            <div class="mix-btn" id="panningReset" style="font-size:9px; padding:4px; cursor:pointer;">Reset</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="panel-content" data-panel="osc" style="display:none;">
            <div class="synth-section" id="oscillatorsSection" style="padding:8px;">
                <h4 style="font-size:15px; margin-bottom:8px;">Oscillators</h4>
                <!-- Instrument Presets Toolbar -->
                <div id="instrumentPresetsBar" style="display:flex; align-items:center; gap:8px; margin:6px 0 10px 0;">
                    <label for="instrumentPresetSelect" style="font-size:12px; color:#8fb3d3;">Preset</label>
                    <select id="instrumentPresetSelect" style="background:#0d2938; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px; padding:6px 8px; min-width:200px;"></select>
                    <button class="osc-btn" id="instrumentPresetApply" title="Apply selected preset" style="background:#3498db; border-color:#2980b9;">Apply</button>
                    <button class="osc-btn" id="instrumentPresetSave" title="Save current instrument as preset" style="background:#10b981; border-color:#059669;">Save</button>
                    <button class="osc-btn" id="instrumentPresetDelete" title="Delete selected preset" style="background:#e74c3c; border-color:#c0392b;">Delete</button>
                </div>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
                    <div style="border:1px solid #4a6870; border-radius:4px; padding:8px; background:rgba(42,72,88,0.2);">
                        <h5 style="font-size:12px; margin-bottom:6px; color:#8fb3d3;">OSC 1</h5>
                        <div class="oscillator-controls" style="margin-bottom:8px;">
                            <div class="osc-btn active" data-wave="sine" data-osc="1" style="font-size:11px; padding:6px 8px;">Sin</div>
                            <div class="osc-btn" data-wave="sawtooth" data-osc="1" style="font-size:11px; padding:6px 8px;">Saw</div>
                            <div class="osc-btn" data-wave="square" data-osc="1" style="font-size:11px; padding:6px 8px;">Sqr</div>
                            <div class="osc-btn" data-wave="triangle" data-osc="1" style="font-size:11px; padding:6px 8px;">Tri</div>
                            <div class="osc-btn" data-wave="noise" data-osc="1" style="font-size:11px; padding:6px 8px;">Nse</div>
                            <div class="osc-btn" data-wave="pulse" data-osc="1" style="font-size:11px; padding:6px 8px;">Pulse</div>
                            <div class="osc-btn" data-wave="fullrect" data-osc="1" style="font-size:11px; padding:6px 8px;">FRect</div>
                            <div class="osc-btn" data-wave="halfrect" data-osc="1" style="font-size:11px; padding:6px 8px;">HRect</div>
                            <div class="osc-btn" data-wave="trapezoid" data-osc="1" style="font-size:11px; padding:6px 8px;">Trap</div>
                            <div class="osc-btn" data-wave="parabolic" data-osc="1" style="font-size:11px; padding:6px 8px;">Para</div>
                            <div class="osc-btn" data-wave="stair" data-osc="1" style="font-size:11px; padding:6px 8px;">Stair</div>
                        </div>
                        <div class="slider-container pulse-width-container" data-osc="1" style="display:none; margin-bottom:6px;">
                            <label style="font-size:9px;">Pulse Width</label>
                            <input type="range" class="synth-slider" id="osc1PulseWidth" min="5" max="95" value="50" style="height:20px;">
                            <div class="slider-value" id="osc1PulseWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px; margin-bottom:8px;">
                            <div class="slider-container">
                                <label style="font-size:9px;">Level</label>
                                <input type="range" class="synth-slider" id="osc1Level" min="0" max="10" value="5" style="height:20px;">
                                <div class="slider-value" id="osc1LevelValue" style="font-size:9px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Fine</label>
                                <input type="range" class="synth-slider" id="osc1Detune" min="-50" max="50" value="0" style="height:20px;">
                                <div class="slider-value" id="osc1DetuneValue" style="font-size:9px;">0¢</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Octave</label>
                                <input type="range" class="synth-slider" id="osc1Octave" min="-3" max="3" value="0" style="height:20px;">
                                <div class="slider-value" id="osc1OctaveValue" style="font-size:9px;">0</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Coarse</label>
                                <input type="range" class="synth-slider" id="osc1Coarse" min="-24" max="24" value="0" step="1" style="height:20px;">
                                <div class="slider-value" id="osc1CoarseValue" style="font-size:9px;">0 steps</div>
                            </div>
                        </div>
                        <h6 style="font-size:10px; margin:6px 0 4px 0; color:#f39c12;">ADSR 1</h6>
                        <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:3px;">
                            <div class="slider-container">
                                <label style="font-size:8px;">Attack</label>
                                <input type="range" class="envelope-slider" id="attackSlider" min="3" max="1000" value="5" style="height:18px;">
                                <div class="slider-value" id="attackValue" style="font-size:8px;">5ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Decay</label>
                                <input type="range" class="envelope-slider" id="decaySlider" min="0" max="1000" value="200" style="height:18px;">
                                <div class="slider-value" id="decayValue" style="font-size:8px;">200ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Sustain</label>
                                <input type="range" class="envelope-slider" id="sustainSlider" min="1" max="100" value="50" style="height:18px;">
                                <div class="slider-value" id="sustainValue" style="font-size:8px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Release</label>
                                <input type="range" class="envelope-slider" id="releaseSlider" min="0" max="1000" value="1000" style="height:18px;">
                                <div class="slider-value" id="releaseValue" style="font-size:8px;">1000ms</div>
                            </div>
                        </div>
                    </div>
                    <div style="border:1px solid #4a6870; border-radius:4px; padding:8px; background:rgba(42,72,88,0.2);">
                        <h5 style="font-size:12px; margin-bottom:6px; color:#8fb3d3;">OSC 2</h5>
                        <div class="oscillator-controls" style="margin-bottom:8px;">
                            <div class="osc-btn active" data-wave="sine" data-osc="2" style="font-size:11px; padding:6px 8px;">Sin</div>
                            <div class="osc-btn" data-wave="sawtooth" data-osc="2" style="font-size:11px; padding:6px 8px;">Saw</div>
                            <div class="osc-btn" data-wave="square" data-osc="2" style="font-size:11px; padding:6px 8px;">Sqr</div>
                            <div class="osc-btn" data-wave="triangle" data-osc="2" style="font-size:11px; padding:6px 8px;">Tri</div>
                            <div class="osc-btn" data-wave="noise" data-osc="2" style="font-size:11px; padding:6px 8px;">Nse</div>
                            <div class="osc-btn" data-wave="pulse" data-osc="2" style="font-size:11px; padding:6px 8px;">Pulse</div>
                            <div class="osc-btn" data-wave="fullrect" data-osc="2" style="font-size:11px; padding:6px 8px;">FRect</div>
                            <div class="osc-btn" data-wave="halfrect" data-osc="2" style="font-size:11px; padding:6px 8px;">HRect</div>
                            <div class="osc-btn" data-wave="trapezoid" data-osc="2" style="font-size:11px; padding:6px 8px;">Trap</div>
                            <div class="osc-btn" data-wave="parabolic" data-osc="2" style="font-size:11px; padding:6px 8px;">Para</div>
                            <div class="osc-btn" data-wave="stair" data-osc="2" style="font-size:11px; padding:6px 8px;">Stair</div>
                        </div>
                        <div class="slider-container pulse-width-container" data-osc="2" style="display:none; margin-bottom:6px;">
                            <label style="font-size:9px;">Pulse Width</label>
                            <input type="range" class="synth-slider" id="osc2PulseWidth" min="5" max="95" value="50" style="height:20px;">
                            <div class="slider-value" id="osc2PulseWidthValue" style="font-size:9px;">50%</div>
                        </div>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px; margin-bottom:8px;">
                            <div class="slider-container">
                                <label style="font-size:9px;">Level</label>
                                <input type="range" class="synth-slider" id="osc2Level" min="0" max="10" value="5" style="height:20px;">
                                <div class="slider-value" id="osc2LevelValue" style="font-size:9px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Fine</label>
                                <input type="range" class="synth-slider" id="osc2Detune" min="-50" max="50" value="-7" style="height:20px;">
                                <div class="slider-value" id="osc2DetuneValue" style="font-size:9px;">-7¢</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Octave</label>
                                <input type="range" class="synth-slider" id="osc2Octave" min="-3" max="3" value="0" style="height:20px;">
                                <div class="slider-value" id="osc2OctaveValue" style="font-size:9px;">0</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:9px;">Coarse</label>
                                <input type="range" class="synth-slider" id="osc2Coarse" min="-24" max="24" value="0" step="1" style="height:20px;">
                                <div class="slider-value" id="osc2CoarseValue" style="font-size:9px;">0 steps</div>
                            </div>
                        </div>
                        <h6 style="font-size:10px; margin:6px 0 4px 0; color:#f39c12;">ADSR 2</h6>
                        <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:3px;">
                            <div class="slider-container">
                                <label style="font-size:8px;">Attack</label>
                                <input type="range" class="envelope-slider" id="osc2AttackSlider" min="3" max="100" value="5" style="height:18px;">
                                <div class="slider-value" id="osc2AttackValue" style="font-size:8px;">5ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Decay</label>
                                <input type="range" class="envelope-slider" id="osc2DecaySlider" min="0" max="1000" value="30" style="height:18px;">
                                <div class="slider-value" id="osc2DecayValue" style="font-size:8px;">30ms</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Sustain</label>
                                <input type="range" class="envelope-slider" id="osc2SustainSlider" min="1" max="100" value="50" style="height:18px;">
                                <div class="slider-value" id="osc2SustainValue" style="font-size:8px;">50%</div>
                            </div>
                            <div class="slider-container">
                                <label style="font-size:8px;">Release</label>
                                <input type="range" class="envelope-slider" id="osc2ReleaseSlider" min="0" max="1000" value="1000" style="height:18px;">
                                <div class="slider-value" id="osc2ReleaseValue" style="font-size:8px;">1000ms</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="instrument">
        <!-- Root Notes at Top -->
        <div class="root-notes-area">
            <div class="root-notes-selector">
                <!-- Logo moved inside keyboard -->
                <div class="root-chord-grid" id="rootGrid"></div>
            </div>
        </div>

        <!-- Fretboard/Strings -->
        <div class="strum-area">
            <div class="extension-columns" id="extensionColumns"></div>
        </div>

    <!-- (Old control panel removed; controls moved into panelHost) -->

    <!-- Unified Chord Builder Modal -->
    <div id="chordBuilderModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 20px; border-radius: 10px; max-width: 95%; max-height: 95%; overflow-y: auto; width: 800px;">
            <h3 id="chordBuilderTitle">Enhanced Chord Builder</h3>
            
            <!-- Chord Name Input -->
            <div style="margin: 20px 0;">
                <label>Chord Name (flavor only, no root):</label>
                <input type="text" id="chordBuilderName" placeholder="e.g. maj7#11, min9, sus2add6" style="width: 300px; padding: 8px; margin-left: 10px; background: #2a4858; color: #fff; border: 1px solid #4a6870; border-radius: 4px;">
            </div>
            
            <!-- Chord Extensions Checkboxes -->
            <div style="margin: 20px 0;">
                <h4 style="margin: 0 0 10px 0; color: #4a90e2;">🎵 Diatonic Extensions (Select Multiple)</h4>
                <div id="chordExtensionsCheckboxes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 8px; margin-bottom: 15px; padding: 15px; border: 2px solid #4a6870; border-radius: 8px; background: rgba(0, 20, 40, 0.3);">
                    <!-- Extension checkboxes will be populated here -->
                </div>
            </div>
            
            <!-- Microtonal Intervals Section -->
            <div id="microtonalSection" style="margin: 20px 0;">
                <h4 style="margin: 0 0 10px 0; color: #27ae60;">🔍 Microtonal Intervals</h4>
                <div style="font-size: 12px; color: #8fb3d3; margin-bottom: 8px;">
                    <span style="color: #4a90e2;"> </span> Diatonic approximations &nbsp;
                    <span style="color: #27ae60;"> </span> Neutral/Xenharmonic &nbsp;
                    <span style="color: #f39c12;"> </span> Quarter-tone regions &nbsp;
                    <span style="color: #e74c3c;"> </span> Chromatic equivalents
                </div>
                <div id="microtonalCheckboxes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 6px; max-height: 300px; overflow-y: auto; padding: 15px; border: 2px solid #4a6870; border-radius: 8px; background: rgba(0, 20, 40, 0.3);">
                    <!-- Microtonal interval checkboxes will be populated here -->
                </div>
            </div>
            
            <!-- Preview Section -->
            <div style="margin: 20px 0; padding: 15px; border: 2px solid #8e44ad; border-radius: 8px; background: rgba(142, 68, 173, 0.1);">
                <h4 style="margin: 0 0 10px 0; color: #8e44ad;">🎧 Chord Preview</h4>
                <div id="chordPreviewDisplay" style="font-family: var(--retro-font); font-size: 14px; color: #8fb3d3; min-height: 40px; padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 4px;">
                    No intervals selected
                </div>
            </div>
            
            <!-- Favorites Section -->
            <div id="favoritesSection" style="margin: 20px 0; padding: 15px; border: 1px solid #4a6870; border-radius: 8px; background: rgba(42, 72, 88, 0.3);">
                <h4 style="margin: 0 0 10px 0; color: #f39c12;">? Favorite Chords</h4>
                <div id="chordBuilderFavoritesList" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; margin-bottom: 10px; min-height: 60px;">
                    <!-- Favorite chords will be populated here -->
                </div>
                <div style="font-size: 12px; color: #8fb3d3;">
                    Click any favorite to load its pattern into the builder
                </div>
            </div>
            
            <!-- Actions -->
            <div style="margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="osc-btn" id="closeChordBuilder">Close</button>
                <button class="osc-btn" id="saveChordBuilder" style="background: #27ae60;">✅ Save Chord</button>
                <button class="osc-btn" id="addToFavoritesBuilder" style="background: #f39c12;">★ Add to Favorites</button>
                <button class="osc-btn" id="previewChordBuilder" style="background: #8e44ad;">🔊 Preview</button>
                <button class="osc-btn" id="clearChordBuilder" style="background: #e74c3c;">❌ Clear</button>
            </div>
        </div>
    </div>

    <!-- Context menus removed for clean interface -->

    <!-- Edit Pattern Modal -->
    <div id="editPatternModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 20px; border-radius: 10px; max-width: 80%; max-height: 80%; overflow-y: auto;">
            <h3 id="editPatternTitle">Edit Note Pattern</h3>
            <div style="margin: 20px 0;">
                <label>Pattern Name:</label>
                <input type="text" id="editPatternName" style="width: 200px; padding: 5px; margin-left: 10px; background: #2a4858; color: #fff; border: 1px solid #4a6870; border-radius: 4px;">
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 10px;">Intervals from Root (semitones):</label>
                <div id="intervalEditor" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; margin-top: 10px;"></div>
            </div>
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 10px;">Quick Patterns:</label>
                <div style="display: flex; gap: 5px; margin-top: 5px; flex-wrap: wrap;">
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7])">Major</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 3, 7])">Minor</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7, 10])">Dom7</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7, 11])">Maj7</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 3, 7, 10])">m7</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 2, 7])">Sus2</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 5, 7])">Sus4</button>
                    <button class="osc-btn" onclick="omnichord.setQuickPattern([0, 4, 7, 9])">6th</button>
                </div>
            </div>
            <div style="margin-top: 20px;">
                <button class="osc-btn" id="closeEditPatternModal">Close</button>
                <button class="osc-btn" id="saveEditPattern">Save Pattern</button>
            </div>
        </div>
    </div>

    <!-- Chord Name Modal -->
    <div id="chordNameModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a2e; padding: 30px; border-radius: 10px; min-width: 400px;">
            <h3 style="color: #8fb3d3; margin-bottom: 20px; text-align: center;">💾 Save Your Chord</h3>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: #8fb3d3;">Chord Name:</label>
                <input type="text" id="chordNameInput" placeholder="e.g. C, Dm, F?7, etc." style="width: 100%; padding: 10px; background: #2a4858; color: #fff; border: 2px solid #4a6870; border-radius: 6px; font-size: 16px;">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: #8fb3d3;">Selected Intervals:</label>
                <div id="selectedIntervalsDisplay" style="background: #2a4858; padding: 10px; border-radius: 6px; color: #fff; font-family: var(--retro-font);"></div>
            </div>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="osc-btn" id="cancelChordName" style="background: #666; border-color: #888;">Cancel</button>
                <button class="osc-btn" id="saveChordName" style="background: #2E8B57; border-color: #3CB371;">✅ Save Chord</button>
            </div>
        </div>
    </div>

    <!-- Text -> Chords Parser Modal -->
    <div id="textChordModal" style="display:none; position:fixed; inset:0; background: rgba(0,0,0,0.85); z-index: 1000;">
        <div style="position:absolute; top:50%; left:50%; transform: translate(-50%, -50%); background:#0f1f2c; border:2px solid #15506a; border-radius:12px; width:min(1000px, 94vw); max-height:90vh; overflow:auto; padding:18px; box-shadow:0 10px 30px rgba(0,0,0,0.6);">
            <div style="display:flex; align-items:center; gap:10px; justify-content:space-between; margin-bottom:10px; flex-wrap:wrap;">
                <h3 style="margin:0; color:#8fb3d3;">Type or Paste your chord sequence</h3>
                <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                    <label style="display:flex; align-items:center; gap:6px; color:#8fb3d3; font-size:12px;">
                        <input id="seqRepeat" type="checkbox" style="transform:translateY(1px)"> Repeat unique sections
                    </label>
                    <button class="osc-btn" id="closeTextChordModalBtn" style="background:#666; border-color:#888;">Close</button>
                </div>
            </div>
            <textarea id="textChordInput" placeholder="Type or Paste chord sequence here (use Roman numerals, e.g. I IV V | vi ii V)." style="width:100%; min-height:160px; background:#102a3a; color:#e8f5ff; border:1px solid #2b5567; border-radius:6px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; line-height:1.5; resize:vertical;"></textarea>

            <!-- Sequence preset controls -->
            <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
                <select id="seqPresetDropdown" style="background:#08222b; color:#e8f5ff; border:1px solid #1f5566; padding:6px; border-radius:6px; min-width:220px;"></select>
                <button class="osc-btn" id="addSeqPresetBtn" title="Save current text as a new preset">Save Preset</button>
                <button class="osc-btn" id="deleteSeqPresetBtn" title="Delete selected preset" style="background:#d9534f; border-color:#c9302c;">Delete</button>
                <button class="osc-btn" id="selectSeqPresetBtn" title="Load selected preset into textarea">Load</button>
            </div>

            <div style="margin-top:8px; display:flex; align-items:center; gap:10px;">
                <div style="font-size:12px; color:#8fb3d3;">Unique chords found:</div>
                <div id="textChordCount" style="font-size:12px; color:#f0f6ff;">0</div>
                <div style="margin-left:auto; display:flex; gap:8px;">
                    <button class="osc-btn" id="parseTextChordsBtn" style="background:#3498db; border-color:#2980b9;">Create Sequence</button>
                </div>
            </div>

            <div id="textChordResults" style="margin-top:10px; display:grid; grid-template-columns:repeat(auto-fill, minmax(120px, 1fr)); gap:8px;"></div>
        </div>
    </div>

    <!-- Tutorial Overlay -->
    <div id="tutorialOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999;">
        <div id="tutorialBox" style="position: fixed; top: 60px; left: 50%; transform: translateX(-50%); background: #1a1a2e; border: 2px solid #4a6870; border-radius: 10px; padding: 20px; max-width: 600px; max-height: 70vh; overflow-y: auto; z-index: 10000; box-shadow: 0 10px 30px rgba(0,0,0,0.8);">
            <h3 id="tutorialTitle" style="color: #8fb3d3; margin-top: 0;">Welcome to OMGnichord By James Mulvale / FASTFAST</h3>
            <p id="tutorialText" style="color: #fff; line-height: 1.5;">Click Next to start the tutorial.</p>
            <div style="margin-top: 15px; text-align: center; font-size: 12px; color: #8fb3d3; opacity: 0.9; background: rgba(74, 104, 112, 0.2); padding: 8px; border-radius: 5px;">
                💡 Press ESC, click outside, or use Skip Tutorial to exit anytime
            </div>
            <div style="margin-top: 20px; text-align: right;">
                <button id="tutorialPrev" class="osc-btn" style="margin-right: 10px;">Previous</button>
                <button id="tutorialNext" class="osc-btn">Next</button>
                <button id="tutorialSkip" class="osc-btn" style="margin-left: 10px; background: #dc2626;">Skip Tutorial</button>
            </div>
        </div>
    </div>

    <!-- Tutorial & Random Dice Buttons (moved top-right) -->
    <button id="tutorialButton" style="position: fixed; top: 12px; right: 14px; z-index: 9000; background: #4a6870; color: #fff; border: 2px solid #8fb3d3; border-radius: 50%; width: 56px; height: 56px; font-size: 24px; cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.4); font-weight: bold;" title="Start Tutorial">?</button>
    <button id="randomDiceButton" style="position: fixed; top: 82px; right: 14px; z-index: 9000; background: #6366f1; color: #fff; border: 2px solid #8b5cf6; border-radius: 50%; width: 56px; height: 56px; font-size: 24px; cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.45);" title="Randomize Settings">🎲</button>
    

    <script>
        // Disable verbose logging by default; toggle DEBUG to true for development
        (function(){
            const DEBUG = false;
            if (!DEBUG && window && window.console) {
                try {
                    console.debug = function(){};
                    console.log = function(){};
                } catch(_) {}
            }
        })();
        // Console output control: set localStorage.muteConsole = '1' to mute logs; otherwise keep logs enabled for debugging
        (function(){
            try {
                const shouldMute = typeof window !== 'undefined' && window.localStorage && window.localStorage.getItem('muteConsole') === '1';
                if (shouldMute && window.console) {
                    const methods = ['log','info','debug','warn','error','trace','group','groupCollapsed','groupEnd','time','timeEnd','table'];
                    methods.forEach(function(m){ if (typeof window.console[m] === 'function') window.console[m] = function(){}; });
                } else if (window && window.console && typeof window.console.info === 'function') {
                    console.info('[OMGnichord] Console logging ENABLED (set localStorage.muteConsole="1" to mute)');
                }
            } catch(_) {}
        })();
        class MicrotonalOmnichord { 
            constructor() {
                this.audioContext = null;
                this.gainNode = null;
                this.activeOscillators = new Map();
                this.currentTuning = 24;
                this.currentRoot = 0;
                this.currentQuality = 'major';
                this.volume = 0.75; // Max volume at -9dB (matches slider at 100%)
                this.masterVolume = 0.708; // Max at -3dB (0.708 linear gain) instead of -6dB
                this.isPlayingStrings = false;
                this.triggeredStrings = new Set();
                this.activeTouches = new Map();
                this.gamelanMode = false;
                // Track the column element that's currently active/last-played for live keyboard edits
                this.currentActiveColumnEl = null;
                // When true, render chord extensions (9/11/13) in higher octaves (two-octave split).
                // When false, fold all degrees into a single octave.
                // Default to compact one-octave voicing as requested.
                this.splitExtendedChordsAcrossOctaves = false;
                // Keyboard rotation across EDO steps (drag left/right rotates visible order)
                this.keyboardRotation = 0;
                // Editing flow flags
                this.isEditingChord = false;
                // Global transpose accumulator (steps from session start)
                this.transposeDelta = 0;
                // Debounced edit/save timers
                this.editArmed = false;
                this._editArmTimer = null;
                this._editSaveTimer = null;
                this.editingOriginalIndex = null;
                
                // ADSR envelope settings
                this.envelope = {
                    attack: 0.01,
                    decay: 0.2,
                    sustain: 0.7,
                    release: 0.8
                };
                
                // OSC 2 ADSR envelope settings
                this.osc2Envelope = {
                    attack: 0.005,
                    decay: 0.03,
                    sustain: 0.5,
                    release: 1.0
                };
                
                this.oscillatorType = 'sawtooth';
                
                // Dual oscillator settings with proper dB scaling
                this.oscillators = {
                    // Add pulseWidth (0-1) for pulse; keep detune as fine cents
                    osc1: { type: 'sine', detune: 0, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5 },
                    osc2: { type: 'sine', detune: -7, level: 5 * 0.125 / 10, octave: 0, coarse: 0, pulseWidth: 0.5 }
                };

                // Custom oscillator wavetable cache
                this._customWaveCache = new Map();
                
                // Mix mode functionality removed
                
                // Store original UI state for piano lock system
                this.originalUIState = null;

                // Piano-lock system state
                // Ensure these are always initialized so the 🎹 button works immediately
                this.pianoLockedChords = new Map();
                this.preloadedPresets = new Map();
                this.pianoLockPresetCounter = 0;
                
                // Panning settings
                this.panning = {
                    mode: 'center', // 'center', 'frequency', 'random', 'rotating', 'alternating'
                    width: 0.8, // How wide the stereo field is
                    speed: 2000, // Speed for rotating/alternating modes (ms)
                    rotationAngle: 0, // Current rotation angle
                    alternateState: false // Current side for alternating
                };
                
                // Simple reverb settings
                this.reverb = {
                    wet: 0.00, // 0% reverb by default
                    decay: 0.0, // 0 seconds decay
                    roomSize: 0.5,
                    filterCutoff: 8000
                };
                
                // Audio nodes
                this.reverbNode = null;
                this.wetGainNode = null;
                this.dryGainNode = null;
                this.reverbFilterNode = null;
                
                // No default chord extensions - start completely empty unless locked chords exist
                this.defaultChordExtensions = [];
                
                // Load user's chord configuration and locked chords
                const savedChords = this.loadChordConfiguration();
                const lockedChords = this.loadLockedChords();
                
                // Clear unlocked chords from memory on first start - only load pre-locked chords
                console.log('?? Clearing unlocked chords from memory on startup');
                
                // Start with only locked chords (if any exist)
                if (lockedChords && lockedChords.length > 0) {
                    console.log('?? Loading only pre-locked chords from previous session:', lockedChords.length, 'chords');
                    this.chordExtensions = lockedChords.map(locked => ({
                        name: locked.chordName,
                        intervals: locked.intervals,
                        getChordIntervals(extensions = []) {
                            // Return canonical 12-TET semitone intervals; mapping to current EDO happens in mapIntervalToEDO
                            let intervals = [0]; // Root (0 semitones)

                            // Base triad (in semitones)
                            switch (this.currentQuality) {
                                case 'major':
                                    intervals.push(4); // Major third
                                    intervals.push(7); // Perfect fifth
                                    break;
                                case 'minor':
                                    intervals.push(3); // Minor third
                                    intervals.push(7); // Perfect fifth
                                    break;
                                case 'neutral':
                                    intervals.push(3.5); // Neutral third (microtonal)
                                    intervals.push(7);
                                    break;
                            }

                            // Apply extensions (still in semitones)
                            extensions.forEach(ext => {
                                switch (ext) {
                                    case '6':
                                        intervals.push(9);
                                        break;
                                    case '7':
                                        intervals.push(10);
                                        break;
                                    case 'maj7':
                                        intervals.push(11);
                                        break;
                                    case '9':
                                        intervals.push(10); // include 7th
                                        intervals.push(14); // 9th
                                        break;
                                    case 'sus2':
                                        intervals = intervals.filter(i => i !== 4 && i !== 3 && i !== 3.5);
                                        intervals.push(2);
                                        break;
                                    case 'sus4':
                                        intervals = intervals.filter(i => i !== 4 && i !== 3 && i !== 3.5);
                                        intervals.push(5);
                                        break;
                                    case 'add9':
                                        intervals.push(14);
                                        break;
                                    case '13':
                                        intervals.push(10); // 7th
                                        intervals.push(21); // 13th
                                        break;
                                    case '#11':
                                        intervals.push(18);
                                        break;
                                    case '7#9':
                                        intervals.push(10);
                                        intervals.push(15);
                                        break;
                                    case '#9':
                                        intervals.push(15);
                                        break;
                                    case 'n7':
                                        intervals.push(10.5); // neutral 7th
                                        break;
                                    default:
                                        break;
                                }
                            });

                            return intervals;
                        }
                    }));
                } else {
                    // No pre-locked chords; start with an empty palette
                    this.chordExtensions = [];
                }
                this.previewInterval = null;
                this.tempChordAudio = new Map(); // For preview audio
                // Track selection entry order for slash-bass inference
                this.selectedIntervals = [];
                this.selectedIntervalsOrder = [];
                // Track a newly created blank chord to inherit notes on first external strum
                this.pendingBlankChordId = null;
                
                // Clean up corrupted palette data
                this.cleanupPaletteData();
                
                // Initialize audio immediately (will be suspended until a gesture, then resumed)
                this.initAudio();
                // Also set up resume attempts on common gestures to satisfy autoplay policies
                const tryResume = () => { if (this.audioContext && this.audioContext.state === 'suspended') { this.audioContext.resume().catch(()=>{}); } };
                document.addEventListener('pointerdown', tryResume, { once: false });
                document.addEventListener('keydown', tryResume, { once: false });
                document.addEventListener('click', tryResume, { once: false });
                document.addEventListener('touchstart', tryResume, { once: false, passive: false });
                this.initEventListeners();
                this.generateRootButtons();
                this.generateExtensionColumns();
                // Ensure we always have an active column so keyboard taps edit that chord
                try {
                    const firstCol = document.querySelector('.extension-column');
                    if (firstCol) { this.currentActiveColumnEl = firstCol; }
                } catch(_) {}
                
                // Ready for chord creation with New Chord button, but don't auto-enter chord mode
                console.log('?? Ready for chord creation - tuning and root can be changed freely');
                // DO NOT auto-enter chord creation mode - let user click "New Chord" when ready
                // Arm editing after idle
                this._scheduleEditArm();
                
                this.updateChordDisplay();
                this.setupSonicChords();
                this.initChordBuilder();

                // Text → Chords parser wiring
                this.initTextChordParser();

                // Wire instrument presets UI
                this.wireInstrumentPresetsUI();
            }

            // After 500ms idle, arm editing so the next keyboard taps go into chordbox
            _scheduleEditArm() {
                clearTimeout(this._editArmTimer);
                this._editArmTimer = setTimeout(() => { this.editArmed = true; }, 500);
            }

            // After any change, debounce save by 500ms; saving here just refreshes header/strings
            _scheduleEditSave(column) {
                clearTimeout(this._editSaveTimer);
                this._editSaveTimer = setTimeout(() => {
                    try {
                        if (column) this.highlightKeyboardForColumn(column);
                    } catch {}
                }, 500);
            }

            // Compute a subtle vibration period in ms for a given frequency and step index
            // Uses audio period (1/f) clamped to sensible range and snaps roots to wavelength series 1,2,4,8,16,32,64,128 as slower pulses
            computeVibrationPeriod(freq, stepIndex = 0) {
                const baseMs = Math.max(12, Math.min(90, 1000 / Math.max(1, freq))); // 12–90ms
                // Treat exact roots (interval 0) specially if the EDO step index equals currentRoot
                // We can't know the interval reliably here in all contexts; as a proxy: if stepIndex % currentTuning == currentRoot treat as root
                try {
                    const isRootish = ((stepIndex % this.currentTuning) === (this.currentRoot % this.currentTuning));
                    if (isRootish) {
                        // Map to one of 1..128 multipliers but cap to a gentle 32x to avoid too slow visuals
                        const multipliers = [1,2,4,8,16,32];
                        const idx = Math.min(multipliers.length - 1, Math.floor((freq || 1) / 110));
                        return Math.round(baseMs * multipliers[idx]);
                    }
                } catch {}
                return Math.round(baseMs);
            }

            // Initialize standard chord types with proper musical symbols
            initializeStandardChordTypes() {
                return [
                    // Triads
                    { name: '', symbol: '', intervals: [0, 4, 7], description: 'Major triad' },
                    { name: 'm', symbol: 'm', intervals: [0, 3, 7], description: 'Minor triad' },
                    { name: '°', symbol: '°', intervals: [0, 3, 6], description: 'Diminished triad' },
                    { name: '+', symbol: '+', intervals: [0, 4, 8], description: 'Augmented triad' },
                    { name: 'sus2', symbol: 'sus2', intervals: [0, 2, 7], description: 'Suspended 2nd' },
                    { name: 'sus4', symbol: 'sus4', intervals: [0, 5, 7], description: 'Suspended 4th' },
                    
                    // Seventh chords
                    { name: '7', symbol: '7', intervals: [0, 4, 7, 10], description: 'Dominant 7th' },
                    { name: 'M7', symbol: 'Δ7', intervals: [0, 4, 7, 11], description: 'Major 7th' },
                    { name: 'm7', symbol: 'm7', intervals: [0, 3, 7, 10], description: 'Minor 7th' },
                    { name: 'mM7', symbol: 'mΔ7', intervals: [0, 3, 7, 11], description: 'Minor major 7th' },
                    { name: '°7', symbol: '°7', intervals: [0, 3, 6, 9], description: 'Diminished 7th' },
                    { name: 'ø7', symbol: 'ø7', intervals: [0, 3, 6, 10], description: 'Half-diminished 7th' },
                    { name: '+7', symbol: '+7', intervals: [0, 4, 8, 10], description: 'Augmented 7th' },
                    
                    // Extended chords
                    { name: '9', symbol: '9', intervals: [0, 4, 7, 10, 14], description: 'Dominant 9th' },
                    { name: 'M9', symbol: 'Δ9', intervals: [0, 4, 7, 11, 14], description: 'Major 9th' },
                    { name: 'm9', symbol: 'm9', intervals: [0, 3, 7, 10, 14], description: 'Minor 9th' },
                    { name: '11', symbol: '11', intervals: [0, 4, 7, 10, 14, 17], description: 'Dominant 11th' },
                    { name: 'M11', symbol: 'Δ11', intervals: [0, 4, 7, 11, 14, 17], description: 'Major 11th' },
                    { name: 'm11', symbol: 'm11', intervals: [0, 3, 7, 10, 14, 17], description: 'Minor 11th' },
                    { name: '13', symbol: '13', intervals: [0, 4, 7, 10, 14, 17, 21], description: 'Dominant 13th' },
                    { name: 'M13', symbol: 'Δ13', intervals: [0, 4, 7, 11, 14, 17, 21], description: 'Major 13th' },
                    { name: 'm13', symbol: 'm13', intervals: [0, 3, 7, 10, 14, 17, 21], description: 'Minor 13th' },
                    
                    // Altered dominants
                    { name: '7♭5', symbol: '7♭5', intervals: [0, 4, 6, 10], description: 'Dominant 7 flat 5' },
                    { name: '7#5', symbol: '7♯5', intervals: [0, 4, 8, 10], description: 'Dominant 7 sharp 5' },
                    { name: '7♭9', symbol: '7♭9', intervals: [0, 4, 7, 10, 13], description: 'Dominant 7 flat 9' },
                    { name: '7#9', symbol: '7♯9', intervals: [0, 4, 7, 10, 15], description: 'Dominant 7 sharp 9' },
                    { name: '7♭5♭9', symbol: '7♭5♭9', intervals: [0, 4, 6, 10, 13], description: 'Dominant 7 flat 5 flat 9' },
                    { name: '7#5#9', symbol: '7♯5♯9', intervals: [0, 4, 8, 10, 15], description: 'Dominant 7 sharp 5 sharp 9' },
                    
                    // Add chords (no 3rd)
                    { name: 'add9', symbol: 'add9', intervals: [0, 4, 7, 14], description: 'Major add 9' },
                    { name: 'madd9', symbol: 'madd9', intervals: [0, 3, 7, 14], description: 'Minor add 9' },
                    { name: 'add11', symbol: 'add11', intervals: [0, 4, 7, 17], description: 'Major add 11' },
                    { name: 'madd11', symbol: 'madd11', intervals: [0, 3, 7, 17], description: 'Minor add 11' },
                    
                    // Slash chords (bass notes)
                    { name: '/3', symbol: '/3', intervals: [4, 0, 7], description: 'Major first inversion' },
                    { name: '/5', symbol: '/5', intervals: [7, 0, 4], description: 'Major second inversion' },
                    { name: 'm/♭3', symbol: 'm/♭3', intervals: [3, 0, 7], description: 'Minor first inversion' },
                    { name: 'm/5', symbol: 'm/5', intervals: [7, 0, 3], description: 'Minor second inversion' }
                ];
            }
            
            // Generate standard chord progressions for practice
            generateStandardChordProgression(rootNote = 'C', progressionType = 'ii-V-I') {
                const progressions = {
                    'ii-V-I': ['m7', '7', 'M7'],
                    'vi-IV-I-V': ['m', '', '', '7'],
                    'I-vi-IV-V': ['', 'm', '', '7'],
                    'blues': ['7', '7', '7', '7', '7', '7', '7', '7', '7', '7', '7', '7'],
                    'jazz-blues': ['M7', '7', 'M7', 'M7', '7', '7', 'M7', 'm7', 'm7', '7', 'M7', '7']
                };
                
                const progression = progressions[progressionType] || progressions['ii-V-I'];
                const chords = [];
                
                progression.forEach((chordSymbol, index) => {
                    const chordType = this.standardChordTypes.find(type => type.symbol === chordSymbol);
                    if (chordType) {
                        chords.push({
                            root: rootNote,
                            type: chordType,
                            symbol: rootNote + chordSymbol
                        });
                    }
                });
                
                return chords;
            }
            
            // Create basic chord set for beginners
            createBasicChordSet() {
                // User-requested basic chord set (only these, no others)
                const basicChords = [
                    { name: 'Major',        symbol: '',   intervals: [0,4,7],          description: 'Major triad' },
                    { name: 'Minor',        symbol: 'm',  intervals: [0,3,7],          description: 'Minor triad' },
                    { name: '7th',          symbol: '7',  intervals: [0,4,7,10],       description: 'Dominant 7th' },
                    { name: 'minor 7th',    symbol: 'm7', intervals: [0,3,7,10],       description: 'Minor 7th' },
                    { name: 'Major 7th',    symbol: 'M7', intervals: [0,4,7,11],       description: 'Major 7th' },
                    { name: '6th',          symbol: '6',  intervals: [0,4,7,9],        description: 'Major 6th' },
                    { name: '9th',          symbol: '9',  intervals: [0,4,7,10,14],    description: 'Dominant 9th' },
                    { name: 'sus4',         symbol: 'sus4', intervals:[0,5,7],         description: 'Suspended 4th' },
                    { name: 'sus2',         symbol: 'sus2', intervals:[0,2,7],         description: 'Suspended 2nd' },
                    { name: 'Diminished',   symbol: 'dim', intervals:[0,3,6],          description: 'Diminished triad' },
                    { name: 'Augmented',    symbol: 'aug', intervals:[0,4,8],          description: 'Augmented triad' }
                ];

                this.chordExtensions = basicChords.map(chord => ({
                    name: chord.name,
                    intervals: chord.intervals,
                    description: chord.description,
                    symbol: chord.symbol,
                    isCustom: false
                }));

                console.log('✓ Created requested basic chord set:', this.chordExtensions.length, 'chords');
                this.updateChordDisplay();
                this.generateExtensionColumns();
            }

            cleanupPaletteData() {
                // Clean up any corrupted palette chord data
                if (this.paletteChords && Array.isArray(this.paletteChords)) {
                    const originalLength = this.paletteChords.length;
                    this.paletteChords = this.paletteChords.filter(chord => {
                        return chord && typeof chord === 'object' && chord.name && chord.intervals;
                    });
                    
                    if (this.paletteChords.length !== originalLength) {
                        console.log('?? Cleaned up corrupted palette data:', originalLength, '->', this.paletteChords.length);
                        // localStorage removed - no longer saving palette chords
                    }
                } else {
                    console.log('?? Resetting corrupted palette data');
                    this.paletteChords = [];
                    // localStorage removed - no longer saving palette chords
                }
            }

            getTuningDisplayName() {
                if (this.gamelanMode) return 'Gamelan';
                switch(this.currentTuning) {
                    case 5: return '5-EDO';
                    case 7: return '7-EDO';
                    case 11: return 'C.Gamma';
                    case 12: return '12-TET';
                    case 15: return '15-EDO';
                    case 17: return '17-EDO';
                    case 19: return '19-TET';
                    case 22: return '22-TET';
                    case 24: return '24-TET';
                    case 31: return '31-TET';
                    case 34: return '34-TET';
                    case 53: return '53-TET';
                    default: return `${this.currentTuning}-TET`;
                }
            }

            // =============================================================================
            // UNIFIED CHORD BUILDER MODULE - Single source of truth for all chord creation
            // =============================================================================
            
            initChordBuilder() {
                // Simple chord builder initialization (removed custom patterns button)
                
                // New chord creation button → WYSIWYG: spawn a blank editable column immediately
                document.getElementById('createNewChordBtn').addEventListener('click', () => {
                    try { this.createBlankChordColumn(); } catch (e) { console.error('Create blank chord failed:', e); }
                });
                
                // Basic chords creation button (moved into SEQUENCE modal); keep guard if present in DOM
                const basicBtnLegacy = document.getElementById('createBasicChordsBtn');
                if (basicBtnLegacy) {
                    basicBtnLegacy.addEventListener('click', () => {
                        if (confirm('Load basic chord set? This will replace any existing unlocked chords.')) {
                            this.createBasicChordSet();
                        }
                    });
                }
                
                // Reset chords button
                document.getElementById('resetChordsBtn').addEventListener('click', () => {
                    if (confirm('Clear all unlocked chords? This will remove only unlocked chords, preserving all locked chords.')) {
                        this.clearUnlockedChords();
                    }
                });
                
                // Save session button
                document.getElementById('saveSessionBtn').addEventListener('click', () => {
                    this.saveSessionToFile();
                });
                
                // Load session button
                document.getElementById('loadSessionBtn').addEventListener('click', () => {
                    document.getElementById('loadSessionInput').click();
                });
                
                // File input for loading sessions
                document.getElementById('loadSessionInput').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.loadSessionFromFile(file)
                            .then(() => {
                                alert('Session loaded successfully!');
                            })
                            .catch((error) => {
                                alert('Error loading session: ' + error.message);
                            });
                    }
                });
                
                // EDO inputs (panel + quick bar)
                const edoPanel = document.getElementById('edoDivisions');
                if (edoPanel) {
                    edoPanel.addEventListener('change', (e) => {
                        const v = Math.max(5, Math.min(52, parseInt(e.target.value)));
                        e.target.value = String(v);
                        this.updateTuningSystem(v);
                        const qi = document.getElementById('edoQuickInput');
                        if (qi) qi.value = String(v);
                    });
                }
                const edoQuick = document.getElementById('edoQuickInput');
                if (edoQuick) {
                    edoQuick.addEventListener('change', (e) => {
                        const v = Math.max(5, Math.min(52, parseInt(e.target.value)));
                        e.target.value = String(v);
                        this.updateTuningSystem(v);
                        const p = document.getElementById('edoDivisions');
                        if (p) p.value = String(v);
                    });
                }
            }
            
            // ============= NEW CHORD CREATION SYSTEM =============
            
            enterChordCreationMode() {
                console.log('?? Entering chord creation mode');
                this.chordCreationMode = true;
                // When entering fresh creation mode (not from edit), clear edit flags
                if (!this.isEditingChord) {
                    this.editingOriginalIndex = null;
                }
                // Start blank: no notes pre-selected
                this.selectedIntervals = [];
                this.previewInterval = null;
                
                // Change UI to creation mode
                document.body.classList.add('chord-creation-mode');
                
                // Add a preview chord column immediately
                this.addPreviewChordColumn();
                
                // Update create button to save mode
                const createBtn = document.getElementById('createNewChordBtn');
                createBtn.textContent = 'Save Chord';
                createBtn.style.background = '#e74c3c';
                createBtn.style.borderColor = '#c0392b';
                
                // Update root button behavior for interval selection
                if (typeof this.closeBottomPanel === 'function') this.closeBottomPanel();
                this.setupIntervalSelection();
            }
            
            exitChordCreationMode() {
                console.log('?? Exiting chord creation mode');
                this.chordCreationMode = false;
                this.isEditingChord = false;
                this.editingOriginalIndex = null;
                // Return to blank state
                this.selectedIntervals = [];
                this.previewInterval = null;
                
                // Stop any preview audio
                this.stopPreviewAudio();
                
                // Remove preview column if it exists
                this.removePreviewChordColumn();
                
                // Restore UI
                document.body.classList.remove('chord-creation-mode');
                
                // Restore create button
                const createBtn = document.getElementById('createNewChordBtn');
                createBtn.textContent = '+';
                createBtn.style.background = '';
                createBtn.style.borderColor = '';
                
                // Restore normal root button behavior
                this.restoreNormalRootButtons();
            }
            
            setupIntervalSelection() {
                // Target all elements with data-step (keys + micro dots)
                const interactive = document.querySelectorAll('#rootGrid [data-step]');
                interactive.forEach(el => {
                    const step = parseInt(el.dataset.step,10);
                    // Replace node to remove previous listeners (root selection)
                    const clone = el.cloneNode(true);
                    el.parentNode.replaceChild(clone, el);
                    clone.classList.remove('preview');
                    // Maintain root highlight separately (active) but allow selection highlighting (selected)
                    // Consider selection across any octave layer: highlight base key if any selected iv maps to this step mod EDO
                    const edo = this.currentTuning || 12;
                    const isSelected = (this.selectedIntervals||[]).some(iv => ((iv % edo)+edo)%edo === step);
                    if (isSelected) clone.classList.add('selected'); else clone.classList.remove('selected');
                    clone.addEventListener('click', (e)=>{
                        e.stopPropagation();
                        // Clear any hover preview so the clicked element's state updates immediately
                        this.previewInterval = null;
                        try {
                            document.querySelectorAll('#rootGrid [data-step].preview').forEach(x=> x.classList.remove('preview'));
                        } catch {}
                        this.toggleInterval(step);
                    });
                    clone.addEventListener('mouseenter', ()=> this.previewInterval(step));
                    clone.addEventListener('mouseleave', ()=> this.clearPreview());
                });
            }
            
            toggleInterval(interval) {
                
                // dataset.step is already the absolute step; pan offset was applied during generation
                const absStep = interval;
                const index = this.selectedIntervals.indexOf(absStep);
                if (index > -1) {
                    // Remove interval
                    this.selectedIntervals.splice(index, 1);
                    const oi = this.selectedIntervalsOrder.indexOf(absStep);
                    if (oi > -1) this.selectedIntervalsOrder.splice(oi, 1);
                } else {
                    // Add interval
                    this.selectedIntervals.push(absStep);
                    this.selectedIntervals.sort((a, b) => a - b);
                    // Preserve entry order separately (no sorting)
                    if (!this.selectedIntervalsOrder.includes(absStep)) this.selectedIntervalsOrder.push(absStep);
                }
                
                // Update button states
                this.updateIntervalButtons();

                // Do not force any note if empty; allow blank state
                // Update the preview chord column immediately
                this.updatePreviewChordColumn();
                // Immediate name update (lowest note as root)
                try {
                    const header = document.querySelector('#previewChordColumn .chord-name');
                    if (header) {
                        if (this.selectedIntervals.length>1) {
                            const edo = this.currentTuning || 12;
                            const absSteps = this.selectedIntervals.map(iv => ((iv % edo) + edo) % edo);
                            const preferredBass = (this.selectedIntervalsOrder && this.selectedIntervalsOrder.length>0)
                                ? ((this.selectedIntervalsOrder[0] % edo)+edo)%edo : null;
                            header.textContent = this.computeFullChordNameFromAbsoluteSteps(absSteps, edo, preferredBass) || 'New Chord';
                        } else {
                            header.textContent = 'Select notes…';
                        }
                    }
                } catch {}
                
                console.log('🎵 Selected intervals (steps):', this.selectedIntervals);
                console.log('🎵 Button clicked (step -> abs):', interval, '->', absStep);
            }
            
            previewInterval(interval) {
                // In chord creation mode, intervals are direct microtonal steps
                if (this.selectedIntervals.includes(interval)) return;
                
                this.previewInterval = interval;
                this.updateIntervalButtons();
                
                // Play single note preview using microtonal interval
                this.playNotePreview(interval);
            }

            // Create a brand-new blank chord column (no carry-over), set it active, and arm editing
            createBlankChordColumn() {
                // Ensure chord extensions array exists
                if (!Array.isArray(this.chordExtensions)) this.chordExtensions = [];
                const id = `custom_${Date.now()}_${Math.floor(Math.random()*1e6)}`;
                const newChord = {
                    id,
                    name: 'New',
                    intervals: [], // start blank; user taps to add
                    isCustom: true,
                    quality: 'custom',
                    position: this.chordExtensions.length
                };
                this.chordExtensions.push(newChord);
                // Track this as a pending blank chord eligible for inheritance on next external strum
                this.pendingBlankChordId = id;
                if (typeof this.saveChordConfiguration === 'function') {
                    try { this.saveChordConfiguration(); } catch (_) {}
                }
                // Regenerate grid and focus the new column
                this.generateExtensionColumns();
                // Find the column by data-chord-id
                const column = document.querySelector(`.extension-column[data-chord-id='${id}']`);
                if (column) {
                    // Initialize per-column state
                    column.dataset.localTranspose = '0';
                    // Replace strings with a blank prompt area
                    try { this.generateStringsForColumn(column, [], true); } catch (_) {}
                    // Make it the active column and clear keyboard highlights
                    this.currentActiveColumnEl = column;
                    this.editArmed = true; // ready to capture key taps
                    try { this.highlightKeyboardForColumn(column); } catch(_) {}
                    // Scroll into view slightly
                    try { column.scrollIntoView({behavior:'smooth', block:'nearest', inline:'center'}); } catch(_){ }
                }
            }
            
            clearPreview() {
                this.previewInterval = null;
                this.updateIntervalButtons();
                this.stopPreviewAudio();
            }
            
        updateIntervalButtons() {
                const all = document.querySelectorAll('#rootGrid [data-step]');
                all.forEach(el=>{
                    const step = parseInt(el.dataset.step,10);
                    el.classList.remove('selected','preview');
            const edo = this.currentTuning || 12;
            const isSelected = (this.selectedIntervals||[]).some(iv => ((iv % edo)+edo)%edo === step);
            if (isSelected) {
                        el.classList.add('selected');
                    } else if (this.previewInterval === step) {
                        el.classList.add('preview');
                    }
                });
            }
            
            async playNotePreview(interval) {
                this.stopPreviewAudio();
                
                const audioReady = await this.ensureAudioContext();
                if (!audioReady) return;
                
                // Use current tuning and audition around middle octave for audibility
                // In chord-creation mode, the interval is already an absolute EDO step.
                // Otherwise, treat it as relative to the current root.
                const edo = this.currentTuning || 12;
                const absStep = this.chordCreationMode
                    ? ((interval % edo) + edo) % edo
                    : (((this.currentRoot || 0) + (interval % edo)) % edo + edo) % edo;
                const frequency = this.getFrequency(absStep, 4, this.currentTuning);
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.1, this.audioContext.currentTime + 0.05);
                
                oscillator.connect(gainNode);
                // Route through master chain (global wet/dry + reverb)
                gainNode.connect(this.gainNode);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.3);
                
                this.tempChordAudio.set('preview', { oscillator, gainNode });
            }
            
            async playChordPreview() {
                this.stopPreviewAudio();
                
                const audioReady = await this.ensureAudioContext();
                if (!audioReady || this.selectedIntervals.length === 0) return;
                
                // Play all selected intervals as a chord
                this.selectedIntervals.forEach((interval, index) => {
                    const edo = this.currentTuning || 12;
                    const absStep = this.chordCreationMode
                        ? ((interval % edo) + edo) % edo
                        : (((this.currentRoot || 0) + (interval % edo)) % edo + edo) % edo;
                    const frequency = this.getFrequency(absStep, 4, this.currentTuning);
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.05, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 1.0);
                    
                    oscillator.connect(gainNode);
                    // Route through master chain (global wet/dry + reverb)
                    gainNode.connect(this.gainNode);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 1.0);
                    
                    this.tempChordAudio.set(`chord-${index}`, { oscillator, gainNode });
                });
            }
            
            stopPreviewAudio() {
                this.tempChordAudio.forEach(({ oscillator, gainNode }) => {
                    try {
                        gainNode.gain.setValueAtTime(gainNode.gain.value, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.05);
                        oscillator.stop(this.audioContext.currentTime + 0.05);
                    } catch (e) {
                        // Oscillator might already be stopped
                    }
                });
                this.tempChordAudio.clear();
            }
            
            saveNewChordAutomatic() {
                if (this.selectedIntervals.length < 2) {
                    alert('Please select at least 2 intervals (including root)');
                    return;
                }
                
                // Always compute name with the lowest note as root
                this.finalizePreviewChord(null);
                
                console.log(`?? Auto-saved new chord from lowest note root`, this.selectedIntervals);
                
                // Exit creation mode
                this.exitChordCreationMode();
            }
            
            saveNewChord() {
                let chordName = document.getElementById('chordNameInput').value.trim();
                
                if (!chordName) {
                    // Fall back to computed root+quality from preview
                    if (this.selectedIntervals.length >= 2) {
                        this.finalizePreviewChord(null);
                        this.exitChordCreationMode();
                        return;
                    } else {
                        alert('Please select at least 2 intervals (including root)');
                        return;
                    }
                }
                
                if (this.selectedIntervals.length < 2) {
                    alert('Please select at least 2 intervals (including root)');
                    return;
                }
                // Prefer the provided name but we still re-root by lowest tone when saving
                this.finalizePreviewChord(chordName);
                console.log(`?? Saved new chord with provided name (re-rooted by lowest tone): ${chordName}`, this.selectedIntervals);
                
                // Exit creation mode
                this.exitChordCreationMode();
            }
            
            addPreviewChordColumn() {
                // Create a temporary preview chord column at the end
                const extensionColumns = document.getElementById('extensionColumns');
                if (!extensionColumns) return;
                
                const previewColumn = document.createElement('div');
                previewColumn.className = 'extension-column preview-chord-column';
                previewColumn.id = 'previewChordColumn';
                previewColumn.style.border = '3px dashed #2E8B57';
                previewColumn.style.background = 'rgba(46, 139, 87, 0.1)';
                
                // Add header
                const header = document.createElement('div');
                header.className = 'extension-header';
                header.style.background = 'rgba(46, 139, 87, 0.8)';
                header.innerHTML = '<span class="chord-name">New Chord</span>';
                previewColumn.appendChild(header);
                
                // Add strings container
                const stringsContainer = document.createElement('div');
                stringsContainer.className = 'strings-column';
                stringsContainer.id = 'previewStringsContainer';
                previewColumn.appendChild(stringsContainer);
                
                // Add note labels
                const noteLabels = document.createElement('div');
                noteLabels.className = 'note-labels';
                noteLabels.id = 'previewNoteLabels';
                previewColumn.appendChild(noteLabels);
                
                extensionColumns.appendChild(previewColumn);
                
                // Add touch gesture support for strumming the preview chord
                this.addTouchGestureToElement(previewColumn, 'chord');
                this.addClickGestureToElement(previewColumn, 'chord');
                
                // Initial update with root note
                this.updatePreviewChordColumn();
            }
            
            updatePreviewChordColumn() {
                const stringsContainer = document.getElementById('previewStringsContainer');
                const noteLabels = document.getElementById('previewNoteLabels');
                const header = document.querySelector('#previewChordColumn .chord-name');
                
                if (!stringsContainer || !noteLabels || !header) return;
                
                // Clear existing strings
                stringsContainer.innerHTML = '';
                
                // Name from lowest absolute steps for consistency with main columns
                if (this.selectedIntervals && this.selectedIntervals.length > 1) {
                    const edo = this.currentTuning || 12;
                    const absSteps = this.selectedIntervals.map(iv => ((iv % edo) + edo) % edo);
                    const label = this.computeFullChordNameFromAbsoluteSteps(absSteps, edo);
                    header.textContent = label || 'New Chord';
                } else {
                    header.textContent = 'Select notes…';
                }
                
                // Use the same string generation as the main fretboard
                this.generateStringsForPreviewColumn(stringsContainer, this.selectedIntervals);
                
                // Update note labels
                const noteNames = this.selectedIntervals.map(interval => {
                    const edo = this.currentTuning || 12;
                    const absStep = ((interval % edo) + edo) % edo;
                    return this.getMicrotonalNoteName(absStep);
                });
                noteLabels.textContent = noteNames.join(' ');
            }
            
            generateStringsForPreviewColumn(container, intervals) {
                // Clear any existing content
                container.innerHTML = '';
                const tuningSize = this.currentTuning || this.getTuningStepsPerOctave();
                // Nothing to show until we have at least 2 tones (root + one)
                const nonRoot = (intervals||[]).filter(iv => iv !== 0);
                if (!intervals || intervals.length < 2 || nonRoot.length === 0) {
                    return;
                }
                
                // Use the EXACT same system as generateStringsForColumn 
                const noteNames = this.getNoteNames();
                // Optionally duplicate selected intervals up one octave for quick two-octave entries
                let ivs = [...intervals];
                
                // Generate string frequencies for full C1-C8 octave range (8 full octaves)
                const stringFreqs = [];
                for (let octave = 1; octave <= 8; octave++) {
                    ivs.forEach(interval => {
                        // In creation preview, intervals are absolute EDO steps
                        const step = ((interval % tuningSize) + tuningSize) % tuningSize;
                        const freq = this.getFrequency(step, octave, this.currentTuning);
                        stringFreqs.push({ freq, step, octave, interval });
                    });
                }
                
                // Sort by frequency to ensure proper ordering
                stringFreqs.sort((a, b) => a.freq - b.freq);
                
                // Calculate string sizing to MATCH main column behavior (fill height uniformly)
                const previewColumn = document.getElementById('previewChordColumn');
                const availableHeight = (previewColumn ? previewColumn.offsetHeight : 500);
                const headerHeight = 40;
                const stringsHeight = availableHeight - headerHeight - 2; // minimal padding
                const numStrings = stringFreqs.length || 1;
                const stringHeight = Math.max(1, Math.floor(stringsHeight / numStrings) - 0.5);
                const stringMargin = 0.2; // minimal margin for tight packing
                
                // Style the container exactly like main columns
                container.style.cssText = `
                    flex: 1;
                    overflow: hidden;
                    padding: 1px;
                    height: calc(100% - ${headerHeight}px);
                    display: flex;
                    flex-direction: column;
                    justify-content: space-evenly;
                `;
                // Subtle root tint for preview using detected root from selected intervals
                try {
                    const edo = this.currentTuning || 12;
                    const t = (this.transposeDelta || 0) % edo;
                    const steps = (intervals||[]).map(s => (((s + t) % edo) + edo) % edo).sort((a,b)=> this.stepToSemitone(a, edo)-this.stepToSemitone(b, edo));
                    const bass = steps[0];
                    const semi = this.stepToSemitone(bass, edo);
                    const accent = this.getChromaticColorForSemitone(semi) || '#000000';
                    const tint = (hex => {
                        const m = /^#?([0-9a-f]{6})$/i.exec(hex || '');
                        if (!m) return 'rgba(0,0,0,0)';
                        const n = parseInt(m[1], 16);
                        let r = (n >> 16) & 0xff, g = (n >> 8) & 0xff, b = n & 0xff;
                        r = Math.max(6, Math.floor(r * 0.08));
                        g = Math.max(6, Math.floor(g * 0.08));
                        b = Math.max(6, Math.floor(b * 0.08));
                        return `linear-gradient(to bottom, rgba(${r},${g},${b},0.12), rgba(${r},${g},${b},0.08))`;
                    })(accent);
                    container.style.setProperty('--root-tint-gradient', tint);
                } catch (_) {}
                
                stringFreqs.forEach((stringData, stringIndex) => {
                    const stringEl = document.createElement('div');
                    stringEl.className = 'string';
                    stringEl.dataset.index = stringIndex;
                    stringEl.dataset.column = 'preview';
                    stringEl.dataset.frequency = stringData.freq;
                    stringEl.dataset.noteIndex = stringData.step;

                    // Interval color and glow
                    const intervalColor = this.getIntervalColor(stringData.interval);
                    const baseColor = intervalColor.color;
                    const glowColor = (baseColor && baseColor.toLowerCase() === '#000000') ? '#555555' : baseColor;
                    stringEl.dataset.glowColor = glowColor;

                    // Visible core
                    const core = document.createElement('div');
                    core.className = 'string-core';
                    core.style.background = baseColor;
                    core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;

                    // Tooltip
                    stringEl.title = `${intervalColor.name} - ${noteNames[stringData.step] || `Note ${stringData.step}`} - Oct${stringData.octave} - ${stringData.freq.toFixed(1)}Hz`;

                    // Hover effects
                    stringEl.addEventListener('mouseenter', () => {
                        core.style.transform = 'scaleY(1.25)';
                        core.style.boxShadow = `0 0 6px ${glowColor}, 0 0 14px ${glowColor}CC, 0 0 28px ${glowColor}88`;
                    });
                    stringEl.addEventListener('mouseleave', () => {
                        core.style.transform = 'scaleY(1)';
                        core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;
                    });

                    // Click handlers
                    stringEl.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        this.playPreviewString(stringEl, stringData.freq, stringData.interval);
                    });
                    stringEl.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.playPreviewString(stringEl, stringData.freq, stringData.interval);
                    });

                    // Attach core and row
                    stringEl.appendChild(core);
                    container.appendChild(stringEl);

                    // Precompute vibration period and store on core
                    const period = this.computeVibrationPeriod(stringData.freq, stringData.step);
                    core.style.setProperty('--vib-period', period + 'ms');
                });
                // Ensure all generated octave strings fit within visible area (rescale heights if needed)
                this.ensureStringsFullyVisible(container);
            }
            
            playPreviewString(stringElement, frequency, interval) {
                // Neon active feedback using per-string glow color
                const glow = stringElement.dataset.glowColor || this.getIntervalColor(interval).color || '#FFFFFF';
                const core = stringElement.querySelector('.string-core');
                if (core) {
                    core.style.transform = 'scaleY(1.3)';
                    core.style.boxShadow = `0 0 6px ${glow}, 0 0 16px ${glow}B3, 0 0 24px ${glow}80`;
                    core.style.filter = 'brightness(1.15)';
                    // Start vibration briefly for preview
                    const period = this.computeVibrationPeriod(frequency, parseInt(stringElement.dataset.noteIndex||'0',10));
                    core.style.setProperty('--vib-period', period + 'ms');
                    core.classList.add('vibrating');
                    setTimeout(()=> core.classList.remove('vibrating'), 220);
                }

                // Play the note using the same system as main strings
                this.playStringNote(frequency, interval);

                // Reset visual state after a delay
                setTimeout(() => {
                    if (core) {
                        core.style.transform = 'scaleY(1)';
                        core.style.boxShadow = `0 0 4px ${glow}, 0 0 10px ${glow}AA, 0 0 18px ${glow}66`;
                        core.style.filter = 'brightness(1)';
                    }
                }, 200);
            }
            
            async playStringNote(frequency, interval) {
                const ready = await this.ensureAudioContext();
                if (!ready) return;
                
                // Use the current oscillator and envelope settings
                let source;
                const gainNode = this.audioContext.createGain();
                
                // Apply current oscillator settings
                const t = this.oscillators.osc1.type;
                if (t === 'noise') {
                    source = this.createNoiseSource();
                } else {
                    source = this.audioContext.createOscillator();
                    if (['pulse','fullrect','halfrect','trapezoid','parabolic','stair'].includes(t)) {
                        source.setPeriodicWave(this.getCustomPeriodicWave(t, this.oscillators.osc1.pulseWidth));
                    } else {
                        source.type = t;
                    }
                    source.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                }
                
                // Apply current ADSR envelope
                const now = this.audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                // Let master gainNode handle global volume; keep per-note envelope in a musical range
                gainNode.gain.linearRampToValueAtTime(1.0, now + this.envelope.attack);
                gainNode.gain.exponentialRampToValueAtTime(Math.max(0, Math.min(1, this.envelope.sustain)), now + this.envelope.attack + this.envelope.decay);
                // Release to zero after decay completes
                gainNode.gain.linearRampToValueAtTime(0, now + this.envelope.attack + this.envelope.decay + this.envelope.release);
                
                // Connect through reverb if enabled
                source.connect(gainNode);
                // Always route into master gainNode so global wet/dry split handles reverb
                gainNode.connect(this.gainNode);
                
                source.start();
                source.stop(now + this.envelope.attack + this.envelope.decay + this.envelope.release);
                
                // Store for cleanup
                this.tempChordAudio.set(`preview-${Date.now()}`, { oscillator: source, gainNode });
            }
            
            removePreviewChordColumn() {
                const previewColumn = document.getElementById('previewChordColumn');
                if (previewColumn) {
                    previewColumn.remove();
                }
            }
            
            finalizePreviewChord(chordName) {
                // Remove the preview column
                this.removePreviewChordColumn();
                
                // Compute lowest interval as chord root anchor and normalize intervals
                const edo = this.currentTuning || 12;
                const ivs = [...this.selectedIntervals];
                // Do not save truly blank or single-note chords
                const nonRootCount = ivs.filter(v=> v !== 0).length;
                if (!ivs.length || nonRootCount === 0) {
                    console.warn('Skipping save: blank chord has no tones beyond root.');
                    return;
                }
                const minIv = Math.min(...ivs);
                const normalized = ivs.map(iv => ((iv - minIv) % edo + edo) % edo).sort((a,b)=>{
                    const sa = this.stepToSemitone(a, edo); const sb = this.stepToSemitone(b, edo); return sa - sb;
                });
                // Compute absolute step for the chord root from lowest note (rootless)
                const baseRootAbs = ((minIv % edo) + edo) % edo;
                // Build a musically sensible label (root + quality + optional slash-bass)
                const absForLabel = ivs.map(iv => ((iv % edo) + edo) % edo);
                const computedLabel = this.computeFullChordNameFromAbsoluteSteps(absForLabel, edo);
                // If user typed a name, keep it; otherwise use computedLabel
                let finalName = (chordName && chordName.trim()) ? chordName.trim() : (computedLabel || 'New Chord');
                
                // Decide target position
                const replacing = !!this.isEditingChord && typeof this.editingOriginalIndex === 'number' && this.editingOriginalIndex >= 0;
                const position = replacing ? this.editingOriginalIndex : this.chordExtensions.length;

                // Decide a persistent header accent color for this chord (per-chord color)
                // Use the current root neon color as the chord's header accent, with a safe fallback
                let headerAccentColor = '#14b8a6';
                try {
                    const c = this.getIntervalColor(0)?.color;
                    headerAccentColor = (!c || c.toLowerCase() === '#000000') ? '#333333' : c;
                } catch {}
                
                // Preserve existing chord metadata if editing in place
                let preserved = {};
                if (replacing && this.chordExtensions[position]) {
                    const oldChord = this.chordExtensions[position];
                    preserved = {
                        id: oldChord.id,
                        createdAt: oldChord.createdAt,
                        headerColor: oldChord.headerColor,
                        originalTuning: oldChord.originalTuning,
                        originalGamelanMode: oldChord.originalGamelanMode,
                        lastTuning: oldChord.lastTuning
                    };
                }

                // Create new chord extension with exact intervals and position tracking
                const newChord = {
                    name: finalName,
                    extensions: [],
                    intervals: normalized,
                    isCustom: true,
                    id: preserved.id || ('custom_' + Date.now()),
                    createdAt: preserved.createdAt || Date.now(),
                    position: position, // Track exact position in array
                    // Keep the original root for reference but don't auto-lock
                    originalRoot: this.currentRoot,
                    // Track tuning metadata to support future remaps between EDOs
                    originalTuning: preserved.originalTuning || this.currentTuning,
                    originalGamelanMode: preserved.originalGamelanMode ?? this.gamelanMode,
                    lastTuning: this.currentTuning,
                    // Persist a header color so saved chords can keep distinct colors
                    headerColor: preserved.headerColor || headerAccentColor,
                    // Per-chord fixed root lock (abs step in its tuning)
                    fixedRootStepAbs: baseRootAbs,
                    fixedRootTuning: edo
                };
                
                console.log('🔧 finalizePreviewChord - saving chord:', {
                    name: chordName,
                    intervals: [...this.selectedIntervals],
                    isCustom: true,
                    currentTuning: this.currentTuning,
                    selectedIntervals: this.selectedIntervals
                });
                
                // Add to chord extensions: replace original index when editing, else append
                if (replacing) {
                    // Replace in place to preserve column position and identity
                    this.chordExtensions.splice(position, 1, newChord);
                } else {
                    this.chordExtensions.push(newChord);
                }

                // Normalize positions to keep exact ordering stable
                this.normalizeChordPositions();
                
                // Save and regenerate without creating variants
                this.saveChordConfiguration();
                this.regenerateColumnsWithoutVariants();
                
                // Clear selection and exit chord creation mode
                this.selectedIntervals = [];
                this.isChordCreationMode = false;
                this.isEditingChord = false;
                this.editingOriginalIndex = null;
                // Clear pending flag since notes were saved
                this.pendingBlankChordId = null;
                
                // Restore normal root button functionality
                this.restoreNormalRootButtons();
                
                console.log(`? Created chord: ${finalName} at position ${position} with intervals:`, normalized);
            }

            // Keep chord.position fields in sync with array order
            normalizeChordPositions() {
                if (!Array.isArray(this.chordExtensions)) return;
                for (let i = 0; i < this.chordExtensions.length; i++) {
                    const c = this.chordExtensions[i];
                    if (c && c.position !== i) c.position = i;
                }
            }
            
            regenerateColumnsWithoutVariants() {
                // Regenerate only the exact chords without creating maj/min/neu variants
                this.generateExactChordColumns();
                this.updateChordDisplay();
            }
            
            generateExactChordColumns() {
                console.log('Generating exact chord columns (no variants)');
                const container = document.getElementById('extensionColumns');
                
                // Clear container completely to remove any leftover columns
                container.innerHTML = '';
                container.style.display = 'flex';
                container.style.gap = '0px';
                container.style.width = '100%';
                container.style.height = '100%';
                // Reset to one row by default; we may split into two rows below
                container.style.flexDirection = 'row';
                
                // Initialize hiddenColumns if not exists
                if (!this.hiddenColumns) {
                    this.hiddenColumns = [];
                }
                
                // Sort chordExtensions by position to maintain exact order
                const sortedExtensions = [...this.chordExtensions].sort((a, b) => {
                    const posA = a.position !== undefined ? a.position : this.chordExtensions.indexOf(a);
                    const posB = b.position !== undefined ? b.position : this.chordExtensions.indexOf(b);
                    return posA - posB;
                });
                
                // Map chord extensions to per-instance identifiers for hiding
                const chordIds = sortedExtensions.map((chord, index) => {
                    return (chord.id || (chord.name + '_' + index)).toLowerCase().replace(/\s+/g, '_');
                });
                
                // Filter visible chord extensions (maintain original order)
                const visibleExtensions = sortedExtensions.filter((chordExt, index) => {
                    const chordId = chordIds[index];
                    const isVisible = !this.hiddenColumns.includes(chordId);
                    return isVisible;
                });
                
                console.log('Creating exact chord columns:', visibleExtensions.length);
                
                // Layout: if >16, split into 2 rows. We'll create a wrapper for rows and append columns to row containers.
                const useTwoRows = visibleExtensions.length > 16;
                let rowTop, rowBottom;
                if (useTwoRows) {
                    container.style.flexDirection = 'column';
                    rowTop = document.createElement('div');
                    rowBottom = document.createElement('div');
                    Object.assign(rowTop.style, { display:'flex', gap:'0px', width:'100%', height:'50%' });
                    Object.assign(rowBottom.style, { display:'flex', gap:'0px', width:'100%', height:'50%' });
                    container.appendChild(rowTop);
                    container.appendChild(rowBottom);
                }

                // Create ONE column per chord extension (no variants) - maintain exact order
                visibleExtensions.forEach((chordExt, extensionIndex) => {
                    // Special case: separator → 30px spacer without strings
                    if (chordExt.isSeparator || chordExt.name === '|') {
                        const sepCol = document.createElement('div');
                        sepCol.className = 'extension-separator';
                        sepCol.style.width = '30px';
                        sepCol.style.minWidth = '30px';
                        sepCol.style.maxWidth = '30px';
                        sepCol.style.height = '100%';
                        sepCol.style.flex = '0 0 30px';
                        sepCol.style.background = 'transparent';
                        sepCol.style.borderLeft = '2px solid rgba(255,255,255,0.15)';
                        sepCol.style.boxShadow = 'inset 0 0 12px rgba(255,255,255,0.08)';
                        if (useTwoRows) {
                            const half = Math.ceil(visibleExtensions.length / 2);
                            const targetRow = extensionIndex < half ? rowTop : rowBottom;
                            targetRow.appendChild(sepCol);
                        } else {
                            container.appendChild(sepCol);
                        }
                        return; // next item
                    }
                    const column = document.createElement('div');
                    column.className = 'extension-column';
                    column.dataset.chordType = chordIds[extensionIndex];
                    // Persist absolute index back to the original array for precise operations
                    const absoluteIndex = (typeof chordExt.position === 'number') ? chordExt.position : (this.findChordIndex ? this.findChordIndex(chordExt) : extensionIndex);
                    column.dataset.originalPosition = absoluteIndex;
                    column.dataset.chordId = chordExt.id || chordIds[extensionIndex];
                    // Assign a unique DOM instance id for this box if missing
                    if (!column.dataset.instanceId) {
                        column.dataset.instanceId = `${column.dataset.chordId}__${Date.now()}_${Math.floor(Math.random()*1e6)}`;
                    }
                    column.style.flex = '1'; // Each column takes equal width
                    column.style.height = '100%';
                    column.style.border = 'none';
                    column.style.borderRadius = '0';
                    column.style.margin = '0';
                    column.style.padding = '0';
                    
                    // Create header with chord name and lock button
                    const header = document.createElement('div');
                    header.className = 'extension-header';
                    
                    // Create chord name span
                    const chordName = document.createElement('span');
                    chordName.className = 'chord-name';
                    
                    // Check if this chord extension is locked and preserve its locked name
                    if (chordExt.isLocked && chordExt.lockedData) {
                        const lockedData = chordExt.lockedData;
                        const rootName = this.getNoteNames()[lockedData.lockedRoot] || lockedData.lockedRoot;
                        
                        // Use the locked name exactly as it was when locked
                        if (lockedData.chordName.match(/^[A-G][#b]?/)) {
                            chordName.textContent = lockedData.chordName;
                        } else {
                            chordName.textContent = `${rootName}${lockedData.chordName}`;
                        }
                        
                        chordName.style.color = '#4CAF50';
                        chordName.style.fontWeight = 'bold';
                        chordName.dataset.isLocked = 'true';
                        chordName.dataset.lockedName = chordName.textContent;
                        chordName.title = `?? LOCKED: ${rootName} root, ${lockedData.lockedTuning}TET, ${lockedData.lockedOsc1.type}/${lockedData.lockedOsc2.type} waves`;
                    } else {
                        // Regular unlocked chord - use current name
                        chordName.textContent = chordExt.name;
                    }
                    
                    // Padlock (full sonic snapshot) button removed per request
                    
                    // piano-lock UI removed: oscillator/envelope recall is handled via instrument presets
                    
                    // Create buttons container
                    const buttonsContainer = document.createElement('div');
                    buttonsContainer.className = 'header-buttons';
                    // Delete button removed — delete via upward drag
                    // Edit button removed — live edit via keyboard

                    // Duplicate button removed per request
                    
                    // Add buttons to container
                    // Per-column transpose controls
                    const downBtn = document.createElement('button');
                    downBtn.className = 'chord-action-button transpose-down';
                    downBtn.title = 'Transpose this chord down one step';
                    downBtn.textContent = '▼';
                    const upBtn = document.createElement('button');
                    upBtn.className = 'chord-action-button transpose-up';
                    upBtn.title = 'Transpose this chord up one step';
                    upBtn.textContent = '▲';
                    // Prevent double-fire on touch (touchstart + synthetic click)
                    let _pressGuard = false;
                    const norm = (v, m)=> ((v % m) + m) % m;
                    const applyLocalTranspose = (delta)=>{
                        if (_pressGuard) return; // avoid accidental double-fire on first tap
                        _pressGuard = true;
                        const edoNow = (chordExt.lockedData?.lockedTuning) || chordExt.fixedRootTuning || this.currentTuning || 12;
                        // Normalize both model and DOM dataset to 0..edo-1
                        chordExt.localTranspose = norm((chordExt.localTranspose||0) + delta, edoNow);
                        // Persist per-column for locked rendering paths
                        const prev = (+column.dataset.localTranspose || 0);
                        column.dataset.localTranspose = String(norm(prev + delta, edoNow));

                        // Update header label root token; for locked chords base on locked root; else recompute
                        const lockedData = chordExt.lockedData || this.lockedChords?.get(column);
                        if (lockedData && typeof lockedData.lockedRoot === 'number') {
                            const edo = lockedData.lockedTuning || edoNow;
                            const base = lockedData.lockedRoot;
                            const step = ((base + (chordExt.localTranspose||0)) % edo + edo) % edo;
                            const newRoot = this.getRootNameForStep(step, edo);
                            const rest = (lockedData.chordName || '').replace(/^[A-G][#b]?\s*/, '');
                            chordName.textContent = `${newRoot}${rest}`;
                            chordName.dataset.lockedName = chordName.textContent;
                            // Clear any exact snapshot so local transpose takes effect in audio
                            if (lockedData.exactFrequencies && lockedData.exactFrequencies.length) {
                                lockedData.exactFrequencies = [];
                            }
                            // Also clear central map snapshot if present
                            try {
                                const mapLocked = this.lockedChords?.get(column);
                                if (mapLocked && Array.isArray(mapLocked.exactFrequencies) && mapLocked.exactFrequencies.length) {
                                    mapLocked.exactFrequencies = [];
                                }
                            } catch (_) {}
                            // Regenerate strings using locked settings + local transpose
                            const oldContainer = column.querySelector('.strings-column');
                            if (oldContainer) oldContainer.remove();
                            this.generateStringsForColumnWithLockedSettings(column, chordExt.intervals || [0], lockedData);
                            // Refresh header accent color to effective root
                            try {
                                const semi = this.stepToSemitone(step, edo);
                                const accent = this.getChromaticColorForSemitone(semi);
                                const text = this.pickTextColor(accent);
                                header.style.background = accent;
                                header.style.borderBottom = `2px solid ${accent}`;
                                header.style.boxShadow = `0 0 10px ${accent}55`;
                                header.style.color = text;
                            } catch(_) {}
                        } else {
                            // Unlocked
                            if (typeof chordExt.fixedRootStepAbs === 'number' && chordExt.fixedRootTuning) {
                                // Recompute full name from absolute steps using fixed root + local delta
                                const modelEdo = chordExt.fixedRootTuning;
                                const localDelta2 = ((+column.dataset.localTranspose || 0) % modelEdo + modelEdo) % modelEdo;
                                const rootAbs2 = ((chordExt.fixedRootStepAbs % modelEdo) + localDelta2 + modelEdo) % modelEdo;
                                const absModel = [rootAbs2, ...((chordExt.intervals||[]).map(iv=> (rootAbs2 + (iv % modelEdo) + modelEdo) % modelEdo))];
                                // Map to current tuning before naming
                                const edo = this.getTuningStepsPerOctave();
                                const centsPerModel = 1200 / modelEdo;
                                const centsPerCur = 1200 / edo;
                                const absCur = absModel.map(s=>{
                                    const cents = (s % modelEdo) * centsPerModel;
                                    return ((Math.round(cents / centsPerCur) % edo) + edo) % edo;
                                });
                                const newName = this.computeFullChordNameFromAbsoluteSteps(absCur, edo);
                                chordName.textContent = newName;
                                chordName.dataset.lockedName = newName;
                            } else {
                                // Shift from CURRENT displayed root by delta only
                                const label = (chordName.dataset.lockedName || chordName.textContent || '').trim();
                                const m = label.match(/^([A-G])([#b]?)([\^v]*)(.*)$/);
                                if (m) {
                                    const rest = m[4]||'';
                                    const rootSemi = this.rootToSemitone(m[1], m[2]||'');
                                    const edo = this.getTuningStepsPerOctave();
                                    const step0 = Math.round((rootSemi * edo)/12);
                                    const ups = (m[3].match(/\^/g) || []).length;
                                    const downs = (m[3].match(/v/g) || []).length;
                                    const currentStep = ((step0 + ups - downs) % edo + edo) % edo;
                                    const nextStep = ((currentStep + delta) % edo + edo) % edo;
                                    const newRoot = this.getRootNameForStep(nextStep, edo);
                                    chordName.textContent = `${newRoot}${rest}`;
                                    chordName.dataset.lockedName = chordName.textContent;
                                }
                            }
                            // Regenerate strings for this column only
                            const oldContainer2 = column.querySelector('.strings-column');
                            if (oldContainer2) oldContainer2.remove();
                            this.generateStringsForColumn(column, chordExt.intervals || [0], chordExt.isCustom||false);
                            // Refresh header accent color based on new displayed root
                            try {
                                const labelNow = (chordName.dataset.lockedName || chordName.textContent || '').trim();
                                const m2 = labelNow.match(/^([A-G])([#b]?)([\^v]*)/);
                                let rootStep;
                                if (m2) {
                                    const semi2 = this.rootToSemitone(m2[1], m2[2]||'');
                                    const edo2 = this.getTuningStepsPerOctave();
                                    let step2 = Math.round((semi2 * edo2) / 12);
                                    const ups2 = (m2[3].match(/\^/g) || []).length;
                                    const downs2 = (m2[3].match(/v/g) || []).length;
                                    rootStep = ((step2 + ups2 - downs2) % edo2 + edo2) % edo2;
                                } else {
                                    rootStep = this.currentRoot ?? 0;
                                }
                                const accent = this.getChromaticColorForSemitone(this.stepToSemitone(rootStep, this.getTuningStepsPerOctave()));
                                const text = this.pickTextColor(accent);
                                header.style.background = accent;
                                header.style.borderBottom = `2px solid ${accent}`;
                                header.style.boxShadow = `0 0 10px ${accent}55`;
                                header.style.color = text;
                            } catch(_) {}
                        }
                        // release guard on next microtask to collapse duplicate events
                        Promise.resolve().then(()=>{ _pressGuard = false; });
                    };
                    const onPointer = (delta)=> (e)=>{ e.preventDefault(); e.stopPropagation(); applyLocalTranspose(delta); try{ this.highlightKeyboardForColumn(column);}catch{} };
                    upBtn.addEventListener('pointerdown', onPointer(+1));
                    downBtn.addEventListener('pointerdown', onPointer(-1));

                    buttonsContainer.appendChild(downBtn);
                    buttonsContainer.appendChild(upBtn);
                    
                    // Initialize per-column local transpose from model (default 0)
                    column.dataset.localTranspose = String(chordExt.localTranspose || 0);

                    header.appendChild(chordName);
                    header.appendChild(buttonsContainer);
                    
                    // Color coding based on chord type
                    let qualityColor;
                    if (chordExt.name === 'Major') {
                        qualityColor = { bg: '#1e40af', border: '#3b82f6' };
                    } else if (chordExt.name === 'Neutral') {
                        qualityColor = { bg: '#059669', border: '#10b981' };
                    } else if (chordExt.name === 'Minor') {
                        qualityColor = { bg: '#dc2626', border: '#ef4444' };
                    } else if (chordExt.isCustom) {
                        // Custom chords get purple coloring
                        qualityColor = { bg: '#7c3aed', border: '#8b5cf6' };
                    } else {
                        // Default coloring for other chord types
                        qualityColor = { bg: '#374151', border: '#6b7280' };
                    }
                    
                    header.style.backgroundColor = qualityColor.bg;
                    header.style.borderColor = qualityColor.border;
                    header.style.color = 'white';
                    header.style.border = `1px solid ${qualityColor.border}`;

                    // Then apply header accent from this column's chord root (or locked root if locked)
                    try {
                        const isLocked = !!chordExt.isLocked && !!chordExt.lockedData;
                        let rootStep;
                        if (isLocked) {
                            const edo = chordExt.lockedData.lockedTuning || this.currentTuning || 12;
                            const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                            rootStep = ((chordExt.lockedData.lockedRoot ?? 0) + localDelta + edo) % edo;
            } else {
                            const label = (chordName.dataset.lockedName || chordName.textContent || '').trim();
                            const m = label.match(/^([A-G])([#b]?)([\^v]*)/);
                            if (m) {
                                const semi = this.rootToSemitone(m[1], m[2]||'');
                                let step = Math.round((semi * (this.currentTuning||12)) / 12);
                                const ups = (m[3].match(/\^/g) || []).length;
                                const downs = (m[3].match(/v/g) || []).length;
                rootStep = ((step + ups - downs) % (this.currentTuning||12) + (this.currentTuning||12)) % (this.currentTuning||12);
                            } else {
                                rootStep = this.currentRoot ?? 0;
                            }
                        }
                        const semi = this.stepToSemitone(rootStep, this.currentTuning || 12);
                        const accent = this.getChromaticColorForSemitone(semi);
                        const text = this.pickTextColor(accent);
                        header.style.background = accent;
                        header.style.borderBottom = `2px solid ${accent}`;
                        header.style.boxShadow = `0 0 10px ${accent}55`;
                        header.style.color = text;
                    } catch {}
                    
                    // Add context menu handlers - REMOVED for clean interface
                    header.addEventListener('click', (e) => {
                        // Don't interfere with header action buttons
                        if (
                            e.target.classList.contains('lock-button') ||
                            e.target.classList.contains('chord-action-button') ||
                            
                            (e.target.tagName === 'BUTTON')
                        ) {
                            return; // Let the buttons handle their own clicks
                        }
                        
                        console.log('?? Chord header clicked:', chordExt.name);
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Context menus removed - no action taken
                    });
                    
                    // Apply the same per-column root accent logic again (post-append)
                    try {
                        const isLocked = !!chordExt.isLocked && !!chordExt.lockedData;
                        let rootStep;
                        if (isLocked) {
                            const edo = chordExt.lockedData.lockedTuning || this.currentTuning || 12;
                            const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                            rootStep = ((chordExt.lockedData.lockedRoot ?? 0) + localDelta + edo) % edo;
            } else {
                            const label = (chordName.dataset.lockedName || chordName.textContent || '').trim();
                            const m = label.match(/^([A-G])([#b]?)([\^v]*)/);
                            if (m) {
                                const semi = this.rootToSemitone(m[1], m[2]||'');
                                let step = Math.round((semi * (this.currentTuning||12)) / 12);
                                const ups = (m[3].match(/\^/g) || []).length;
                                const downs = (m[3].match(/v/g) || []).length;
                rootStep = ((step + ups - downs) % (this.currentTuning||12) + (this.currentTuning||12)) % (this.currentTuning||12);
                            } else {
                                rootStep = this.currentRoot ?? 0;
                            }
                        }
                        const semi = this.stepToSemitone(rootStep, this.currentTuning || 12);
                        const accent = this.getChromaticColorForSemitone(semi);
                        const text = this.pickTextColor(accent);
                        header.style.background = accent;
                        header.style.borderBottom = `2px solid ${accent}`;
                        header.style.boxShadow = `0 0 10px ${accent}55`;
                        header.style.color = text;
                    } catch {}

                    column.appendChild(header);
                    
                    // Generate chord intervals and strings
                    const intervals = chordExt.intervals || this.getBaseTriadForQuality(chordExt.name.toLowerCase());
                    
                    // If this chord is locked, generate strings using its locked settings
                    if (chordExt.isLocked && chordExt.lockedData) {
                        console.log('?? Generating strings with locked settings for:', chordExt.name);
                        // Update header to effective root (locked root + local transpose)
                        try {
                            const edo = chordExt.lockedData.lockedTuning || this.currentTuning || 12;
                            const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                            const effRoot = ((chordExt.lockedData.lockedRoot ?? 0) + localDelta + edo) % edo;
                            const effRootName = this.getRootNameForStep(effRoot, edo);
                            const header = column.querySelector('.extension-header');
                            const nameEl = header?.querySelector('.chord-name');
                            if (nameEl) {
                                const rest = (chordExt.lockedData.chordName || '').replace(/^[A-G][#b]?\s*/, '');
                                nameEl.textContent = `${effRootName}${rest}`;
                                nameEl.dataset.lockedName = nameEl.textContent;
                            }
                        } catch {}
                        this.generateStringsForColumnWithLockedSettings(column, intervals, chordExt.lockedData);
                    } else {
                        // Regular chord - use current global settings
                        this.generateStringsForColumn(column, intervals, chordExt.isCustom);
                    }
                    
                    // Ensure columns generated via the exact path are draggable
                    if (this.attachColumnDragHandlers) {
                        this.attachColumnDragHandlers(column);
                    }
                    if (useTwoRows) {
                        const half = Math.ceil(visibleExtensions.length / 2);
                        const targetRow = extensionIndex < half ? rowTop : rowBottom;
                        targetRow.appendChild(column);
                        // If strings exist already, scale their container height to half
                        const sc = column.querySelector('.strings-column');
                        if (sc) sc.style.height = 'calc(100% - 42px)';
                    } else {
                        container.appendChild(column);
                    }
                });
                
                // Add click handlers and restore locked chord states after rendering
                setTimeout(() => {
                    this.addSimpleClickHandlers();
                    this.restoreLockedChordStates(); // Restore locked chord states
                }, 100);
            }
            
            generateStringsForColumnWithLockedSettings(column, intervals, lockedData) {
                // Check if we have exact frequencies captured - use those for perfect reproduction
                if (lockedData.exactFrequencies && lockedData.exactFrequencies.length > 0 && !this._transposing) {
                    this.generateStringsWithExactFrequencies(column, lockedData);
                    return; // Skip the rest of this method
                }
                
                // Store current settings to restore later
                const originalSettings = {
                    currentRoot: this.currentRoot,
                    currentTuning: this.currentTuning,
                    gamelanMode: this.gamelanMode,
                    volume: this.volume,
                    masterVolume: this.masterVolume
                };
                
                // Temporarily apply locked settings for string generation (with per-column local transpose in conjunction)
                const edo = lockedData.lockedTuning || this.currentTuning || 12;
                const globalDelta = (this.transposeDelta || 0) % edo;
                const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                this.currentRoot = ((lockedData.lockedRoot ?? 0) + (this._transposing ? globalDelta : 0) + localDelta + edo) % edo;
                this.currentTuning = lockedData.lockedTuning;
                this.gamelanMode = lockedData.lockedGamelanMode;
                this.volume = lockedData.lockedVolume.main;
                this.masterVolume = lockedData.lockedVolume.master;
                
                // Generate strings with locked settings
                this.generateStringsForColumn(column, intervals, lockedData.isCustom);
                
                // Store the display/effective root in the column's data attribute for reference during playback
                column.dataset.lockedRoot = String(this.currentRoot);
                
                // Add a visual indicator that this column is locked to a specific root
                const header = column.querySelector('.extension-header');
                if (header) {
                    const rootName = this.getRootNameForStep(this.currentRoot, lockedData.lockedTuning || this.currentTuning || 12);
                    const chordName = header.querySelector('.chord-name');
                    if (chordName) {
                        // Update the header to show it's locked to a specific root
                        chordName.textContent = `${rootName}${(lockedData.chordName||'').replace(/^[A-G][#b]?\s*/, '')}`;
                        chordName.dataset.lockedName = chordName.textContent;
                        chordName.style.color = '#ffcc00'; // Make it gold to indicate locked root
                        chordName.title = `LOCKED: ${rootName} root, ${lockedData.lockedTuning}TET tuning`;
                    }
                }
                
                // Restore original global settings
                this.currentRoot = originalSettings.currentRoot;
                this.currentTuning = originalSettings.currentTuning;
                this.gamelanMode = originalSettings.gamelanMode;
                this.volume = originalSettings.volume;
                this.masterVolume = originalSettings.masterVolume;
                
                console.log('?? Generated strings with locked settings and restored global settings');
                
                // Find the lock button and ensure it shows the correct state
                const lockButton = column.querySelector('.lock-button');
                if (lockButton) {
                    lockButton.innerHTML = '🔒';
                    lockButton.classList.add('locked');
                    lockButton.title = `Locked to ${this.getNoteNames()[this.currentRoot] || this.currentRoot} root with all settings`;
                }
            }
            
            generateChordName(intervals) {
                if (!intervals || intervals.length === 0) return '';
                if (intervals.length === 1) return '';
                
                // Use the new proper chord symbol system
                return this.getProperChordSymbol(intervals);
            }

            
            
            // Helper function to check if intervals match (accounting for octave wrapping)
            intervalsMatch(intervals1, intervals2) {
                if (intervals1.length !== intervals2.length) return false;
                
                // Normalize intervals to within one octave
                const normalize = (intervals) => intervals.map(i => i % 12).sort((a, b) => a - b);
                const norm1 = normalize(intervals1);
                const norm2 = normalize(intervals2);
                
                return norm1.every((interval, index) => interval === norm2[index]);
            }
            
            async playStringPreview(interval) {
                const ready = await this.ensureAudioContext();
                if (!ready) return;
                
                // Interpret interval as an absolute step plus global transpose (rootless)
                const absStep = (((interval % this.currentTuning) + (this.transposeDelta||0)) % this.currentTuning + this.currentTuning) % this.currentTuning;
                const frequency = this.getFrequency(absStep, 4, this.currentTuning);
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.2, this.audioContext.currentTime + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.8);
                
                oscillator.connect(gainNode);
                // Route through master chain (global wet/dry + reverb)
                gainNode.connect(this.gainNode);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.8);
            }
            
            restoreNormalRootButtons() {
                // Restore original root button functionality
                this.generateRootButtons();
            }

            // Apply a global transpose by n EDO steps; rootless: rename headers from absolute steps when possible and retune
            applyTransposeStep(n = 0) {
                if (!n) return;
                const edo = this.currentTuning || 12;
                this.transposeDelta = (((this.transposeDelta || 0) + n) % edo + edo) % edo;
                // Refresh keyboard labels and chord-tone highlights
                try { this.generateRootButtons(); } catch (_) {}
                // Rename headers (prefer recompute from absolute steps if model has fixed root)
                document.querySelectorAll('.extension-column').forEach(col => {
                    const nameEl = col.querySelector('.extension-header .chord-name');
                    if (!nameEl) return;
                    const locked = !!col.querySelector('.lock-button')?.classList.contains('locked');
                    const labelRaw = (nameEl.dataset.lockedName || nameEl.textContent || '').trim().replace(/^🔒\s*/, '');
                    let model = null;
                    try {
                        let idx = col.dataset.originalPosition != null ? parseInt(col.dataset.originalPosition,10) : -1;
                        if (isNaN(idx) || idx < 0) {
                            const id = col.dataset.chordId;
                            idx = (this.chordExtensions || []).findIndex(c => (c.id===id));
                        }
                        model = (idx>=0)? this.chordExtensions[idx] : null;
                    } catch (_) { model = null; }
                    if (model && typeof model.fixedRootStepAbs === 'number' && Array.isArray(model.intervals) && model.intervals.length>1) {
                        // Map model's absolute steps (in its tuning) into the CURRENT tuning space before naming
                        const modelEdo = model.fixedRootTuning || edo;
                        const mapToCurrent = (s)=>{
                            // step -> cents in model edo -> nearest step in current edo
                            const cents = (s % modelEdo) * (1200 / modelEdo);
                            const step = Math.round(cents / (1200 / edo)) % edo;
                            return (step + edo) % edo;
                        };
                        const absModel = [model.fixedRootStepAbs, ...model.intervals.map(iv=> (model.fixedRootStepAbs + iv)%modelEdo)];
                        const abs = absModel.map(mapToCurrent);
                        const recomputed = this.computeFullChordNameFromAbsoluteSteps(abs, edo);
                        nameEl.textContent = locked ? `🔒 ${recomputed}` : recomputed;
                        nameEl.dataset.lockedName = nameEl.textContent;
                    } else {
                        // Fallback: rotate by EDO steps using parsed root, then relabel
                        const m = labelRaw.match(/^([A-G])([#b]?)(.*)$/);
                        if (m) {
                            const semi = this.rootToSemitone(m[1], m[2]||'');
                            let step = this.semitoneToStep(semi, edo);
                            step = (((step + n) % edo) + edo) % edo;
                            const newRoot = this.getRootNameForStep(step, edo);
                            nameEl.textContent = locked ? `🔒 ${newRoot}${m[3]||''}` : `${newRoot}${m[3]||''}`;
                            nameEl.dataset.lockedName = nameEl.textContent;
                        }
                    }
                });
                // Retune all strings/columns to reflect transpose
                this._transposing = true;
                try { this.regenerateAllColumnsPreservingLocks(); } finally { this._transposing = false; }
                // After transpose, warm all visible pianolocked columns for instant response
                try {
                    // Warm columns marked as piano-locked (use class marker or backend flags)
                    document.querySelectorAll('.extension-column.piano-locked-col').forEach(col => {
                        try { this.preloadPianoLockedChord(col); } catch(_) {}
                    });
                    // Fallback: scan columns and check their chord data for pianoLockedData
                    document.querySelectorAll('.extension-column').forEach(col => {
                        try {
                            const hdr = col.querySelector('.extension-header');
                            const cd = (typeof this.getChordDataFromColumn === 'function') ? this.getChordDataFromColumn(col, hdr) : null;
                            if (cd && cd.isPianoLocked) { try { this.preloadPianoLockedChord(col); } catch(_) {} }
                        } catch(_){}
                    });
                } catch(_) {}
                // Update delta indicator
                const deltaEl = document.getElementById('transposeDelta');
                if (deltaEl) deltaEl.textContent = String(this.transposeDelta);
                // Update any locked column header tooltips
                try {
                    document.querySelectorAll('.extension-column').forEach(col=>{
                        const btn = col.querySelector('.lock-button');
                        if (btn?.classList.contains('locked')){
                            const edoNow = this.currentTuning || 12;
                            const lockedChord = this.lockedChords?.get(col);
                            if (lockedChord) {
                                const localDelta = ((+col.dataset.localTranspose || 0) % edoNow + edoNow) % edoNow;
                                const effStep = (((lockedChord.lockedRoot ?? 0) + localDelta + (this.transposeDelta || 0)) % edoNow + edoNow) % edoNow;
                                const newRoot = this.getRootNameForStep(effStep, edoNow);
                                btn.title = `Locked to ${newRoot} root with all settings`;
                            }
                        }
                    });
                } catch (_) {}
                // Refresh keyboard highlights after global transpose
                try { if (this.currentActiveColumnEl) this.highlightKeyboardForColumn(this.currentActiveColumnEl); } catch {}
            }

            // ================== TEXT → CHORDS PARSER ==================
            initTextChordParser() {
                const openBtn = document.getElementById('openTextChordParserBtn');
                const modal = document.getElementById('textChordModal');
                const closeBtn = document.getElementById('closeTextChordModalBtn');
                const parseBtn = document.getElementById('parseTextChordsBtn');
                const textarea = document.getElementById('textChordInput');
                // Sequence preset controls
                const seqSelect = document.getElementById('seqPresetDropdown');
                const seqLoadBtn = document.getElementById('selectSeqPresetBtn');
                const seqSaveBtn = document.getElementById('addSeqPresetBtn');
                const seqDelBtn  = document.getElementById('deleteSeqPresetBtn');
                // Open the modal when SEQUENCE button is clicked
                if (openBtn && modal) {
                    openBtn.addEventListener('click', () => {
                        modal.style.display = 'block';
                        // Populate presets each open to pick up new saves/deletes
                        try { if (seqSelect) this.populateSeqPresetDropdown(seqSelect, this.getSequencePresets()); } catch(_) {}
                        // Run an initial parse to populate palette/count
                        try { this.runTextChordParsing(); } catch(_) {}
                    });
                }
                // Update any locked column header tooltips
                if (closeBtn) closeBtn.addEventListener('click', ()=> { if(modal) modal.style.display='none'; });
                // Create Sequence now builds from textarea
                if (parseBtn) parseBtn.addEventListener('click', ()=> this.createSequenceFromTextarea());
                // Live preview of unique chords palette
                if (textarea) textarea.addEventListener('input', ()=> this.runTextChordParsing());
                // Dismiss on backdrop click
                if (modal) modal.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none'; });

                // Wire sequence presets UI
                // Initial populate on load
                try { if (seqSelect) this.populateSeqPresetDropdown(seqSelect, this.getSequencePresets()); } catch(_) {}
                // Auto-load on selection change and close modal
                if (seqSelect && textarea && modal) {
                    seqSelect.addEventListener('change', () => {
                        const v = seqSelect.value || '';
                        if (!v) return;
                        const textOnly = v.replace(/\s*\([^)]*\)\s*$/, '');
                        textarea.value = textOnly;
                        textarea.dispatchEvent(new Event('input'));
                        // If it's a Roman sequence, immediately create columns
                        try {
                            const material = this.convertRomanNumeralsInline(textOnly);
                            const list = this.extractChordsFromTextPreserveOrder(material);
                            if (list && list.length) {
                                this.transposeDelta = 0;
                                const deltaEl = document.getElementById('transposeDelta');
                                if (deltaEl) deltaEl.textContent = '0';
                                this.autoCreateColumnsFromText(list);
                            }
                        } catch(_) {}
                        modal.style.display = 'none';
                    });
                }
                // Save: prompt for name and save current textarea as a new preset, then refresh dropdown
                if (seqSaveBtn) seqSaveBtn.addEventListener('click', () => {
                    if (!textarea) return;
                    const text = (textarea.value || '').trim();
                    if (!text) return;
                    const name = prompt('Preset name?', 'My Sequence');
                    if (!name) return;
                    this.saveSequencePreset(`${text} (${name})`);
                    try { if (seqSelect) this.populateSeqPresetDropdown(seqSelect, this.getSequencePresets()); } catch(_) {}
                    if (seqSelect) seqSelect.value = `${text} (${name})`;
                });
                // Delete: remove selected preset
                if (seqDelBtn) seqDelBtn.addEventListener('click', () => {
                    if (!seqSelect) return;
                    const v = seqSelect.value || '';
                    if (!v) return;
                    const key = 'omni_seq_presets_v3';
                    try {
                        const list = this.getSequencePresets();
                        const next = list.filter(x => x !== v);
                        localStorage.setItem(key, JSON.stringify(next));
                        this.populateSeqPresetDropdown(seqSelect, next);
                    } catch(_) {}
                });
            }

            // ================== INSTRUMENT PRESETS (OSC/ADSR) ==================
            getInstrumentPresets() {
                const key = 'omni_instr_presets_v1';
                try {
                    const raw = localStorage.getItem(key);
                    const list = raw ? JSON.parse(raw) : [];
                    return Array.isArray(list) ? list : [];
                } catch (_) {
                    return [];
                }
            }
            saveInstrumentPresets(list) {
                const key = 'omni_instr_presets_v1';
                try { localStorage.setItem(key, JSON.stringify(list.slice(0, 200))); } catch (_) {}
            }
            populateInstrumentPresetDropdown(selectEl) {
                if (!selectEl) return;
                const list = this.getInstrumentPresets();
                selectEl.innerHTML = '';
                const def = document.createElement('option');
                def.value = '';
                def.textContent = 'Choose preset';
                selectEl.appendChild(def);
                list.forEach(p => {
                    const opt = document.createElement('option');
                    opt.value = p.id;
                    opt.textContent = p.name || p.id;
                    selectEl.appendChild(opt);
                });
            }
            captureInstrumentState() {
                return {
                    osc1: { ...this.oscillators.osc1 },
                    osc2: { ...this.oscillators.osc2 },
                    envelope: { ...this.envelope },
                    osc2Envelope: { ...this.osc2Envelope }
                };
            }
            applyInstrumentState(state) {
                if (!state) return;
                if (state.osc1) Object.assign(this.oscillators.osc1, state.osc1);
                if (state.osc2) Object.assign(this.oscillators.osc2, state.osc2);
                if (state.envelope) Object.assign(this.envelope, state.envelope);
                if (state.osc2Envelope) Object.assign(this.osc2Envelope, state.osc2Envelope);
                // Sync UI controls if panel is open
                const oscPanel = document.querySelector('.panel-content[data-panel="osc"]');
                if (oscPanel && window.getComputedStyle(oscPanel).display !== 'none') {
                    const syncOscUi = (num, data) => {
                        try {
                            document.querySelectorAll(`.osc-btn[data-osc="${num}"]`).forEach(b => b.classList.remove('active'));
                            const active = document.querySelector(`.osc-btn[data-osc="${num}"][data-wave="${data.type}"]`);
                            if (active) active.classList.add('active');
                            const pwContainer = document.querySelector(`.pulse-width-container[data-osc="${num}"]`);
                            if (pwContainer) pwContainer.style.display = (data.type === 'pulse') ? 'block' : 'none';
                            const pwSlider = document.getElementById(`osc${num}PulseWidth`);
                            const pwValue = document.getElementById(`osc${num}PulseWidthValue`);
                            if (pwSlider && typeof data.pulseWidth === 'number') {
                                const pct = Math.round((data.pulseWidth || 0.5) * 100);
                                pwSlider.value = String(pct);
                                if (pwValue) pwValue.textContent = `${pct}%`;
                            }
                            const lvl = document.getElementById(`osc${num}Level`);
                            const lvlV = document.getElementById(`osc${num}LevelValue`);
                            if (lvl) { const slider = Math.round(((data.level || 0) / 0.125) * 10); lvl.value = String(slider); if (lvlV) lvlV.textContent = `${slider * 10}%`; }
                            const det = document.getElementById(`osc${num}Detune`);
                            const detV = document.getElementById(`osc${num}DetuneValue`);
                            if (det) { det.value = String(Math.round(data.detune || 0)); if (detV) detV.textContent = `${Math.round(data.detune || 0)}¢`; }
                            const oct = document.getElementById(`osc${num}Octave`);
                            const octV = document.getElementById(`osc${num}OctaveValue`);
                            if (oct) { oct.value = String(data.octave || 0); if (octV) octV.textContent = String(data.octave || 0); }
                            const crs = document.getElementById(`osc${num}Coarse`);
                            const crsV = document.getElementById(`osc${num}CoarseValue`);
                            if (crs) { crs.value = String(data.coarse || 0); if (crsV) crsV.textContent = `${data.coarse || 0} steps`; }
                        } catch(_) {}
                    };
                    // ADSR 1
                    const a = document.getElementById('attackSlider');
                    const d = document.getElementById('decaySlider');
                    const s = document.getElementById('sustainSlider');
                    const r = document.getElementById('releaseSlider');
                    const av = document.getElementById('attackValue');
                    const dv = document.getElementById('decayValue');
                    const sv = document.getElementById('sustainValue');
                    const rv = document.getElementById('releaseValue');
                    if (a) { const ms = Math.round((this.envelope.attack||0)*1000); a.value = String(ms); if (av) av.textContent = `${ms}ms`; }
                    if (d) { const ms = Math.round((this.envelope.decay||0)*1000); d.value = String(ms); if (dv) dv.textContent = `${ms}ms`; }
                    if (s) { const pct = Math.round((this.envelope.sustain||0)*100); s.value = String(pct); if (sv) sv.textContent = `${pct}%`; }
                    if (r) { const ms = Math.round((this.envelope.release||0)*1000); r.value = String(ms); if (rv) rv.textContent = `${ms}ms`; }
                    // ADSR 2
                    const a2 = document.getElementById('osc2AttackSlider');
                    const d2 = document.getElementById('osc2DecaySlider');
                    const s2 = document.getElementById('osc2SustainSlider');
                    const r2 = document.getElementById('osc2ReleaseSlider');
                    const a2v = document.getElementById('osc2AttackValue');
                    const d2v = document.getElementById('osc2DecayValue');
                    const s2v = document.getElementById('osc2SustainValue');
                    const r2v = document.getElementById('osc2ReleaseValue');
                    if (a2) { const ms = Math.round((this.osc2Envelope.attack||0)*1000); a2.value = String(ms); if (a2v) a2v.textContent = `${ms}ms`; }
                    if (d2) { const ms = Math.round((this.osc2Envelope.decay||0)*1000); d2.value = String(ms); if (d2v) d2v.textContent = `${ms}ms`; }
                    if (s2) { const pct = Math.round((this.osc2Envelope.sustain||0)*100); s2.value = String(pct); if (s2v) s2v.textContent = `${pct}%`; }
                    if (r2) { const ms = Math.round((this.osc2Envelope.release||0)*1000); r2.value = String(ms); if (r2v) r2v.textContent = `${ms}ms`; }
                    // Waves and per-osc UI
                    syncOscUi(1, this.oscillators.osc1);
                    syncOscUi(2, this.oscillators.osc2);
                }
            }
            wireInstrumentPresetsUI() {
                const sel = document.getElementById('instrumentPresetSelect');
                const btnApply = document.getElementById('instrumentPresetApply');
                const btnSave = document.getElementById('instrumentPresetSave');
                const btnDel = document.getElementById('instrumentPresetDelete');
                if (sel) this.populateInstrumentPresetDropdown(sel);
                if (btnApply) btnApply.addEventListener('click', () => {
                    const id = sel?.value || '';
                    if (!id) return;
                    const list = this.getInstrumentPresets();
                    const found = list.find(p => p.id === id);
                    if (found) this.applyInstrumentState(found.state);
                });
                if (btnSave) btnSave.addEventListener('click', () => {
                    const name = prompt('Preset name?','My Instrument');
                    if (!name) return;
                    const list = this.getInstrumentPresets();
                    const id = `P${Date.now()}`;
                    list.unshift({ id, name, state: this.captureInstrumentState() });
                    this.saveInstrumentPresets(list);
                    if (sel) { this.populateInstrumentPresetDropdown(sel); sel.value = id; }
                });
                if (btnDel) btnDel.addEventListener('click', () => {
                    const id = sel?.value || '';
                    if (!id) return;
                    const list = this.getInstrumentPresets();
                    const next = list.filter(p => p.id !== id);
                    this.saveInstrumentPresets(next);
                    if (sel) this.populateInstrumentPresetDropdown(sel);
                });
            }

            runTextChordParsing() {
                const input = document.getElementById('textChordInput');
                const resultsGrid = document.getElementById('textChordResults');
                const countEl = document.getElementById('textChordCount');
                if (!input || !resultsGrid || !countEl) return;
                const text = input.value || '';
                // Always convert Roman numerals inline while leaving ordinary chord tokens as-is
                const material = this.convertRomanNumeralsInline(text);
                // Build a unique chord palette (deduped, first-appearance order)
                const unique = this.extractUniqueChordsFromEntireText(material);
                // Render clickable cards that append to textarea
                resultsGrid.innerHTML = '';
                unique.forEach(ch => {
                    const card = document.createElement('div');
                    card.style.cssText = 'padding:10px; border:1px solid #2b5567; border-radius:8px; background:#102a3a; color:#e8f5ff; font-family:var(--retro-font); display:flex; align-items:center; justify-content:center; min-height:46px;';
                    card.textContent = ch;
                    card.tabIndex = 0;
                    card.style.cursor = 'pointer';
                    const append = ()=>{
                        const ta = document.getElementById('textChordInput');
                        if (!ta) return;
                        const sep = /[\s\n]$/.test(ta.value || '') || !ta.value ? '' : ' ';
                        ta.value = (ta.value || '') + sep + ch;
                        ta.focus();
                        ta.setSelectionRange(ta.value.length, ta.value.length);
                        ta.dispatchEvent(new Event('input'));
                    };
                    card.addEventListener('click', append);
                    card.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); append(); } });
                    resultsGrid.appendChild(card);
                });
                countEl.textContent = String(unique.length);
                // Keep last palette for potential future use
                this._lastParsedChordsPalette = unique;
            }

            // New: create sequence from current textarea content; honors Roman detection and Repeat Unique Sections
            createSequenceFromTextarea() {
                const input = document.getElementById('textChordInput');
                const modal = document.getElementById('textChordModal');
                if (!input) return;
                const text = input.value || '';
                const material = this.convertRomanNumeralsInline(text);
                const blocks = this.extractUniqueBlocks(material);
                const repeat = !!document.getElementById('seqRepeat')?.checked;
                const list = (repeat && blocks.length > 1)
                    ? blocks.flatMap(b=>b)
                    : this.extractChordsFromTextPreserveOrder(material);
                if (!list.length) return;
                // Reset global transpose and rebuild
                this.transposeDelta = 0;
                const deltaEl = document.getElementById('transposeDelta');
                if (deltaEl) deltaEl.textContent = '0';
                this.autoCreateColumnsFromText(list);
                if (modal) modal.style.display='none';
            }

            // Unique chords across the entire text in order of first appearance
            extractUniqueChordsFromEntireText(text) {
                const out = [];
                const seen = new Set();
                if (!text) return out;
                const lines = String(text).split(/\r?\n/);
                for (const line of lines) {
                    const s = line.trim();
                    if (!s) continue;
                    const matches = this.scanChordMatches(s);
                    for (const m of matches) {
                        const norm = this.normalizeChordToken(m.raw);
                        if (!norm) continue;
                        if (!seen.has(norm)) { seen.add(norm); out.push(norm); }
                    }
                }
                return out;
            }

            // Heuristic: consider this text a Roman sequence only if most tokens are Roman numerals (with optional degree accidentals and extensions)
            isRomanSequence(text) {
                if (!text) return false;
                const tokens = [];
                String(text).split(/\r?\n/).forEach(line => {
                    line.split(/[\s\|]+|[–—-]/g).map(s=>s.trim()).filter(Boolean).forEach(t=>tokens.push(t));
                });
                if (tokens.length === 0) return false;
                // Roman token: optional leading b/#, then roman (I,II,III,IV,V,VI,VII in any case), optional extension tail
                const romanRe = /^(?:b+|#+)?(?:i{1,3}|iv|v|vi{0,3}|I{1,3}|IV|V|VI{0,3})(?:maj7|M7|Δ7|m7|7|9|11|13|maj9|M9|Δ9|add(?:9|11|13)|[#b](?:5|9|11|13))?$/;
                let romanCount = 0;
                for (const tok of tokens) {
                    if (romanRe.test(tok)) romanCount++;
                }
                if (romanCount === 0) return false;
                // Require a majority to avoid mixing modes
                return romanCount / tokens.length >= 0.6;
            }

            // Detect unique repeating blocks from multi-line input; returns array of arrays (each block => list of chords).
            extractUniqueBlocks(text) {
                if (!text) return [];
                const lines = String(text).split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
                const out = [];
                const seen = new Set();
                for (const line of lines) {
                    const tokens = this.extractUniqueChordsFromText(line);
                    if (!tokens.length) continue;
                    const key = tokens.join(' ');
                    if (!seen.has(key)) { seen.add(key); out.push(tokens); }
                }
                return out;
            }

            // New: Extract chords in order (no dedupe), across lines, preserving repeats
            extractChordsFromTextPreserveOrder(text) {
                if (!text) return [];
                const lines = String(text).split(/\r?\n/);
                const out = [];
                for (const line of lines) {
                    // Convert headings like A:, B:, C: to section separators first
                    const s = line.replace(/(^|\s)[^\s|:]+\s*:\s*/g, ' | ').trim();
                    if (!s) continue;
                    // Preserve section separators using '|'
                    const sections = s.split('|');
                    sections.forEach((seg, idx) => {
                        const matches = this.scanChordMatches(seg);
                        for (const m of matches) {
                            const norm = this.normalizeChordToken(m.raw);
                            if (norm) out.push(norm);
                        }
                        if (idx < sections.length - 1) out.push('__SECTION__');
                    });
                }
                return out;
            }

            // Presets management in localStorage
            getSequencePresets() {
                const key = 'omni_seq_presets_v3';
                let list = [];
                try { list = JSON.parse(localStorage.getItem(key)) || []; } catch(_) { list = []; }
                if (!Array.isArray(list) || !list.length) {
                    list = this.getDefaultSequencePresets();
                    try { localStorage.setItem(key, JSON.stringify(list)); } catch(_) {}
                }
                return list;
            }
            saveSequencePreset(text) {
                const key = 'omni_seq_presets_v3';
                const list = this.getSequencePresets();
                let v = String(text || '').trim();
                if (!v) return;
                // If user didn't include a bracketed name, append a simple one
                if (!/\([^)]*\)\s*$/.test(v)) v = v + ' (Saved)';
                if (!list.includes(v)) list.unshift(v);
                try { localStorage.setItem(key, JSON.stringify(list.slice(0,50))); } catch(_) {}
            }
            populateSeqPresetDropdown(selectEl, list) {
                if (!selectEl) return;
                selectEl.innerHTML = '';
                // Default chooser option
                const def = document.createElement('option');
                def.value = '';
                def.textContent = 'Choose Preset';
                def.selected = true;
                def.disabled = false; // allow re-selecting empty to clear
                selectEl.appendChild(def);
                // Add presets with label = name in parentheses when present
                list.forEach(v => {
                    const opt = document.createElement('option');
                    opt.value = v;
                    const nameMatch = v.match(/\(([^)]+)\)\s*$/);
                    const label = nameMatch ? nameMatch[1] : v;
                    opt.textContent = label.length > 80 ? label.slice(0,77)+'…' : label;
                    selectEl.appendChild(opt);
                });
            }
            getDefaultSequencePresets() {
                // A compact but comprehensive starter set
                return [
                    'I–vi–IV–V (50s progression)',
                    'IV–V–I–vi (Doo-wop variant)',
                    'I–V–vi–IV (Pop progression)',
                    'I–IV–♭VII–IV (Mixolydian rock riff)',

                    'ii–V–I (251 cadence)',
                    'ii–♭II7–I (Tritone substitution cadence)',
                    'ii–♭III+–I (Augmented dominant substitute)',

                    'iv–III–♭II–I (Andalusian cadence)',
                    'ii–♭VII7–I (Backdoor progression)',

                    'I–viiø–III7–vi–II7–v–I7–IV7–iv–♭VII7–iii–VI7–♭iii–♭VI7–ii–V7–I–VI7–ii–V (Bird changes)',

                    'I–V–♭VII–IV (Chromatic 5–6 sequence)',
                    'vi–ii–V–I (Circle progression)',

                    'I–V–♭VI–V–III–V–I (Coltrane changes)',
                    'Bmaj7 D7 Gmaj7 Bb7 Ebmaj7 Am7 D7 Gmaj7 Bb7 Ebmaj7 F#7 Bmaj7 Fm7 Bb7 Ebmaj7 Am7 D7 Gmaj7 C#m7 F#7 Bmaj7 Fm7 Bb7 Ebmaj7 C#m7 F#7 (Giant Steps)',

                    'I–V–IV–IV–I–V–I–V (Eight-bar blues)',
                    'i–V–i–♭VII–♭III–♭VII–i–V–i–V–i–♭VII–♭III–♭VII–i–V–i (Folia)',
                    'V7–III7 (Irregular resolution)',
                    'I–IV–ii–V (Montgomery–Ward bridge)',
                    'I–V–vi–iii–IV–I–IV–V (Pachelbel’s Canon)',
                    'i–VII–i–V–III–VII–i–V–i (Passamezzo antico)',
                    'I–IV–I–V–I–IV–I–V–I (Passamezzo moderno)',
                    'III7–VI7–II7–V7 (Ragtime progression)',
                    'I–iv–ii–V | I–I7–iv–I–V–I | III7–VI7–II7–V7 (Rhythm changes)',

                    'I–IV–I–V–IV–I–V (Twelve-bar blues)',
                    'I–vi–ii–V (I–vi–ii–V progression)',
                    '♭VII–V7–I (♭VII cadence)',
                    'V–IV–I (V–IV–I turnaround)',
                    'I–♭VII–♭VI–♭VII (Aeolian rock cadence)',
                    'IV△7–V7–iii7–vi (IV–V–iii–vi progression)',
                    '♭VI–♭VII–I (Modal cadence)'
                ];
            }

            // Convert Roman numeral sequence to concrete chord names in current key
            convertRomanNumeralSequenceToChords(text) {
                const edo = this.currentTuning || 12;
                const keyStep = this.currentRoot || 0; // tonic
                const tokens = [];
                const lines = String(text).split(/\r?\n/);
                const pushLine = (s)=>{
                    // Turn any SectionLabel: into a separator. We accept letters/numbers/_ before colon
                    const normalized = s.replace(/(^|\s)[^\s|:]+\s*:\s*/g, ' | ');
                    // Preserve '|' as its own token; split other separators
                    const withPipes = normalized.replace(/\|/g, ' | ');
                    const parts = withPipes.split(/[\s]+|[–—-]/g).map(x=>x.trim()).filter(Boolean);
                    for (const p of parts) tokens.push(p);
                };
                lines.forEach(pushLine);
                const mapped = tokens.map(tok=> this.mapRomanTokenToChord(tok, keyStep, edo)).filter(t=>t!=null);
                return mapped.join(' ');
            }

            // Convert any Roman numerals inline while preserving other chord tokens and '|' separators
            convertRomanNumeralsInline(text){
                if (!text) return '';
                const edo = this.currentTuning || 12;
                const keyStep = this.currentRoot || 0;
                const outLines = [];
                const lines = String(text).split(/\r?\n/);
                for (const rawLine of lines){
                    // Normalize section headers to pipes and keep them as standalone tokens
                    let s = String(rawLine || '').replace(/(^|\s)[^\s|:]+\s*:\s*/g, ' | ');
                    s = s.replace(/\|/g, ' | ');
                    const parts = s.split(/[\s]+|[–—-]/g).map(x=>x.trim()).filter(Boolean);
                    const mapped = parts.map(p=>{
                        const m = this.mapRomanTokenToChord(p, keyStep, edo);
                        return m != null ? m : p;
                    });
                    outLines.push(mapped.join(' '));
                }
                return outLines.join('\n');
            }

            // Map one roman token (like bVII, ii, Vmaj7, iii7, bVI#11) to a chord name in current key
            mapRomanTokenToChord(tok, keyStep, edo) {
                // Normalize unicode flats/sharps
                if (tok === '|') return '|';
                let t = String(tok).replace(/♭/g,'b').replace(/♯/g,'#');
                // Extract accidental prefix for degree (b/# before the roman)
                const accMatch = t.match(/^(b+|#+)?/);
                const acc = (accMatch && accMatch[0]) || '';
                let rest = t.slice(acc.length);
                // Choose the longest matching roman token first to avoid splitting 'iv' into 'i'+'v'
                const romans = ['vii','vi','iv','iii','ii','v','i','VII','VI','IV','III','II','V','I'];
                let roman = null;
                for (const cand of romans) {
                    if (rest.startsWith(cand)) { roman = cand; break; }
                }
                if (!roman) return null;
                let tail = rest.slice(roman.length).trim();
                const isMinor = roman === roman.toLowerCase();
                // Map roman to diatonic degree in 12-TET steps (Ionian)
                const romanSteps = { i:0, ii:2, iii:4, iv:5, v:7, vi:9, vii:11 };
                const baseSemi = romanSteps[roman.toLowerCase()];
                if (baseSemi == null) return null;
                let semi = baseSemi;
                // Apply accidentals to degree
                for (const ch of acc) semi += (ch === 'b' ? -1 : 1);
                // Wrap
                semi = ((semi % 12) + 12) % 12;
                // Convert to EDO step offset from tonic for HEAD roman (relative to some reference key)
                const headDegreeStep = Math.round((semi * edo) / 12);
                let referenceKeyStep = keyStep; // may be replaced by target of "/"

                // Secondary functions e.g., V/ii, vii°7/V, iiø7/V
                // If tail contains "/<roman>" (optionally accidental), compute target key first
                let preSlash = tail; let postTail = '';
                let slashMatch = tail.match(/^(.*?)(?:\/(b+|#+)?(i{1,3}|iv|v|vi{0,3}|I{1,3}|IV|V|VI{0,3})([\^v]*))?(.*)$/);
                if (slashMatch) {
                    preSlash = (slashMatch[1] || '').trim();
                    const targetAcc = slashMatch[2] || '';
                    const targetRoman = slashMatch[3] || '';
                    const targetMicro = slashMatch[4] || '';
                    postTail = (slashMatch[5] || '').trim();
                    if (targetRoman) {
                        let targetSemi = romanSteps[targetRoman.toLowerCase()];
                        if (targetSemi != null) {
                            // apply accidentals to target degree
                            for (const ch of targetAcc) targetSemi += (ch === 'b' ? -1 : 1);
                            targetSemi = ((targetSemi % 12) + 12) % 12;
                            const targetDegreeStep = Math.round((targetSemi * edo) / 12);
                            let targetRoot = ((keyStep + targetDegreeStep) % edo + edo) % edo;
                            // optional micro on target
                            if (targetMicro) {
                                const ups2 = (targetMicro.match(/\^/g) || []).length;
                                const downs2 = (targetMicro.match(/v/g) || []).length;
                                targetRoot = (((targetRoot + ups2 - downs2) % edo) + edo) % edo;
                            }
                            referenceKeyStep = targetRoot; // Now interpret head roman relative to target key
                        }
                    }
                    // Keep the rest of the tail (quality/extensions) around the slash parts
                    tail = (preSlash + ' ' + (postTail || '')).trim();
                }

                // Now compute chord root relative to the chosen referenceKeyStep
                let rootStep = ((referenceKeyStep + headDegreeStep) % edo + edo) % edo;
                // Optional micro-step marks right after the numeral: e.g., ii^7, bVIIvv
                const microMatch = tail.match(/^([\^v]+)/);
                if (microMatch) {
                    const ups = (microMatch[1].match(/\^/g) || []).length;
                    const downs = (microMatch[1].match(/v/g) || []).length;
                    rootStep = (((rootStep + ups - downs) % edo) + edo) % edo;
                    tail = tail.slice(microMatch[1].length).trim();
                }
                const preferAccidental = acc && /b/.test(acc) ? 'flat' : (acc && /#/.test(acc) ? 'sharp' : undefined);
                const rootName = this.getMicrotonalNoteName(rootStep, preferAccidental ? { preferAccidental } : {});
                // Determine basic quality from case unless tail already encodes explicit quality (maj/M/m/°/ø/+/sus)
                let canonicalTail = tail.replace(/△/g,'maj');
                const hasExplicitQuality = /^(?:maj|M|m|°|ø|\+|sus)/.test(canonicalTail);
                const quality = hasExplicitQuality ? '' : (isMinor ? 'm' : '');
                // Special-case: user expectation that 'VII7' denotes fully diminished seventh
                if (!isMinor && roman.toUpperCase() === 'VII' && /(?:^|\b)7(?![0-9])/.test(canonicalTail)) {
                    canonicalTail = canonicalTail.replace(/(?:^|\b)7(?![0-9])/, '°7');
                }
                const chord = `${rootName}${quality}${canonicalTail}`.trim();
                return this.normalizeChordToken(chord) || chord;
            }

            copyParsedChordsToClipboard() {
                const list = (this._lastParsedChordsList || []).join(', ');
                if (!navigator.clipboard) {
                    // Fallback
                    const ta = document.createElement('textarea');
                    ta.value = list; document.body.appendChild(ta); ta.select();
                    try { document.execCommand('copy'); } catch {}
                    ta.remove();
                    return;
                }
                navigator.clipboard.writeText(list).catch(()=>{});
            }

            // Create chord columns from a list of normalized chord strings, then lock each to its own root
            autoCreateColumnsFromText(chordList) {
                // Replace the current grid with this sequence
                this.chordExtensions = [];
                // Reset visibility and any prior locks so board truly clears
                this.hiddenColumns = [];
                this.lockedChords = new Map();
                this.pianoLockedChords = new Map();
                const beforeLen = 0;
                const created = [];
                for (const chordStr of chordList) {
                    if (chordStr === '__SECTION__') {
                        // Insert a visual separator placeholder
                        const sep = {
                            name: '|',
                            isCustom: true,
                            isSeparator: true,
                            id: 'sep_' + (this.chordExtensions.length),
                            position: this.chordExtensions.length
                        };
                        this.chordExtensions.push(sep);
                        continue;
                    }
                    const added = this.addChordFromName(chordStr);
                    if (added) created.push(added);
                }
                // Render new chords
                this.normalizeChordPositions();
                if (typeof this.generateExactChordColumns === 'function') {
                    this.generateExactChordColumns();
                } else if (typeof this.generateExtensionColumns === 'function') {
                    this.generateExtensionColumns();
                }

                // Do NOT auto-lock new chords; keep everything editable and transposable per request
                const stepCents = Array.from({length: this.currentTuning}, (_,i)=> this.getCentValue(i, this.currentTuning));
                const container = document.getElementById('extensionColumns');
                const priorRoot = this.currentRoot;
                for (const data of created) {
                    const { chord, position, rootSemitone, rootStep } = data;
                    if (rootSemitone == null && rootStep == null) continue;
                    const lockedRoot = (rootStep != null) ? rootStep : this.findNearestStepForSemitone(rootSemitone, stepCents);
                    const column = container.querySelector(`.extension-column[data-original-position="${position}"]`);
                    if (!column) continue;
                    try {
                        // Temporarily switch root for this chord
                        const prevRoot = this.currentRoot;
                        this.currentRoot = lockedRoot;
                        // Recompute this column's string frequencies at this root so capture is correct
                        const strings = column.querySelectorAll('.string');
                        strings.forEach(string => {
                            // Prefer persisted EDO step and octave when available
                            const edoStep = parseInt(string.dataset.edoStep);
                            const octave = parseInt(string.dataset.octave);
                            const hasPersisted = !isNaN(edoStep) && !isNaN(octave);
                            let frequency;
                            let stepForName;
                            if (hasPersisted) {
                                // Absolute step in current tuning = lockedRoot + relative edoStep
                                const tuningSize = this.currentTuning;
                                const absStep = ((lockedRoot + edoStep) % tuningSize + tuningSize) % tuningSize;
                                stepForName = absStep;
                                frequency = this.getFrequency(absStep, octave, this.currentTuning);
                            } else {
                                // Fallback to interval-based recompute
                                const interval = parseInt(string.dataset.interval);
                                if (isNaN(interval)) return;
                                stepForName = (this.currentRoot + interval) % this.currentTuning;
                                // Interpret interval as relative step from currentRoot
                                const absStep2 = ((this.currentRoot + interval) % this.currentTuning + this.currentTuning) % this.currentTuning;
                                frequency = this.getFrequency(absStep2, octave, this.currentTuning);
                            }

                            string.dataset.frequency = frequency;
                            // Keep existing inner structure (core div) and just update tooltip and vibration period
                            const noteName = this.getNoteNames()[stepForName] || this.getIntervalNoteName(parseInt(string.dataset.interval)||0);
                            string.title = `${noteName} (${hasPersisted ? `step ${stepForName}` : `interval ${string.dataset.interval}`} , ${frequency.toFixed(1)}Hz)`;
                            const core = string.querySelector('.string-core');
                            if (core) {
                                const period = this.computeVibrationPeriod(frequency, stepForName);
                                core.style.setProperty('--vib-period', period + 'ms');
                            }
                        });
                        // Do not snapshot/lock automatically
                        // Restore global root for subsequent chords
                        this.currentRoot = prevRoot;
                    } catch (_) {}
                }
                this.currentRoot = priorRoot;
            }

            // Map chord name to a chordExtensions entry with computed intervals. Returns {chord, position, rootSemitone, rootStep}
            addChordFromName(chordName) {
                const norm = this.normalizeChordToken(chordName);
                if (!norm) return null;
                const rootMatch = norm.match(/^([A-G])([#b]?)([\^v]*)/);
                const rootSemitone = rootMatch ? this.rootToSemitone(rootMatch[1], rootMatch[2]||'') : null;
                // Compute root step in current EDO including micro marks (^ up, v down). Multiple marks accumulate.
                let rootStep = null;
                if (rootSemitone != null) {
                    const baseStep = Math.round((rootSemitone * this.currentTuning) / 12);
                    const microMarks = (rootMatch && rootMatch[3]) ? rootMatch[3] : '';
                    const ups = (microMarks.match(/\^/g) || []).length;
                    const downs = (microMarks.match(/v/g) || []).length;
                    rootStep = ((baseStep + ups - downs) % this.currentTuning + this.currentTuning) % this.currentTuning;
                }
                const quality = norm.replace(/^([A-G][#b]?[\^v]*)/, '');
                // Exclude slash bass from stacked-interval parsing; it will be added explicitly below
                const tailForIntervals = quality.replace(/\/[A-G](?:#|b)?/, '');
                let intervals = this.parseChordQualityToIntervals(tailForIntervals);

                // Slash chord handling: if tail contains "/<bass>", add that bass pitch as an extra interval
                // Example: G/F -> add b7 (F relative to G)
                const slash = quality.match(/\/([A-G](?:#|b)?)/);
                if (slash && rootSemitone != null) {
                    const bassLetter = slash[1][0];
                    const bassAcc = slash[1].length > 1 ? slash[1][1] : '';
                    const bassSemi = this.rootToSemitone(bassLetter, bassAcc);
                    // Interval difference bass relative to root in 12-TET (0..11)
                    const diffSemi = ((bassSemi - rootSemitone) % 12 + 12) % 12;
                    // Map to current EDO
                    const mapped = Math.round((diffSemi * this.currentTuning) / 12);
                    if (!intervals.includes(mapped)) {
                        intervals = [...intervals, mapped].sort((a,b)=>a-b);
                    }
                }
                const newChord = {
                    name: norm,
                    intervals,
                    isCustom: true,
                    id: 'import_' + Date.now() + '_' + Math.floor(Math.random()*1e6),
                    createdAt: Date.now(),
                    position: this.chordExtensions.length,
                    originalRoot: 0,
                    originalTuning: this.currentTuning,
                    originalGamelanMode: this.gamelanMode,
                    lastTuning: this.currentTuning,
                    headerColor: this.getIntervalColor(0)?.color || '#14b8a6',
                    localTranspose: 0,
                    // Set a fixed absolute root so keyboard edits use the correct base
                    fixedRootStepAbs: (rootStep != null ? rootStep : 0),
                    fixedRootTuning: this.currentTuning
                };
                this.chordExtensions.push(newChord);
                return { chord: newChord, position: newChord.position, rootSemitone, rootStep };
            }

            // Convert chord quality/extensions tail to interval steps in current EDO
            parseChordQualityToIntervals(tail) {
                // Defaults to major triad if unspecified
                const map = (semi)=> Math.round((semi * this.currentTuning) / 12);
                const add = (set, semi)=> set.add(map(semi));
                const set = new Set([0]);
                let third = 4; // major
                let fifth = 7;
                let hasThird = true;

                const t = (tail || '').trim();
                const has = (pat)=> new RegExp(pat).test(t);

                // quality
                const isMinorQuality = /^m(?!aj)/.test(t);
                if (isMinorQuality) third = 3; // 'm' but not 'maj'
                // bare half-diminished symbol: treat as ø7 by default
                if (/^ø(?!7)/.test(t)) { third = 3; fifth = 6; }
                if (/^°/.test(t)) { third = 3; fifth = 6; }
                if (/^\+/.test(t)) { third = 4; fifth = 8; }
                if (/sus2/.test(t)) { hasThird = false; }
                if (/sus4/.test(t)) { hasThird = false; }

                // base triad
                if (hasThird) add(set, third);
                add(set, fifth);
                if (/sus2/.test(t)) add(set, 2);
                if (/sus4/.test(t)) add(set, 5);

                // seventh family
                const hasMaj7 = /maj7|Δ7|M7/.test(t);
                if (hasMaj7) add(set, 11);
                else if (/ø7/.test(t) || /^ø(?!7)/.test(t)) { add(set, 10); add(set, 6); third = 3; }
                else if (/°7/.test(t) || /dim7|diminished\s*7(?:th)?|o7/.test(t)) { add(set, 9); third = 3; fifth = 6; }
                else if (/m7/.test(t)) { add(set, 10); third = 3; }
                else if (/7(?![0-9])/.test(t)) { add(set, 10); }

                // 6th
                if (/(?:^|[^0-9])6(?![0-9])/.test(t)) add(set, 9);

                // Extensions with canonical stacking rules:
                // 9 implies 7; 11 implies 9+7; 13 implies 11+9+7.
                // Exception: m9 (minor ninth) skips the 7th unless explicitly present.
                // Plain '7' (dominant) only if not part of maj7/m7/°7/ø7 tokens
                const hasPlain7  = /(?:^|[^0-9])7(?![0-9])/.test(t) && !/(?:maj7|M7|Δ7|m7|°7|ø7)/.test(t);
                const hasAdd9    = /add9/.test(t);
                const hasAdd11   = /add11/.test(t);
                const hasAdd13   = /add13/.test(t);
                const hasSharp11 = /#11|♯11/.test(t);
                const hasSharp13 = /#13|♯13/.test(t);
                const isMaj9     = /maj9|M9|Δ9/.test(t);
                const isMinor9   = /^m9(?![0-9])/.test(t) || /\bm9(?![0-9])/.test(t);
                const has9       = /(?:^|[^0-9])9(?![0-9])/.test(t) && !hasAdd9 && !isMaj9 && !isMinor9;
                // If #11 is present together with 13, we'll handle the sharped 11 inside the 13 stack below
                const has11      = /(?:^|[^0-9])11(?![0-9])/.test(t) && !hasAdd11 && !hasSharp11;
                const has13      = /(?:^|[^0-9])13(?![0-9])/.test(t) && !hasAdd13 && !hasSharp13;

                // maj9
                if (isMaj9) { add(set, 11); add(set, 14); }
                // m9 (no implied 7th)
                if (isMinor9) { add(set, 14); }
                // Plain stacked 9/11/13
                if (has9) { if (!hasMaj7) add(set, 10); add(set, 14); }
                if (has11) { if (!hasMaj7) add(set, 10); add(set, 14); add(set, 17); }
                if (hasSharp11 && !has13) { // standalone #11 (not tied to 13)
                    if (!hasMaj7) add(set, 10); add(set, 14); add(set, 18);
                }
                if (has13) {
                    // 13 implies 7+9+11; if #11 present, sharpen the 11 inside this stack
                    if (!hasMaj7) add(set, 10); // 7 (only if no maj7 present)
                    add(set, 14); // 9
                    if (hasSharp11) add(set, 18); else add(set, 17); // 11 or #11
                    add(set, 21); // 13
                }
                if (hasSharp13) { if (!hasMaj7) add(set, 10); add(set, 14); add(set, 17); add(set, 22); }
                // Explicit 7
                if (hasPlain7) { add(set, 10); }

                // add tones
                if (/add9/.test(t)) add(set, 14);
                if (/add11/.test(t)) add(set, 17);
                if (/add13/.test(t)) add(set, 21);

                // alterations
                if (/♭5|b5|\-5/.test(t)) { set.delete(map(7)); add(set, 6); }
                if (/♯5|#5/.test(t)) { set.delete(map(7)); add(set, 8); }
                if (/♭9|b9|\-9/.test(t)) add(set, 13);
                if (/♯9|#9/.test(t)) add(set, 15);
                if (/♯11|#11/.test(t)) add(set, 18);

                // Microtonal '^' (raise) and 'v' (lower) modifiers on extensions
                // Helper: add a degree with optional microstep offset in current EDO
                const EDO = this.currentTuning;
                const degToSemi = {2:2,3:3,4:5,5:7,6:9,7:10,9:14,11:17,13:21};
                const addMicroDegree = (deg, microSteps=0)=>{
                    const semi = degToSemi[deg];
                    if (semi == null) return;
                    const base = map(semi);
                    let target = base + microSteps;
                    // wrap within EDO for safety
                    target = ((target % EDO) + EDO) % EDO;
                    set.add(target);
                };
                const microShiftOf = (s)=> ((s.match(/\^/g)||[]).length - (s.match(/v/g)||[]).length);

                // addv7/add^9/addv11/add^13 etc.
                const addMicroRe = /add([\^v]+)(2|3|4|5|6|7|9|11|13)/g;
                let mm;
                while ((mm = addMicroRe.exec(t)) !== null) {
                    const shift = microShiftOf(mm[1]);
                    const deg = parseInt(mm[2],10);
                    addMicroDegree(deg, shift);
                }

                // Bare micro-marked degrees like v7, ^9, v13
                const bareMicroRe = /(?:^|[^A-Za-z])([\^v]+)(2|3|4|5|6|7|9|11|13)(?![0-9])/g;
                while ((mm = bareMicroRe.exec(t)) !== null) {
                    const shift = microShiftOf(mm[1]);
                    const deg = parseInt(mm[2],10);
                    if (deg === 9) {
                        if (!hasMaj7) add(set, 10); // implied 7
                        addMicroDegree(9, shift);
                    } else if (deg === 11) {
                        if (!hasMaj7) add(set, 10);
                        add(set, 14); // implied 9
                        addMicroDegree(11, shift);
                    } else if (deg === 13) {
                        if (!hasMaj7) add(set, 10);
                        add(set, 14); // 9
                        add(set, hasSharp11 ? 18 : 17); // respect #11 if also present
                        addMicroDegree(13, shift);
                    } else {
                        addMicroDegree(deg, shift);
                    }
                }

                // Return sorted unique
                return Array.from(set).sort((a,b)=>a-b);
            }

            rootToSemitone(letter, acc) {
                const base = {C:0,D:2,E:4,F:5,G:7,A:9,B:11}[letter] ?? 0;
                if (acc === '#') return (base + 1) % 12;
                if (acc === 'b') return (base + 11) % 12;
                return base;
            }

            // Core parser: returns normalized chord strings including root (e.g., Bb7, Caug)
            extractUniqueChordsFromText(text) {
                if (!text) return [];
                const lines = String(text).split(/\r?\n/);
                const seen = new Set();
                const out = [];

                const pushNorm = (raw)=>{
                    const norm = this.normalizeChordToken(raw);
                    if (!norm) return;
                    const key = norm.toLowerCase();
                    if (!seen.has(key)) { seen.add(key); out.push(norm); }
                };

                for (const line of lines) {
                    const s = line.trim();
                    if (!s) continue;

                    // First, grab all chord-like matches with positions
                    const matches = this.scanChordMatches(s);
                    // Accept all matches; dedupe later
                    for (const m of matches) pushNorm(m.raw);
                }

                return out;
            }

            // Return array of { raw, start, end } chord-like matches within a string
            scanChordMatches(s) {
                // Normalize and strip section headings like "A:" "B:" before tokenizing
                const text = String(s)
                    .replace(/♭/g,'b')
                    .replace(/♯/g,'#')
                    .replace(/(^|\s)[^\s|:]+\s*:\s*/g, ' ');
                // Match a chord token up to the next whitespace or punctuation; do NOT consume spaces across tokens
                // Match compact slash chords like G/F but not spaced G / F (space breaks tokens)
                const re = /\b([A-G])(?:#|b|\-)?(?:[\^v]+)?(?:add|maj|min|dim|aug|mM|sus|m|M|\+|°|ø)?[A-Za-z0-9#bø°\+\-\^v]*(?:\/(?:[A-G](?:#|b)?))?/g;
                const found = [];
                let m;
                while ((m = re.exec(text)) !== null) {
                    const raw = m[0].trim();
                    // Keep single-letter roots (e.g., G) — treat as valid chords
                    found.push({ raw, start: m.index, end: m.index + m[0].length });
                }
                return found;
            }

            // Tokenize candidates allowing: flats as b or '-', sharps as #, unicode ♭/♯, letters A–G, and common quality tails
            tokenizePossibleChords(text) {
                return this.scanChordMatches(text).map(x=>x.raw);
            }

            // Normalize one token to a canonical chord string
            normalizeChordToken(rawToken) {
                if (!rawToken) return null;
                if (rawToken === '__SECTION__' || rawToken === '|') return '__SECTION__';
                let t = rawToken.trim();
                // Standardize unicode and spaces
                t = t.replace(/♭/g,'b').replace(/♯/g,'#');
                // Important: do NOT remove all spaces blindly; we must distinguish "G / F" (two chords) from "G/F" (slash chord)
                // We'll collapse spaces except when a slash is present with spaces around it; in that case, keep spaces so scanner splits tokens
                if (/\/[A-G]/.test(t)) {
                    // Already a compact slash chord like G/F – remove other spaces
                    t = t.replace(/\s+/g,'');
                } else {
                    // Keep spaces, they help tokenization stage treat G / F as separate tokens
                    t = t.replace(/\s{2,}/g,' ').trim();
                }

                // Root parse: letter + optional accidental (#, b, -) and optional micro marks (^ up, v down)
                const mRoot = t.match(/^([A-G])([#b\-]?)([\^v]*)(.*)$/);
                if (!mRoot) return null;
                const letter = mRoot[1];
                const acc = mRoot[2] === '-' ? 'b' : (mRoot[2] || '');
                const micro = mRoot[3] || '';
                let tail = mRoot[4] || '';
                // Normalize spacing before interpreting quality/extensions
                tail = tail.trim();
                // Normalize common spaced variants like "Maj 7", "Maj 9" → "maj7", "maj9"
                tail = tail.replace(/^maj\s*(?=(?:7|9|11|13)\b)/i, 'maj');
                tail = tail.replace(/^M\s*(7|9|11|13)/, 'M$1');

                // Guard: ignore bare two-letter words that look like lyrics (e.g., "Bu", "Ea")
                // Criteria: exactly two chars, second is a lowercase vowel, and no chord markers like m, M, digits, +, °, ø, #, b, or /
                if (!acc && !micro && /^[A-G][aeiou]$/.test(t) && !/[mM0-9+°ø#b/]/.test(t)) {
                    return null;
                }

                // Convert common synonyms/variants in the tail
                // min/maj shorthand
                tail = tail.replace(/^min/i,'m');
                tail = tail.replace(/^maj/i,'M');
                // diminished
                tail = tail.replace(/^dim/i,'°'); // use ° as canonical dim triad
                // half-diminished
                tail = tail.replace(/^ø/i,'ø');
                // augmented
                if (/^aug/i.test(tail) || /^\+/i.test(tail)) {
                    tail = tail.replace(/^aug/i,'+');
                    // Ensure + remains
                    if (!/^\+/.test(tail)) tail = '+' + tail;
                }
                // handle c+ etc: if tail starts with '+', keep as augmented triad unless specific tensions follow
                // sus synonyms already OK

                // Remove any remaining internal spaces in the tail to keep tokens intact (e.g., Maj 9 → M9)
                tail = tail.replace(/\s+/g, '');

                // Flats and sharps on extensions, allow b or -
                tail = tail.replace(/\-([0-9]+)/g,'b$1'); //  -7 -> b7
                tail = tail.replace(/b11/g,'♭11').replace(/b9/g,'♭9').replace(/b5/g,'♭5').replace(/b13/g,'♭13');
                tail = tail.replace(/#([0-9]+)/g,'♯$1');

                // Support simple slash chords bass note like /G or /Gb (compact only, no spaces)
                // Uppercase only the letter, keep accidental case
                tail = tail.replace(/\/([A-G])((?:#|b)?)$/g, (_, L, acc)=> '/' + L.toUpperCase() + acc);

                // Clean trailing punctuation or lyrics fragments after a closing bracket/paren or comma/semicolon
                tail = tail.replace(/[\],;:]+.*$/,'');
                // Keep valid tail characters, including A–G for slash bass notes (e.g., /G, /Bb)
                // Include Δ (major) so previously-normalized tokens like CΔ7/CΔ9 survive re-normalization
                tail = tail.replace(/[^A-GmM°øΔ+suad0-9♭♯/#^vb]+.*$/,'');

                // If tail empty, it's a bare triad: major by default -> ''
                // If tail equals 'min' was converted to 'm' above.

                // Special: 'dim' used with 7 -> °7; 'm7b5' normalize to ø7
                // m7b5 or m7-5 → ø7
                if (/^m7(?:♭|b|\-)?5$/i.test(tail)) tail = 'ø7';
                if (/^dim7$/i.test(tail)) tail = '°7';
                if (/^dim$/i.test(tail)) tail = '°';

                // Compose root + tail (allow bare single-letter chords e.g., G)
                const root = letter + acc + micro;
                let chord = root + tail;

                // Cosmetic: convert 'Bbb' accidents or double signs not handled here; keep simple
                // Display: prefer 'maj' wording over Δ or bare 'M'
                chord = chord.replace(/Δ(7|9|11|13)/g,'maj$1').replace(/M(7|9|11|13)/g,'maj$1');

                return chord;
            }
            
            // ============= CHORD BUILDER SETUP =============
            
            showSimpleChordBuilder() {
                // Create a simple modal for custom chord building
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                `;
                
                const tuningSize = this.getTuningStepsPerOctave();
                const noteNames = this.getNoteNames();
                
                // Create note selector grid
                let notesGrid = '';
                for (let i = 0; i < tuningSize; i++) {
                    const isDiatonic = this.isDiatonicNote(i);
                    const noteClass = isDiatonic ? 'note-btn diatonic' : 'note-btn';
                    notesGrid += `
                        <button class="${noteClass}" data-note="${i}" style="
                            background: ${isDiatonic ? '#1e40af' : '#374151'};
                            color: white;
                            border: 1px solid ${isDiatonic ? '#3b82f6' : '#6b7280'};
                            padding: 8px;
                            margin: 2px;
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 12px;
                            min-width: 40px;
                        ">${noteNames[i] || i}</button>
                    `;
                }
                
                modal.innerHTML = `
                    <div style="
                        background: #1f2937;
                        border-radius: 12px;
                        padding: 20px;
                        max-width: 600px;
                        width: 90%;
                        max-height: 80vh;
                        overflow-y: auto;
                        color: white;
                    ">
                        <h2 style="margin: 0 0 20px 0; color: #f3f4f6;">Create Custom Chord</h2>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Chord Name:</label>
                            <input type="text" id="simpleChordName" placeholder="Enter chord name" style="
                                width: 100%;
                                padding: 8px;
                                border: 1px solid #6b7280;
                                border-radius: 4px;
                                background: #374151;
                                color: white;
                                font-size: 14px;
                            ">
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">
                                Select Notes (Blue = Diatonic):
                            </label>
                            <div style="
                                display: grid;
                                grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
                                gap: 4px;
                                max-height: 200px;
                                overflow-y: auto;
                                border: 1px solid #6b7280;
                                padding: 10px;
                                border-radius: 4px;
                                background: #2d3748;
                            " id="simpleNotesGrid">
                                ${notesGrid}
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <button id="previewSimpleChord" style="
                                background: #059669;
                                color: white;
                                border: none;
                                padding: 8px 16px;
                                border-radius: 4px;
                                cursor: pointer;
                                margin-right: 10px;
                            ">?? Preview</button>
                            <button id="clearSimpleChord" style="
                                background: #dc2626;
                                color: white;
                                border: none;
                                padding: 8px 16px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">Clear</button>
                        </div>
                        
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button id="cancelSimpleChord" style="
                                background: #6b7280;
                                color: white;
                                border: none;
                                padding: 10px 20px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">Cancel</button>
                            <button id="saveSimpleChord" style="
                                background: #1e40af;
                                color: white;
                                border: none;
                                padding: 10px 20px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">Save Chord</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Add event listeners
                this.setupSimpleChordBuilderEvents(modal);
            }
            
            setupSimpleChordBuilderEvents(modal) {
                // Note selection
                modal.querySelectorAll('.note-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        btn.classList.toggle('selected');
                        if (btn.classList.contains('selected')) {
                            btn.style.background = btn.classList.contains('diatonic') ? '#3b82f6' : '#6b7280';
                            btn.style.boxShadow = '0 0 8px rgba(59, 130, 246, 0.5)';
                        } else {
                            btn.style.background = btn.classList.contains('diatonic') ? '#1e40af' : '#374151';
                            btn.style.boxShadow = 'none';
                        }
                    });
                });
                
                // Preview chord
                modal.querySelector('#previewSimpleChord').addEventListener('click', () => {
                    const selectedNotes = this.getSelectedNotesFromModal(modal);
                    if (selectedNotes.length === 0) {
                        alert('Please select at least one note!');
                        return;
                    }
                    this.previewCustomChord(selectedNotes);
                });
                
                // Clear selection
                modal.querySelector('#clearSimpleChord').addEventListener('click', () => {
                    modal.querySelectorAll('.note-btn.selected').forEach(btn => {
                        btn.classList.remove('selected');
                        btn.style.background = btn.classList.contains('diatonic') ? '#1e40af' : '#374151';
                        btn.style.boxShadow = 'none';
                    });
                });
                
                // Save chord
                modal.querySelector('#saveSimpleChord').addEventListener('click', () => {
                    const chordName = modal.querySelector('#simpleChordName').value.trim();
                    const selectedNotes = this.getSelectedNotesFromModal(modal);
                    
                    if (!chordName) {
                        alert('Please enter a chord name!');
                        return;
                    }
                    
                    if (selectedNotes.length === 0) {
                        alert('Please select at least one note!');
                        return;
                    }
                    
                    this.saveSimpleCustomChord(chordName, selectedNotes);
                    modal.remove();
                    if (typeof this.closeBottomPanel === 'function') this.closeBottomPanel();
                });
                
                // Cancel
                modal.querySelector('#cancelSimpleChord').addEventListener('click', () => {
                    modal.remove();
                });
                
                // Close on ESC
                const closeOnEsc = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', closeOnEsc);
                    }
                };
                document.addEventListener('keydown', closeOnEsc);
            }
            
            isDiatonicNote(noteIndex) {
                // Check if note is diatonic (major scale intervals in current tuning)
                const tuningSize = this.getTuningStepsPerOctave();
                const diatonicIntervals = [0, 2, 4, 5, 7, 9, 11]; // Major scale in semitones
                
                // Map to current tuning
                const diatonicSteps = diatonicIntervals.map(interval => 
                    Math.round((interval * tuningSize) / 12)
                );
                
                return diatonicSteps.includes(noteIndex);
            }
            
            getSelectedNotesFromModal(modal) {
                const selectedButtons = modal.querySelectorAll('.note-btn.selected');
                return Array.from(selectedButtons).map(btn => parseInt(btn.dataset.note));
            }
            
            previewCustomChord(selectedNotes) {
                // Play the selected notes as a chord
                const baseOctave = 4;
                selectedNotes.forEach(noteStep => {
                    const freq = this.getFrequency(noteStep, baseOctave, this.currentTuning);
                    this.playFrequency(freq, null);
                });
                
                // Stop after 1 second
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 1000);
            }
            
            saveSimpleCustomChord(chordName, selectedNotes) {
                // Create a single chord extension that will auto-generate all 3 qualities
                const chordExtension = {
                    name: chordName,
                    intervals: selectedNotes,
                    isCustom: true,
                    id: chordName.toLowerCase().replace(/\s+/g, '_')
                };
                
                // ADD to existing chords instead of replacing them
                this.chordExtensions.push(chordExtension);
                
                // Save and regenerate
                this.saveChordConfiguration();
                this.preserveLockedChordsAndRegenerate();
                
                console.log(`Added custom chord: ${chordName} with notes:`, selectedNotes);
            }

            getTuningDisplayName() {
                if (this.gamelanMode) return 'Gamelan';
                switch(this.currentTuning) {
                    case 5: return '5-EDO';
                    case 7: return '7-EDO';
                    case 11: return 'C.Gamma';
                    case 12: return '12-TET';
                    case 15: return '15-EDO';
                    case 17: return '17-EDO';
                    case 19: return '19-TET';
                    case 22: return '22-TET';
                    case 24: return '24-TET';
                    case 31: return '31-TET';
                    case 34: return '34-TET';
                    case 53: return '53-TET';
                    default: return `${this.currentTuning}-TET`;
                }
            }
            
            updateFavoritesDisplay() {
                // This method appears to be unused/orphaned - keeping as placeholder
            }
            
            populateChordBuilderNoteSelector() {
                const selector = document.getElementById('chordBuilderNoteSelector');
                selector.innerHTML = '';
                
                const edoSize = this.gamelanMode ? 7 : this.currentTuning;
                
                for (let i = 0; i < edoSize; i++) {
                    const button = document.createElement('div');
                    button.className = 'note-btn';
                    button.dataset.note = i;
                    button.textContent = this.getMicrotonalNoteName(i);
                    
                    // Color coding for diatonic highlighting
                    button.style.cssText = `
                        padding: 8px 4px;
                        background: ${this.getDiatonicNoteColor(i)};
                        border: 2px solid ${this.getDiatonicNoteBorderColor(i)};
                        color: white;
                        cursor: pointer;
                        border-radius: 6px;
                        font-size: 11px;
                        font-weight: bold;
                        text-align: center;
                        transition: all 0.2s;
                        user-select: none;
                    `;
                    
                    button.addEventListener('click', () => {
                        button.classList.toggle('selected');
                        if (button.classList.contains('selected')) {
                            button.style.borderColor = '#f39c12';
                            button.style.boxShadow = '0 0 8px rgba(243, 156, 18, 0.6)';
                        } else {
                            button.style.borderColor = this.getDiatonicNoteBorderColor(i);
                            button.style.boxShadow = 'none';
                        }
                    });
                    
                    selector.appendChild(button);
                }
            }
            
            populateChordExtensions() {
                const checkboxContainer = document.getElementById('chordExtensionsCheckboxes');
                checkboxContainer.innerHTML = '';
                
                const extensions = [
                    { name: 'Major', intervals: [0, 4, 7], base: true },
                    { name: 'Minor', intervals: [0, 3, 7], base: true },
                    { name: 'Neutral', intervals: [0, 3.5, 7], base: true },
                    { name: 'Diminished', intervals: [0, 3, 6] },
                    { name: 'Augmented', intervals: [0, 4, 8] },
                    { name: 'sus2', intervals: [0, 2, 7] },
                    { name: 'sus4', intervals: [0, 5, 7] },
                    { name: 'maj7', intervals: [11] },
                    { name: '7th', intervals: [10] },
                    { name: '6th', intervals: [9] },
                    { name: '9th', intervals: [14] },
                    { name: 'add9', intervals: [2] },
                    { name: '11th', intervals: [17] },
                    { name: '13th', intervals: [21] },
                    { name: '?9', intervals: [13] },
                    { name: '?9', intervals: [15] },
                    { name: '?11', intervals: [18] },
                    { name: '?13', intervals: [20] },
                    { name: '?13', intervals: [22] }
                ];
                
                extensions.forEach((ext, index) => {
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.style.display = 'flex';
                    checkboxDiv.style.alignItems = 'center';
                    checkboxDiv.style.gap = '6px';
                    checkboxDiv.style.padding = '4px 8px';
                    checkboxDiv.style.borderRadius = '4px';
                    checkboxDiv.style.background = ext.base ? 'rgba(74, 144, 226, 0.2)' : 'rgba(255, 255, 255, 0.1)';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `ext_${index}`;
                    checkbox.dataset.intervals = JSON.stringify(ext.intervals);
                    checkbox.style.cursor = 'pointer';
                    
                    const label = document.createElement('label');
                    label.htmlFor = `ext_${index}`;
                    label.textContent = ext.name;
                    label.style.fontSize = '12px';
                    label.style.cursor = 'pointer';
                    label.style.color = ext.base ? '#4a90e2' : '#8fb3d3';
                    label.style.fontWeight = ext.base ? 'bold' : 'normal';
                    
                    checkbox.addEventListener('change', () => {
                        this.updateChordPreview();
                    });
                    
                    // Add hover preview for extensions
                    checkboxDiv.addEventListener('mouseenter', () => {
                        this.previewIntervals(ext.intervals);
                    });
                    
                    checkboxDiv.addEventListener('mouseleave', () => {
                        this.stopPreview();
                    });
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(label);
                    checkboxContainer.appendChild(checkboxDiv);
                });
            }
            
            populateMicrotonalIntervals() {
                const checkboxContainer = document.getElementById('microtonalCheckboxes');
                checkboxContainer.innerHTML = '';
                
                // Generate all intervals in the current EDO
                for (let step = 1; step < this.currentTuning; step++) {
                    const semitones = (step * 12) / this.currentTuning;
                    const cents = semitones * 100;
                    
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.style.display = 'flex';
                    checkboxDiv.style.alignItems = 'center';
                    checkboxDiv.style.gap = '4px';
                    checkboxDiv.style.padding = '3px 6px';
                    checkboxDiv.style.borderRadius = '3px';
                    checkboxDiv.style.fontSize = '11px';
                    
                    // Color coding based on interval type
                    const color = this.getDiatonicNoteColor(step);
                    checkboxDiv.style.background = color + '20'; // Add transparency
                    checkboxDiv.style.borderLeft = `3px solid ${color}`;
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `micro_${step}`;
                    checkbox.dataset.semitones = semitones.toString();
                    checkbox.dataset.step = step.toString();
                    checkbox.style.cursor = 'pointer';
                    checkbox.style.transform = 'scale(0.8)';
                    
                    const label = document.createElement('label');
                    label.htmlFor = `micro_${step}`;
                    label.style.fontSize = '10px';
                    label.style.cursor = 'pointer';
                    label.style.color = '#fff';
                    label.style.fontFamily = 'monospace';
                    
                    // Create descriptive label
                    const noteName = this.getMicrotonalNoteName(step);
                    const centsStr = cents >= 0 ? `+${cents.toFixed(0)} ` : `${cents.toFixed(0)} `;
                    label.textContent = `${noteName} (${centsStr})`;
                    
                    checkbox.addEventListener('change', () => {
                        this.updateChordPreview();
                    });
                    
                    // Add hover preview for microtonal intervals
                    checkboxDiv.addEventListener('mouseenter', () => {
                        this.previewIntervals([semitones]);
                    });
                    
                    checkboxDiv.addEventListener('mouseleave', () => {
                        this.stopPreview();
                    });
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(label);
                    checkboxContainer.appendChild(checkboxDiv);
                }
            }
            
            updateChordPreview() {
                const previewDisplay = document.getElementById('chordPreviewDisplay');
                if (!previewDisplay) return;
                
                const selectedIntervals = this.getSelectedChordIntervals();
                
                if (selectedIntervals.length === 0) {
                    previewDisplay.textContent = 'No intervals selected';
                    previewDisplay.style.color = '#8fb3d3';
                    return;
                }
                
                // Sort intervals
                selectedIntervals.sort((a, b) => a - b);
                
                // Create preview text
                let previewText = 'Selected intervals: ';
                previewText += selectedIntervals.map(interval => {
                    if (interval === 0) return 'Root';
                    const semitones = interval;
                    const cents = Math.round(semitones * 100);
                    return `${semitones.toFixed(1)}? (${cents} )`;
                }).join(', ');
                
                previewDisplay.textContent = previewText;
                previewDisplay.style.color = '#27ae60';
            }
            
            getSelectedChordIntervals() {
                const intervals = [0]; // Always include root
                
                // Get selected diatonic extensions
                const extensionCheckboxes = document.querySelectorAll('#chordExtensionsCheckboxes input[type="checkbox"]:checked');
                extensionCheckboxes.forEach(checkbox => {
                    const extIntervals = JSON.parse(checkbox.dataset.intervals);
                    intervals.push(...extIntervals);
                });
                
                // Get selected microtonal intervals
                const microCheckboxes = document.querySelectorAll('#microtonalCheckboxes input[type="checkbox"]:checked');
                microCheckboxes.forEach(checkbox => {
                    const semitones = parseFloat(checkbox.dataset.semitones);
                    intervals.push(semitones);
                });
                
                // Remove duplicates and sort
                return [...new Set(intervals)].sort((a, b) => a - b);
            }
            
            previewIntervals(intervals) {
                // Stop any existing preview
                this.stopPreview();
                
                // Start preview timeout to avoid too many rapid previews
                this.previewTimeout = setTimeout(() => {
                    if (!intervals || intervals.length === 0) return;
                    
                    // Play the intervals as a chord
                    const baseOctave = 4;
                    intervals.forEach((interval, index) => {
                        setTimeout(() => {
                            const step = this.semitoneToEDOStep(interval);
                            const frequency = this.getFrequency(step, baseOctave, this.currentTuning);
                            const mockElement = { classList: { add: () => {}, remove: () => {} } };
                            this.playFrequency(frequency, mockElement);
                            
                            // Store the frequency for later cleanup
                            if (!this.previewFrequencies) this.previewFrequencies = [];
                            this.previewFrequencies.push(frequency);
                        }, index * 30); // Slight arpeggiation
                    });
                    
                    // Auto-stop preview after 800ms
                    this.previewStopTimeout = setTimeout(() => {
                        this.stopPreview();
                    }, 800);
                }, 100); // 100ms delay to avoid rapid firing
            }
            
            stopPreview() {
                // Clear timeouts
                if (this.previewTimeout) {
                    clearTimeout(this.previewTimeout);
                    this.previewTimeout = null;
                }
                if (this.previewStopTimeout) {
                    clearTimeout(this.previewStopTimeout);
                    this.previewStopTimeout = null;
                }
                
                // Stop all preview frequencies
                if (this.previewFrequencies) {
                    this.previewFrequencies.forEach(frequency => {
                        const mockElement = { classList: { add: () => {}, remove: () => {} } };
                        this.stopFrequency(frequency, mockElement);
                    });
                    this.previewFrequencies = [];
                }
            }
            
            updateChordBuilderFromExtensions() {
                // Get selected extensions
                const activeExtensions = Array.from(document.querySelectorAll('#chordExtensionsGrid .osc-btn.active'))
                    .map(btn => btn.textContent);
                
                // Convert extensions to intervals
                const intervals = this.convertExtensionsToIntervals(activeExtensions);
                
                // Update note selector to reflect these intervals
                this.loadChordPatternIntoBuilder(intervals);
            }
            
            convertExtensionsToIntervals(extensions) {
                const intervals = [0]; // Always include root
                const baseTriad = this.getBaseTriadForQuality();
                intervals.push(...baseTriad.slice(1)); // Add 3rd and 5th
                
                extensions.forEach(ext => {
                    switch(ext) {
                        case '6th': intervals.push(9); break;
                        case '7th': intervals.push(10); break;
                        case 'maj7': intervals.push(11); break;
                        case '9th': intervals.push(14); break;
                        case '?9': intervals.push(13); break;
                        case '?9': intervals.push(15); break;
                        case '11th': intervals.push(17); break;
                        case '?11': intervals.push(16); break;
                        case '?11': intervals.push(18); break;
                        case '13th': intervals.push(21); break;
                        case '?13': intervals.push(20); break;
                        case '?13': intervals.push(22); break;
                        case 'sus2': 
                            intervals.splice(intervals.indexOf(baseTriad[1]), 1); // Remove 3rd
                            intervals.push(2); 
                            break;
                        case 'sus4': 
                            intervals.splice(intervals.indexOf(baseTriad[1]), 1); // Remove 3rd
                            intervals.push(5); 
                            break;
                        case 'add9': intervals.push(14); break;
                        case 'dim': 
                            intervals[intervals.indexOf(baseTriad[1])] = 3; // ?3
                            intervals[intervals.indexOf(baseTriad[2])] = 6; // ?5
                            break;
                        case 'aug': 
                            intervals[intervals.indexOf(baseTriad[2])] = 8; // ?5
                            break;
                    }
                });
                
                return [...new Set(intervals)].sort((a, b) => a - b);
            }
            
            getBaseTriadForQuality() {
                switch(this.currentQuality) {
                    case 'major': return [0, 4, 7];
                    case 'minor': return [0, 3, 7];
                    case 'neutral': return [0, 3.5, 7];
                    default: return [0, 4, 7];
                }
            }
            
            loadChordPatternIntoBuilder(intervals) {
                // Clear all selections first
                document.querySelectorAll('#chordBuilderNoteSelector .note-btn').forEach(btn => {
                    btn.classList.remove('selected');
                    btn.style.borderColor = this.getDiatonicNoteBorderColor(parseInt(btn.dataset.note));
                    btn.style.boxShadow = 'none';
                });
                
                // Convert 12-TET intervals to current EDO
                intervals.forEach(interval => {
                    const edoStep = this.semitoneToEDOStep(interval);
                    const button = document.querySelector(`#chordBuilderNoteSelector .note-btn[data-note="${edoStep}"]`);
                    if (button) {
                        button.classList.add('selected');
                        button.style.borderColor = '#f39c12';
                        button.style.boxShadow = '0 0 8px rgba(243, 156, 18, 0.6)';
                    }
                });
            }
            
            semitoneToEDOStep(semitones) {
                // Convert 12-TET semitones to current EDO step
                const exactStep = (semitones / 12) * this.currentTuning;
                return Math.round(exactStep) % this.currentTuning;
            }
            
            getMicrotonalNoteName(step, opts = {}) {
                // Base note letters
                const baseLetters = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
                
                // Unicode accidental symbols
                const accidentals = {
                    doubleFlat: '𝄫',      // -2 semitones
                    flat: '♭',            // -1 semitone
                    quarterFlat: '𝄳',     // -0.5 semitone (24EDO)
                    flatUp: '𝄬',          // slightly > -1 (31EDO, 22EDO)
                    flatDown: '𝄭',        // slightly < -1 (31EDO, 22EDO)
                    natural: '♮',         // 0 semitones (when needed for clarity)
                    naturalUp: '𝄮',       // slightly > 0 (31EDO, 22EDO)
                    naturalDown: '𝄯',     // slightly < 0 (31EDO, 22EDO)
                    quarterSharp: '𝄲',    // +0.5 semitone (24EDO)
                    sharp: '♯',           // +1 semitone
                    sharpUp: '𝄰',         // slightly > +1 (31EDO, 22EDO)
                    sharpDown: '𝄱',       // slightly < +1 (31EDO, 22EDO)
                    doubleSharp: '𝄪'      // +2 semitones
                };
                
                // Calculate cents and closest diatonic note
                const centsPerStep = 1200 / this.currentTuning;
                const totalCents = step * centsPerStep;
                
                // Map to closest diatonic note (C=0, D=2, E=4, F=5, G=7, A=9, B=11)
                const diatonicSteps = [0, 2, 4, 5, 7, 9, 11];
                const semitonePosition = totalCents / 100;
                
                // Find closest diatonic note
                let closestDiatonic = 0;
                let minDistance = Infinity;
                let diatonicIndex = 0;
                for (let i = 0; i < diatonicSteps.length; i++) {
                    const distance = Math.abs(semitonePosition - diatonicSteps[i]);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestDiatonic = diatonicSteps[i];
                        diatonicIndex = i;
                    }
                }

                // Optional preference: if caller prefers flats or sharps for enharmonic choices,
                // bias the diatonic anchor toward upper (flat) or lower (sharp) choice when not exact.
                const prefer = opts.preferAccidental;
                if (prefer === 'flat' || prefer === 'sharp') {
                    // Compute nearest lower and upper diatonic indices
                    let lowerIdx = 0, upperIdx = diatonicSteps.length - 1;
                    for (let i = 0; i < diatonicSteps.length; i++) {
                        if (diatonicSteps[i] <= semitonePosition) lowerIdx = i;
                        if (diatonicSteps[i] >= semitonePosition) { upperIdx = i; break; }
                    }
                    const isExact = diatonicSteps[lowerIdx] === semitonePosition || diatonicSteps[upperIdx] === semitonePosition;
                    if (!isExact) {
                        if (prefer === 'flat') {
                            diatonicIndex = upperIdx; // e.g., choose B then flat for 10 → Bb
                            closestDiatonic = diatonicSteps[diatonicIndex];
                        } else if (prefer === 'sharp') {
                            diatonicIndex = lowerIdx; // e.g., choose A then sharp for 10 → A#
                            closestDiatonic = diatonicSteps[diatonicIndex];
                        }
                    }
                }
                
                // Get base note letter
                let noteLetter = baseLetters[diatonicIndex];
                let accidental = '';
                let arrows = '';
                
                // Calculate deviation from closest diatonic note in cents
                const deviation = totalCents - (closestDiatonic * 100);
                
                // Apply EDO-specific accidental rules
                if (this.currentTuning === 12) {
                    // 12 EDO - standard notation
                    if (Math.abs(deviation) < 25) {
                        accidental = ''; // Natural
                    } else if (deviation >= 75) {
                        accidental = accidentals.sharp;
                    } else if (deviation <= -75) {
                        accidental = accidentals.flat;
                    }
                } else if (this.currentTuning === 24) {
                    // 24 EDO - quarter-tone system
                    if (Math.abs(deviation) < 12.5) {
                        accidental = ''; // Natural
                    } else if (deviation >= 37.5 && deviation < 62.5) {
                        accidental = accidentals.quarterSharp;
                    } else if (deviation >= 62.5) {
                        accidental = accidentals.sharp;
                    } else if (deviation <= -37.5 && deviation > -62.5) {
                        accidental = accidentals.quarterFlat;
                    } else if (deviation <= -62.5) {
                        accidental = accidentals.flat;
                    }
                } else if (this.currentTuning === 31 || this.currentTuning === 22) {
                    // 31 EDO or 22 EDO - fine-tuned accidentals
                    const threshold = 1200 / (this.currentTuning * 4); // Quarter of a step
                    
                    if (Math.abs(deviation) < threshold) {
                        accidental = ''; // Natural
                    } else if (deviation > 75 && deviation < 125) {
                        accidental = accidentals.sharpDown; // Sharp down
                    } else if (deviation >= 125) {
                        accidental = accidentals.sharp;
                    } else if (deviation < -75 && deviation > -125) {
                        accidental = accidentals.flatUp; // Flat up
                    } else if (deviation <= -125) {
                        accidental = accidentals.flat;
                    } else if (deviation > 0 && deviation <= 75) {
                        accidental = accidentals.naturalUp; // Natural up
                    } else if (deviation < 0 && deviation >= -75) {
                        accidental = accidentals.naturalDown; // Natural down
                    }
                } else {
                    // Higher resolution EDOs (>31) - use base accidentals + arrows
                    const stepSize = 1200 / this.currentTuning;
                    
                    // Determine base accidental
                    if (Math.abs(deviation) < stepSize / 4) {
                        accidental = ''; // Natural
                    } else if (deviation >= 87.5) {
                        accidental = accidentals.sharp;
                    } else if (deviation <= -87.5) {
                        accidental = accidentals.flat;
                    } else if (deviation > 37.5 && deviation < 87.5) {
                        accidental = accidentals.quarterSharp;
                    } else if (deviation < -37.5 && deviation > -87.5) {
                        accidental = accidentals.quarterFlat;
                    } else if (deviation > 0) {
                        accidental = accidentals.naturalUp;
                    } else {
                        accidental = accidentals.naturalDown;
                    }
                    
                    // Add ^ or v arrows for fine-tuning in high-resolution EDOs
                    const fineDeviation = Math.abs(deviation) % stepSize;
                    const arrowThreshold = stepSize / 8;
                    
                    if (fineDeviation > arrowThreshold && fineDeviation < stepSize - arrowThreshold) {
                        const numArrows = Math.floor(fineDeviation / arrowThreshold);
                        if (deviation > 0) {
                            arrows = '^'.repeat(Math.min(numArrows, 3));
                        } else {
                            arrows = 'v'.repeat(Math.min(numArrows, 3));
                        }
                    }
                }
                
                // Construct final note name: [Note][Accidental(s)][Arrows]
                let finalName = noteLetter + accidental + arrows;
                
                return finalName;
            }

            // Return a concise root name for a given EDO step, using:
            // - 12 EDO: standard sharps (C, C#, D, ...)
            // - 24 EDO: arrow notation for quarter steps relative to nearest even step (C, C^, C#, C#^, D, ...), wrapping so step 23 -> Cv
            // - other EDOs: fall back to rich getMicrotonalNoteName()
            getRootNameForStep(step, edo = (this.currentTuning || 12)) {
                const norm = (n, m) => ((n % m) + m) % m;
                const s = norm(step|0, edo|0 || 12);
                const sharpNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

                if (edo === 12) {
                    // Prefer b7 spelling in chord labels: show Bb instead of A# for semitone 10
                    const idx = s % 12;
                    if (idx === 10) return 'Bb';
                    return sharpNames[idx];
                }
                if (edo === 24) {
                    // Choose nearest even anchor (12-TET lattice), then append ^ for +1 or v for -1 quarter-step
                    let anchor = Math.round(s / 2) * 2; // 0..24
                    anchor = norm(anchor, 24);
                    let delta = s - anchor; // usually -1,0,+1 but handle wrap-around
                    if (delta > 12) delta -= 24;
                    if (delta < -12) delta += 24;
                    const semi = (anchor / 2) % 12;
                    const base = sharpNames[semi];
                    if (delta === 0) return base;
                    if (delta === 1) return base + '^';
                    if (delta === -1) return base + 'v';
                    // Fallback (shouldn't happen): compose from micro name
                    return this.getMicrotonalNoteName(s);
                }
                // Default: keep the richer musical symbols
                return this.getMicrotonalNoteName(s);
            }
            
            getDiatonicNoteColor(step) {
                // Color-code notes based on their relationship to diatonic scale
                const semitoneEquivalent = (step * 12) / this.currentTuning;
                const baseSemitone = Math.round(semitoneEquivalent) % 12;
                
                // Diatonic notes (C D E F G A B)
                if ([0, 2, 4, 5, 7, 9, 11].includes(baseSemitone)) {
                    return '#4a90e2'; // Blue for diatonic
                }
                // Neutral/microtonal
                if (Math.abs(semitoneEquivalent - Math.round(semitoneEquivalent)) > 0.3) {
                    return '#27ae60'; // Green for neutral
                }
                // Chromatic
                return '#e74c3c'; // Red for chromatic
            }
            
            getDiatonicNoteBorderColor(step) {
                const semitoneEquivalent = (step * 12) / this.currentTuning;
                const baseSemitone = Math.round(semitoneEquivalent) % 12;
                
                if ([0, 2, 4, 5, 7, 9, 11].includes(baseSemitone)) {
                    return '#6bb6ff'; // Lighter blue for diatonic
                }
                if (Math.abs(semitoneEquivalent - Math.round(semitoneEquivalent)) > 0.3) {
                    return '#2ecc71'; // Lighter green for neutral
                }
                return '#ff6b6b'; // Lighter red for chromatic
            }
            
            updateBuilderFavoritesDisplay() {
                const favoritesList = document.getElementById('chordBuilderFavoritesList');
                favoritesList.innerHTML = '';
                
                if (!this.favoriteChords || this.favoriteChords.length === 0) {
                    favoritesList.innerHTML = '<div style="color: #8fb3d3; font-style: italic; text-align: center; padding: 20px;">No favorite chords yet</div>';
                    return;
                }
                
                this.favoriteChords.forEach((chord, index) => {
                    const chordElement = document.createElement('div');
                    chordElement.className = 'favorite-chord-item';
                    chordElement.style.cssText = `
                        background: rgba(0, 30, 60, 0.6);
                        border: 1px solid #4a6870;
                        border-radius: 6px;
                        padding: 8px;
                        cursor: pointer;
                        transition: all 0.2s;
                        text-align: center;
                    `;
                    
                    chordElement.innerHTML = `
                        <div style="font-weight: bold; color: #f39c12;">${chord.name}</div>
                        <div style="font-size: 10px; opacity: 0.8;">${chord.intervals ? chord.intervals.join(' ') : 'Custom'}</div>
                        <div style="font-size: 8px; opacity: 0.6; margin-top: 4px;">Click to load</div>
                    `;
                    
                    chordElement.addEventListener('click', () => {
                        this.loadFavoriteIntoBuilder(chord);
                    });
                    
                    chordElement.addEventListener('mouseenter', () => {
                        chordElement.style.borderColor = '#8fb3d3';
                        chordElement.style.background = 'rgba(0, 40, 80, 0.8)';
                    });
                    
                    chordElement.addEventListener('mouseleave', () => {
                        chordElement.style.borderColor = '#4a6870';
                        chordElement.style.background = 'rgba(0, 30, 60, 0.6)';
                    });
                    
                    favoritesList.appendChild(chordElement);
                });
            }
            
            loadFavoriteIntoBuilder(favoriteChord) {
                // Load name
                document.getElementById('chordBuilderName').value = favoriteChord.name;
                
                // Load pattern
                if (favoriteChord.intervals) {
                    this.loadChordPatternIntoBuilder(favoriteChord.intervals);
                }
            }
            
            saveChordFromBuilder() {
                const name = document.getElementById('chordBuilderName').value.trim();
                const selectedIntervals = this.getSelectedChordIntervals();
                
                if (!name || selectedIntervals.length <= 1) {
                    alert('Please enter a chord name and select at least one interval beyond the root.');
                    return;
                }
                
                // Prefix the display name with current root (only if no root letter at start)
                const rootName = this.getMicrotonalNoteName(this.currentRoot || 0);
                const prefixedName = /^[A-G][#b]?/.test(name) ? name : `${rootName}${name}`;
                const newChord = {
                    name: prefixedName,
                    intervals: selectedIntervals,
                    isCustom: true,
                    id: Date.now(), // Unique ID
                    root: this.currentRoot || 0,
                    tuning: this.currentTuning || 12
                };
                
                if (this.currentEditingChord) {
                    // Update existing chord
                    this.updateExistingChord(newChord);
                } else {
                    // Use addChordColumn to automatically generate 3 chord qualities
                    this.addChordColumn(newChord);
                }
                
                // Custom chords are automatically added to extensions, no separate dropdown needed
                
                this.closeChordBuilder();
                
                console.log(`Saved custom chord: ${name} with auto-generated 3 qualities`);
            }
            
            getSelectedBuilderNotes() {
                // For backward compatibility, use the new checkbox system
                return this.getSelectedChordIntervals();
            }
            
            addBuilderChordToFavorites() {
                const name = document.getElementById('chordBuilderName').value.trim();
                const selectedNotes = this.getSelectedBuilderNotes();
                
                if (!name || selectedNotes.length === 0) {
                    alert('Please enter a chord name and select notes first.');
                    return;
                }
                
                const favoriteChord = {
                    name: name,
                    intervals: selectedNotes,
                    quality: this.currentQuality,
                    root: this.currentRoot,
                    tuning: this.currentTuning
                };
                
                // Check if already in favorites
                const exists = this.favoriteChords.some(fav => 
                    fav.name === favoriteChord.name && 
                    JSON.stringify(fav.intervals) === JSON.stringify(favoriteChord.intervals)
                );
                
                if (!exists) {
                    this.favoriteChords.push(favoriteChord);
                    // localStorage removed - no longer saving favorite chords
                    this.updateBuilderFavoritesDisplay();
                    alert(`Added "${favoriteChord.name}" to favorites!`);
                } else {
                    alert('This chord is already in your favorites.');
                }
            }
            
            previewBuilderChord() {
                const selectedNotes = this.getSelectedBuilderNotes();
                if (selectedNotes.length === 0) {
                    alert('Please select some notes first.');
                    return;
                }
                
                // Play the chord
                selectedNotes.forEach((interval, index) => {
                    setTimeout(() => {
                        const frequency = this.getFrequency(this.semitoneToEDOStep(interval), 4);
                        const mockElement = { classList: { add: () => {}, remove: () => {} } };
                        this.playFrequency(frequency, mockElement);
                        
                        // Stop after a short duration
                        setTimeout(() => {
                            this.stopFrequency(frequency, mockElement);
                        }, 1000);
                    }, index * 50); // Slight arpeggiation
                });
            }
            
            clearChordBuilder() {
                // Stop any active previews
                this.stopPreview();
                
                document.getElementById('chordBuilderName').value = '';
                
                // Uncheck all extension checkboxes
                document.querySelectorAll('#chordExtensionsCheckboxes input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                // Uncheck all microtonal checkboxes
                document.querySelectorAll('#microtonalCheckboxes input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                // Update preview
                this.updateChordPreview();
            }
            
            closeChordBuilder() {
                // Stop any active previews
                this.stopPreview();
                
                document.getElementById('chordBuilderModal').style.display = 'none';
                this.currentEditingChord = null;
                // Autosave on tap-out: if we were editing via selectedIntervals, commit in place
                if (this.isChordCreationMode && this.selectedIntervals && this.selectedIntervals.length > 1) {
                    const edo = this.currentTuning || 12;
                    const absSteps = this.selectedIntervals.map(iv => ((iv % edo) + edo) % edo);
                    const pendingName = this.computeFullChordNameFromAbsoluteSteps(absSteps, edo);
                    this.finalizePreviewChord(pendingName);
                }
                this.isChordCreationMode = false;
            }
            
            updateTuningSystem(divisions) {
                const previousTuning = this.currentTuning;
                this.currentTuning = divisions;
                this.gamelanMode = false;
                this.generateRootButtons();
                // Remap custom chords to nearest neighbors in new tuning
                try {
                    this.remapCustomChordsToNearestNeighbors(previousTuning, this.currentTuning);
                } catch (e) { console.warn('Remap skipped:', e); }
                // Update visible column headers to the new tuning preserving pitch/quality
                try {
                    this.relabelColumnsForNewTuning(previousTuning, this.currentTuning);
                } catch (e) { console.warn('Relabel skipped:', e); }
                this.preserveLockedChordsAndRegenerate();
                
                // Update note selector if chord builder is open
                if (document.getElementById('chordBuilderModal').style.display === 'block') {
                    this.populateChordBuilderNoteSelector();
                }
                
                // Auto-close the TUNING popup/panel after applying
                if (typeof this.closeBottomPanel === 'function') this.closeBottomPanel();
            }

            // Remap custom-chord intervals from an old EDO to the nearest neighbors in a new EDO
            remapCustomChordsToNearestNeighbors(fromEdo, toEdo) {
                if (!Array.isArray(this.chordExtensions) || !fromEdo || !toEdo || fromEdo === toEdo) return;
                // Helper: map a step value in fromEdo to nearest step in toEdo by preserving cents
                const mapStep = (step) => {
                    // Preserve pitch-class modulo octave while keeping absolute step differences minimal
                    // Convert to cents relative to octave and round to nearest destination step
                    const cents = (step / fromEdo) * 1200;
                    const mapped = Math.round((cents / 1200) * toEdo);
                    return ((mapped % toEdo) + toEdo) % toEdo;
                };
                this.chordExtensions = this.chordExtensions.map(ch => {
                    if (ch && ch.isCustom && Array.isArray(ch.intervals)) {
                        const mappedIntervals = ch.intervals.map(mapStep);
                        // Keep root at 0 explicitly
                        if (!mappedIntervals.includes(0)) mappedIntervals.unshift(0);
                        return {
                            ...ch,
                            intervals: [...new Set(mappedIntervals)].sort((a,b)=>a-b),
                            lastTuning: toEdo
                        };
                    }
                    return ch;
                });
            }

            // After changing EDO, relabel each unlocked column to keep root at 0 semantics and preserve quality
            relabelColumnsForNewTuning(fromEdo, toEdo) {
                const edo = toEdo || this.currentTuning || 12;
                document.querySelectorAll('.extension-column').forEach(col => {
                    const nameEl = col.querySelector('.extension-header .chord-name');
                    if (!nameEl) return;
                    // Detect locked state without relying on removed lock button
                    const isLocked = nameEl.dataset.isLocked === 'true';
                    if (isLocked) return; // leave locked headers as-is; pitch is preserved by snapshot

                    // Resolve chord model
                    let model = null;
                    try {
                        const id = col.dataset.chordId;
                        let idx = -1;
                        if (id) idx = (this.chordExtensions||[]).findIndex(c=> c && (String(c.id)===String(id)));
                        if (idx < 0 && col.dataset.originalPosition != null) {
                            const op = parseInt(col.dataset.originalPosition,10);
                            if (!isNaN(op) && op >= 0) idx = op;
                        }
                        if (idx >= 0) model = (this.chordExtensions||[])[idx];
                    } catch(_) {}

                    const label = (nameEl.dataset.lockedName || nameEl.textContent || '').trim();
                    // Parse root and any ^/v local transpose decorations
                    let baseStep = 0;
                    let arrowDelta = 0;
                    const m = label.match(/^([A-G])([#b]?)([\^v]*)/);
                    if (m) {
                        const semi = this.rootToSemitone(m[1], m[2]||'');
                        baseStep = this.semitoneToStep(semi, edo);
                        const ups = (m[3].match(/\^/g) || []).length;
                        const downs = (m[3].match(/v/g) || []).length;
                        arrowDelta = ups - downs;
                    }

                    // Build degree steps in new EDO
                    let degrees = [];
                    if (model && Array.isArray(model.intervals) && model.intervals.length) {
                        if (model.isCustom) {
                            // Custom intervals are already steps and were remapped above
                            degrees = model.intervals.slice();
                        } else {
                            // Map semitone intervals to new EDO steps
                            degrees = model.intervals.map(iv => this.mapIntervalToEDO(iv, edo));
                        }
                    } else {
                        // Fallback: try to infer a simple triad (Major by default)
                        degrees = [0, this.mapIntervalToEDO(4, edo), this.mapIntervalToEDO(7, edo)];
                    }
                    // Ensure root at 0 and dedupe/sort
                    degrees = Array.from(new Set([0, ...degrees.map(x=> ((x%edo)+edo)%edo)])).sort((a,b)=>a-b);

                    // Compose absolute steps with local arrows; global transpose is added inside naming
                    const rootStep = (((baseStep + arrowDelta) % edo) + edo) % edo;
                    const abs = [rootStep, ...degrees.filter(x=>x!==0).map(iv => (rootStep + iv) % edo)];
                    const labelNew = this.computeFullChordNameFromAbsoluteSteps(abs, edo) || label;

                    nameEl.textContent = labelNew;
                    nameEl.dataset.lockedName = labelNew;
                });
            }
            
            // Interval ratio support removed — EDO-only (5–52)
            
            addChordColumn(chordData) {
                // When adding a new chord, automatically create ONE Major, ONE Minor, ONE Neutral
                if (chordData.intervals && chordData.intervals.length > 0) {
                    // Auto-generate 3 qualities for the new chord with color gradients
                    this.autoGenerateChordQualities(chordData);
                } else {
                    // For standard chord extensions without specific intervals
                    this.chordExtensions.push(chordData);
                    this.saveChordConfiguration(); // Use consistent save method
                }
                
                // Regenerate the columns to show the new chord variations
                this.preserveLockedChordsAndRegenerate();
                
                console.log(`Added chord column: ${chordData.name} with auto-generated qualities`);
            }
            
            autoGenerateChordQualities(chordData) {
                // Automatically create Major, Minor, and Neutral variants with color gradients
                const qualities = [
                    { 
                        name: 'major', 
                        suffix: 'Maj', 
                        color: { bg: '#1e40af', border: '#3b82f6' }, // Blue for Major
                        intervals: chordData.intervals 
                    },
                    { 
                        name: 'minor', 
                        suffix: 'Min', 
                        color: { bg: '#dc2626', border: '#ef4444' }, // Red for Minor
                        intervals: this.convertToMinorIntervals(chordData.intervals)
                    },
                    { 
                        name: 'neutral', 
                        suffix: 'Neu', 
                        color: { bg: '#059669', border: '#10b981' }, // Green for Neutral
                        intervals: this.convertToNeutralIntervals(chordData.intervals)
                    }
                ];
                
        qualities.forEach(quality => {
                    const qualityChord = {
            name: `${chordData.name}${quality.suffix}`,
                        originalName: chordData.name,
                        intervals: quality.intervals,
                        quality: quality.name,
                        isCustom: true,
                        color: quality.color,
            baseIntervals: chordData.intervals,
            root: chordData.root ?? this.currentRoot ?? 0,
            tuning: chordData.tuning ?? this.currentTuning ?? 12
                    };
                    
                    // Add to chord extensions for the 3-column layout
                    this.chordExtensions.push(qualityChord);
                });
                
                // Save the updated chord extensions
                this.saveChordConfiguration(); // Use consistent save method
                
                console.log(`Auto-generated 3 qualities for: ${chordData.name}`);
            }
            
            convertToMinorIntervals(intervals) {
                // Convert major intervals to minor by flattening the third
                return intervals.map(interval => {
                    if (interval === 4) return 3; // Major 3rd to minor 3rd
                    if (interval === 11) return 10; // Major 7th to minor 7th
                    return interval;
                });
            }
            
            convertToNeutralIntervals(intervals) {
                // Convert intervals to neutral by using quarter-tones
                return intervals.map(interval => {
                    if (interval === 4) return 3.5; // Major 3rd to neutral 3rd
                    if (interval === 3) return 3.5; // Minor 3rd to neutral 3rd
                    if (interval === 11) return 10.5; // Major 7th to neutral 7th
                    if (interval === 10) return 10.5; // Minor 7th to neutral 7th
                    return interval;
                });
            }
            
            updateExistingChord(newChordData) {
                if (this.currentEditingChord.isCustom) {
                    const index = this.customChords.findIndex(c => c.id === this.currentEditingChord.id);
                    if (index !== -1) {
                        const prev = this.customChords[index] || {};
                        this.customChords[index] = { ...prev, ...newChordData, id: this.currentEditingChord.id, root: prev.root ?? this.currentRoot, tuning: prev.tuning ?? this.currentTuning };
                        // localStorage removed - no longer saving custom chords
                    }
                } else {
                    const index = this.chordExtensions.findIndex(c => c.name === this.currentEditingChord.name);
                    if (index !== -1) {
                        const prev = this.chordExtensions[index] || {};
                        this.chordExtensions[index] = { ...prev, ...newChordData, root: prev.root ?? this.currentRoot, tuning: prev.tuning ?? this.currentTuning };
                        this.saveChordConfiguration(); // Use consistent save method
                    }
                }
                
                this.preserveLockedChordsAndRegenerate();
                console.log(`Updated chord: ${newChordData.name}`);
            }

        async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.value = this.volume * this.masterVolume; // Apply both volume and master volume at start
                    
                    // Create simple reverb
                    this.createReverb();
                    
                    // Create wet/dry gain nodes for reverb
            this.wetGainNode = this.audioContext.createGain();
            this.dryGainNode = this.audioContext.createGain();
            // Clamp wet to [0,1] to avoid accidental mute
            const wet = Math.max(0, Math.min(1, Number.isFinite(this.reverb.wet) ? this.reverb.wet : 0.3));
            this.wetGainNode.gain.value = wet;
            this.dryGainNode.gain.value = 1.0 - wet;
                    
                    // Create reverb filter
                    this.reverbFilterNode = this.audioContext.createBiquadFilter();
                    this.reverbFilterNode.type = 'lowpass';
                    this.reverbFilterNode.frequency.value = Math.max(100, Math.min(20000, Number.isFinite(this.reverb.filterCutoff) ? this.reverb.filterCutoff : 8000));
                    this.reverbFilterNode.Q.value = 1;
                    
                    // Connect audio routing: gainNode ? dry/wet ? reverb ? destination
                    this.gainNode.connect(this.dryGainNode);
                    this.gainNode.connect(this.wetGainNode);
                    this.dryGainNode.connect(this.audioContext.destination);
                    this.wetGainNode.connect(this.reverbNode);
                    this.reverbNode.connect(this.reverbFilterNode);
                    this.reverbFilterNode.connect(this.audioContext.destination);

                    // Helper to bypass convolver when wet=0 to save CPU
                    this.updateReverbRouting = () => {
                        try {
                            const isWet = (this.reverb?.wet || 0) > 0.0001;
                            // Ensure base connections exist
                            if (!this.wetGainNode || !this.reverbNode || !this.reverbFilterNode) return;
                            // Disconnect all from wet chain first
                            try { this.wetGainNode.disconnect(); } catch {}
                            try { this.reverbNode.disconnect(); } catch {}
                            try { this.reverbFilterNode.disconnect(); } catch {}
                            if (isWet) {
                                // Enable wet path
                                this.wetGainNode.connect(this.reverbNode);
                                this.reverbNode.connect(this.reverbFilterNode);
                                this.reverbFilterNode.connect(this.audioContext.destination);
                            } else {
                                // Keep wetGainNode disconnected when wet=0
                                // Dry path already connected
                            }
                        } catch {}
                    };
                    // Apply initial routing state
                    this.updateReverbRouting();
                    
                    // Store the initial clean state for piano lock system
                    this.storeOriginalUIState();
                    console.log('🎹 Stored original UI state for piano lock system');
                } catch (error) {
                    console.error('Audio initialization failed:', error);
                }
            }

            // Ensure AudioContext exists and is running before attempting playback
        async ensureAudioContext() {
                try {
                    if (!this.audioContext) await this.initAudio();
                    if (!this.audioContext) return false;
                    if (this.audioContext.state === 'suspended') {
                        try {
                            await this.audioContext.resume();
                            console.log('AudioContext resumed');
                        } catch (e) {
                            console.warn('Failed to resume AudioContext:', e);
                            return false;
                        }
                    }
                    return this.audioContext.state === 'running';
                } catch (e) {
                    console.warn('ensureAudioContext error:', e);
                    return false;
                }
            }

            createReverb() {
                const convolver = this.audioContext.createConvolver();
                // Ensure a non-zero impulse length to avoid AudioBuffer errors when decay is 0
                const decaySec = Math.max(0.01, Number.isFinite(this.reverb.decay) ? this.reverb.decay : 0.3);
                const length = Math.max(1, Math.floor(this.audioContext.sampleRate * decaySec));
                const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const n = length - i;
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(n / length, this.reverb.roomSize);
                    }
                }
                
                convolver.buffer = impulse;
                this.reverbNode = convolver;
            }

            createNoiseSource() {
                const bufferSize = this.audioContext.sampleRate * 1; // 1 second of noise
                const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1; // White noise
                }
                
                const whiteNoise = this.audioContext.createBufferSource();
                whiteNoise.buffer = noiseBuffer;
                whiteNoise.loop = true;
                
                return whiteNoise;
            }

            // Build or fetch a cached PeriodicWave for custom oscillator shapes.
            // type: 'pulse' | 'fullrect' | 'halfrect' | 'trapezoid' | 'parabolic' | 'stair'
            // pulseWidth: only applies to 'pulse' (0..1), default 0.5
            getCustomPeriodicWave(type, pulseWidth = 0.5) {
                if (!this.audioContext) return null;
                const key = `${type}:${type === 'pulse' ? Math.max(0.01, Math.min(0.99, pulseWidth || 0.5)).toFixed(3) : 'std'}`;
                if (this._customWaveCache.has(key)) return this._customWaveCache.get(key);

                let real = null, imag = null;
                const N = 64; // number of harmonics to include

                switch (type) {
                    case 'pulse': {
                        const d = Math.max(0.01, Math.min(0.99, pulseWidth));
                        real = new Float32Array(N + 1);
                        imag = new Float32Array(N + 1);
                        real[0] = 0;
                        for (let n = 1; n <= N; n++) {
                            // Duty-cycle pulse: sine-only series, scaled by sin(n*pi*d)
                            const bn = (4 / (n * Math.PI)) * Math.sin(n * Math.PI * d);
                            imag[n] = bn;
                            real[n] = 0;
                        }
                        break;
                    }
                    case 'fullrect': {
                        // |sin| -> even harmonics cosine series
                        real = new Float32Array(N + 1);
                        imag = new Float32Array(N + 1);
                        for (let k = 1; k <= N / 2; k++) {
                            const n = 2 * k;
                            const a = -4 / (Math.PI * (4 * k * k - 1));
                            real[n] = a;
                            imag[n] = 0;
                        }
                        break;
                    }
                    case 'parabolic': {
                        // Curved saw-like; cosine series decaying as 1/n^2 with alternating sign
                        real = new Float32Array(N + 1);
                        imag = new Float32Array(N + 1);
                        for (let n = 1; n <= N; n++) {
                            real[n] = (n % 2 === 0 ? 1 : -1) * (1 / (n * n));
                            imag[n] = 0;
                        }
                        break;
                    }
                    case 'halfrect': {
                        // Half-wave rectified sine: better built via sampling then DFT
                        return this._buildSampledPeriodicWave(x => Math.max(0, Math.sin(x)) * 2 - 1, key);
                    }
                    case 'trapezoid': {
                        const slope = 0.2; // ramp fraction
                        return this._buildSampledPeriodicWave(x => {
                            const t = ((x / (2 * Math.PI)) % 1 + 1) % 1;
                            let y;
                            if (t < slope) y = t / slope; // rise 0..1
                            else if (t < 0.5 - slope) y = 1; // high
                            else if (t < 0.5 + slope) y = 1 - (t - (0.5 - slope)) / (2 * slope); // fall
                            else if (t < 1 - slope) y = 0; // low
                            else y = (t - (1 - slope)) / slope; // rise to wrap
                            return y * 2 - 1;
                        }, key);
                    }
                    case 'stair': {
                        const steps = 8;
                        return this._buildSampledPeriodicWave(x => {
                            const t = ((x / (2 * Math.PI)) % 1 + 1) % 1;
                            const s = Math.floor(t * steps) / (steps - 1);
                            return s * 2 - 1;
                        }, key);
                    }
                    default: {
                        // Fallback to a mild saw series
                        real = new Float32Array(N + 1);
                        imag = new Float32Array(N + 1);
                        real[0] = 0;
                        for (let n = 1; n <= N; n++) {
                            imag[n] = -1 / n;
                        }
                    }
                }

                let wave = null;
                if (real && imag) {
                    try {
                        wave = this.audioContext.createPeriodicWave(real, imag, { disableNormalization: false });
                    } catch(_) {
                        // Older browsers don't support the options arg
                        wave = this.audioContext.createPeriodicWave(real, imag);
                    }
                }
                if (wave) this._customWaveCache.set(key, wave);
                return wave;
            }

            // Build a PeriodicWave from a sampled function using a naive DFT for first N harmonics
            _buildSampledPeriodicWave(sampleFn, cacheKey) {
                const S = 1024; // samples per period
                const samples = new Float32Array(S);
                for (let i = 0; i < S; i++) {
                    const x = (i / S) * 2 * Math.PI;
                    samples[i] = sampleFn(x);
                }
                // Remove DC offset
                let dc = 0;
                for (let i = 0; i < S; i++) dc += samples[i];
                dc /= S;
                for (let i = 0; i < S; i++) samples[i] -= dc;

                const N = 64;
                const real = new Float32Array(N + 1);
                const imag = new Float32Array(N + 1);
                real[0] = 0; imag[0] = 0;
                for (let n = 1; n <= N; n++) {
                    let a = 0, b = 0;
                    for (let i = 0; i < S; i++) {
                        const x = (i / S) * 2 * Math.PI;
                        const y = samples[i];
                        a += y * Math.cos(n * x);
                        b += y * Math.sin(n * x);
                    }
                    a = (2 / S) * a;
                    b = (2 / S) * b;
                    real[n] = a;
                    imag[n] = b;
                }
                let wave;
                try {
                    wave = this.audioContext.createPeriodicWave(real, imag, { disableNormalization: false });
                } catch(_) {
                    wave = this.audioContext.createPeriodicWave(real, imag);
                }
                this._customWaveCache.set(cacheKey, wave);
                return wave;
            }

            initEventListeners() {
                // Tuning system selection
                document.querySelectorAll('[data-tuning]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-tuning]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        const tuningValue = btn.dataset.tuning;
                        if (tuningValue === 'gamelan') {
                            // Gamelan pelog scale (7 notes)
                            this.currentTuning = 7;
                            this.gamelanMode = true;
                        } else {
                            this.currentTuning = parseInt(tuningValue);
                            this.gamelanMode = false;
                        }
                        
                        this.generateRootButtons();
                        this.preserveLockedChordsAndRegenerate();
                        this.updateChordDisplay();
                    });
                });

                // Quality selection
                document.querySelectorAll('[data-quality]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-quality]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentQuality = btn.dataset.quality;
                        this.preserveLockedChordsAndRegenerate();
                        this.updateChordDisplay();
                    });
                });

                // Removed standalone volumeSlider (merged into master volume UI)

                // ADSR controls with value displays and proper limits
                const attackSlider = document.getElementById('attackSlider');
                if (attackSlider) {
                    attackSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        this.envelope.attack = Math.max(0.003, e.target.value / 1000); // 3ms minimum
                        console.log('?? Attack changed to:', this.envelope.attack);
                        const attackValue = document.getElementById('attackValue');
                        if (attackValue) {
                            attackValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('attackSlider not found');
                }
                
                const decaySlider = document.getElementById('decaySlider');
                if (decaySlider) {
                    decaySlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        // 0–1000ms → 0–1s
                        const ms = Math.max(0, parseInt(e.target.value, 10) || 0);
                        this.envelope.decay = ms / 1000;
                        const decayValue = document.getElementById('decayValue');
                        if (decayValue) decayValue.textContent = `${ms}ms`;
                    });
                } else {
                    console.error('decaySlider not found');
                }
                
                const sustainSlider = document.getElementById('sustainSlider');
                if (sustainSlider) {
                    sustainSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        // 1–100% → 0.01–1.0 level
                        const pct = Math.min(100, Math.max(1, parseInt(e.target.value, 10) || 1));
                        this.envelope.sustain = pct / 100;
                        const sustainValue = document.getElementById('sustainValue');
                        if (sustainValue) sustainValue.textContent = `${pct}%`;
                    });
                } else {
                    console.error('sustainSlider not found');
                }
                
                const releaseSlider = document.getElementById('releaseSlider');
                if (releaseSlider) {
                    releaseSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        // Clamp to 0–1000ms => 0–1.0s
                        const ms = Math.max(0, Math.min(1000, parseInt(e.target.value, 10) || 0));
                        this.envelope.release = ms / 1000;
                        const releaseValue = document.getElementById('releaseValue');
                        if (releaseValue) {
                            releaseValue.textContent = `${ms}ms`;
                        }
                    });
                } else {
                    console.error('releaseSlider not found');
                }

                // Master Volume control with dB conversion
                const masterVolumeSlider = document.getElementById('masterVolume');
                if (masterVolumeSlider) {
                    masterVolumeSlider.addEventListener('input', (e) => {
                        // Convert 0-10 scale to 0dB to -3dB (linear from 0 to 0.9)
                        const sliderValue = e.target.value / 10; // 0-1
                        this.masterVolume = sliderValue * 0.9; // Max at -3dB (0.9 linear gain)
                        if (this.gainNode) {
                            this.gainNode.gain.value = this.volume * this.masterVolume;
                        }
                        const masterVolumeValue = document.getElementById('masterVolumeValue');
                        if (masterVolumeValue) {
                            masterVolumeValue.textContent = `${e.target.value * 10}%`;
                        }
                    });
                } else {
                    console.error('masterVolumeSlider not found');
                }

                // Voicing mode selector (split vs compact)
                const voicingSpanMode = document.getElementById('voicingSpanMode');
                if (voicingSpanMode) {
                    // Sync initial UI with current flag
                    voicingSpanMode.value = this.splitExtendedChordsAcrossOctaves ? 'split-two' : 'compact-one';
                    voicingSpanMode.addEventListener('change', (e) => {
                        const mode = e.target.value;
                        this.splitExtendedChordsAcrossOctaves = (mode === 'split-two');
                        // Regenerate current columns to reflect mode
                        if (typeof this.generateExtensionColumns === 'function') {
                            this.generateExtensionColumns();
                        }
                    });
                }

                // OSC 2 ADSR controls
                const osc2AttackSlider = document.getElementById('osc2AttackSlider');
                if (osc2AttackSlider) {
                    osc2AttackSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        this.osc2Envelope.attack = Math.max(0.003, e.target.value / 1000); // 3ms minimum
                        const osc2AttackValue = document.getElementById('osc2AttackValue');
                        if (osc2AttackValue) {
                            osc2AttackValue.textContent = `${e.target.value}ms`;
                        }
                    });
                } else {
                    console.error('osc2AttackSlider not found');
                }
                
                const osc2DecaySlider = document.getElementById('osc2DecaySlider');
                if (osc2DecaySlider) {
                    osc2DecaySlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        const ms = Math.max(0, parseInt(e.target.value, 10) || 0);
                        this.osc2Envelope.decay = ms / 1000;
                        const osc2DecayValue = document.getElementById('osc2DecayValue');
                        if (osc2DecayValue) osc2DecayValue.textContent = `${ms}ms`;
                    });
                } else {
                    console.error('osc2DecaySlider not found');
                }
                
                const osc2SustainSlider = document.getElementById('osc2SustainSlider');
                if (osc2SustainSlider) {
                    osc2SustainSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        const pct = Math.min(100, Math.max(1, parseInt(e.target.value, 10) || 1));
                        this.osc2Envelope.sustain = pct / 100;
                        const osc2SustainValue = document.getElementById('osc2SustainValue');
                        if (osc2SustainValue) osc2SustainValue.textContent = `${pct}%`;
                    });
                } else {
                    console.error('osc2SustainSlider not found');
                }
                
                const osc2ReleaseSlider = document.getElementById('osc2ReleaseSlider');
                if (osc2ReleaseSlider) {
                    osc2ReleaseSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        // Clamp to 0–1000ms => 0–1.0s
                        const ms = Math.max(0, Math.min(1000, parseInt(e.target.value, 10) || 0));
                        this.osc2Envelope.release = ms / 1000;
                        const osc2ReleaseValue = document.getElementById('osc2ReleaseValue');
                        if (osc2ReleaseValue) {
                            osc2ReleaseValue.textContent = `${ms}ms`;
                        }
                    });
                } else {
                    console.error('osc2ReleaseSlider not found');
                }

                // Oscillator controls
                document.querySelectorAll('.osc-btn[data-wave]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        const osc = btn.dataset.osc;
                        const wave = btn.dataset.wave;
                        
                        // Update active state
                        document.querySelectorAll(`[data-osc="${osc}"]`).forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        // Set type and toggle pulse width slider
                        this.oscillators[`osc${osc}`].type = wave;
                        const pwContainer = document.querySelector(`.pulse-width-container[data-osc="${osc}"]`);
                        if (pwContainer) {
                            pwContainer.style.display = (wave === 'pulse') ? 'block' : 'none';
                        }
                    });
                });

                // Oscillator detune and level controls
                ['1', '2'].forEach(num => {
                    // Pulse width slider
                    const pwSlider = document.getElementById(`osc${num}PulseWidth`);
                    if (pwSlider) {
                        pwSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            const pct = Math.min(95, Math.max(5, parseInt(e.target.value, 10) || 50));
                            this.oscillators[`osc${num}`].pulseWidth = pct / 100;
                            const v = document.getElementById(`osc${num}PulseWidthValue`);
                            if (v) v.textContent = `${pct}%`;
                        });
                    }

                    const detuneSlider = document.getElementById(`osc${num}Detune`);
                    if (detuneSlider) {
                        detuneSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            this.oscillators[`osc${num}`].detune = parseInt(e.target.value);
                            const detuneValue = document.getElementById(`osc${num}DetuneValue`);
                            if (detuneValue) {
                                detuneValue.textContent = `${e.target.value}¢`;
                            }
                        });
                    } else {
                        console.error(`osc${num}Detune not found`);
                    }
                    
                    const levelSlider = document.getElementById(`osc${num}Level`);
                    if (levelSlider) {
                        levelSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            // Convert 0-10 scale to -18dB to 0dB (linear from 0.125 to 1.0)
                            const sliderValue = e.target.value / 10; // 0-1
                            this.oscillators[`osc${num}`].level = sliderValue * 0.125; // Max at -18dB
                            const levelValue = document.getElementById(`osc${num}LevelValue`);
                            if (levelValue) {
                                levelValue.textContent = `${e.target.value * 10}%`;
                            }
                        });
                    } else {
                        console.error(`osc${num}Level not found`);
                    }
                });

                // Oscillator octave and coarse controls
                ['1', '2'].forEach(num => {
                    const octaveSlider = document.getElementById(`osc${num}Octave`);
                    if (octaveSlider) {
                        octaveSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            this.oscillators[`osc${num}`].octave = parseInt(e.target.value);
                            const octaveValue = document.getElementById(`osc${num}OctaveValue`);
                            if (octaveValue) {
                                octaveValue.textContent = e.target.value;
                            }
                        });
                    } else {
                        console.error(`osc${num}Octave not found`);
                    }
                    
                    const coarseSlider = document.getElementById(`osc${num}Coarse`);
                    if (coarseSlider) {
                        coarseSlider.addEventListener('input', (e) => {
                            if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                            this.oscillators[`osc${num}`].coarse = parseInt(e.target.value);
                            const coarseValue = document.getElementById(`osc${num}CoarseValue`);
                            if (coarseValue) {
                                coarseValue.textContent = `${e.target.value} steps`;
                            }
                        });
                    } else {
                        console.error(`osc${num}Coarse not found`);
                    }
                });

                // Mix mode removed - oscillators will now simply add together

                // Reverb controls
                const reverbWetSlider = document.getElementById('reverbWet');
                if (reverbWetSlider) {
                    reverbWetSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        this.reverb.wet = e.target.value / 10; // 0-10 scale to 0-1
                        if (this.wetGainNode && this.dryGainNode) {
                            this.wetGainNode.gain.value = this.reverb.wet;
                            this.dryGainNode.gain.value = 1.0 - this.reverb.wet;
                        }
                        // Bypass reverb processing when wet=0%
                        if (typeof this.updateReverbRouting === 'function') this.updateReverbRouting();
                        const reverbWetValue = document.getElementById('reverbWetValue');
                        if (reverbWetValue) {
                            reverbWetValue.textContent = `${e.target.value * 10}%`;
                        }
                    });
                } else {
                    console.error('reverbWet slider not found');
                }

                const reverbRoomSlider = document.getElementById('reverbRoom');
                if (reverbRoomSlider) {
                    reverbRoomSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        this.reverb.roomSize = e.target.value / 10; // 0-10 scale to 0-1
                        const reverbRoomValue = document.getElementById('reverbRoomValue');
                        if (reverbRoomValue) {
                            reverbRoomValue.textContent = `${e.target.value * 10}%`;
                        }
                        // Recreate reverb with new room size
                        if (this.audioContext) {
                            this.createReverb();
                            // Properly reconnect the reverb chain
                            try { this.wetGainNode.disconnect(); } catch {}
                            try { this.reverbFilterNode.disconnect(); } catch {}
                            this.wetGainNode.connect(this.reverbNode);
                            this.reverbNode.connect(this.reverbFilterNode);
                            this.reverbFilterNode.connect(this.audioContext.destination);
                            if (typeof this.updateReverbRouting === 'function') this.updateReverbRouting();
                        }
                    });
                } else {
                    console.error('reverbRoom slider not found');
                }
                
                const reverbDecaySlider = document.getElementById('reverbDecay');
                if (reverbDecaySlider) {
                    reverbDecaySlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        this.reverb.decay = (e.target.value / 100) * 10; // 0-10 seconds
                        const reverbDecayValue = document.getElementById('reverbDecayValue');
                        if (reverbDecayValue) {
                            reverbDecayValue.textContent = `${(this.reverb.decay).toFixed(1)}s`;
                        }
                        // Recreate reverb with new decay time
                        if (this.audioContext) {
                            this.createReverb();
                            // Properly reconnect the reverb chain
                            try { this.wetGainNode.disconnect(); } catch {}
                            try { this.reverbFilterNode.disconnect(); } catch {}
                            this.wetGainNode.connect(this.reverbNode);
                            this.reverbNode.connect(this.reverbFilterNode);
                            this.reverbFilterNode.connect(this.audioContext.destination);
                            if (typeof this.updateReverbRouting === 'function') this.updateReverbRouting();
                        }
                    });
                } else {
                    console.error('reverbDecay slider not found');
                }
                
                const reverbFilterCutoffSlider = document.getElementById('reverbFilterCutoff');
                if (reverbFilterCutoffSlider) {
                    reverbFilterCutoffSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        this.reverb.filterCutoff = parseInt(e.target.value);
                        if (this.reverbFilterNode) {
                            this.reverbFilterNode.frequency.value = this.reverb.filterCutoff;
                        }
                        const reverbFilterCutoffValue = document.getElementById('reverbFilterCutoffValue');
                        if (reverbFilterCutoffValue) {
                            reverbFilterCutoffValue.textContent = `${e.target.value}Hz`;
                        }
                    });
                } else {
                    console.error('reverbFilterCutoff slider not found');
                }

                const reverbFilterResSlider = document.getElementById('reverbFilterRes');
                if (reverbFilterResSlider) {
                    reverbFilterResSlider.addEventListener('input', (e) => {
                        if (this.reverbFilterNode) {
                            this.reverbFilterNode.Q.value = parseFloat(e.target.value);
                        }
                        const reverbFilterResValue = document.getElementById('reverbFilterResValue');
                        if (reverbFilterResValue) {
                            reverbFilterResValue.textContent = e.target.value;
                        }
                    });
                }
                // Note: reverbFilterRes slider not present in current UI

                // Panning controls
                const panningModeSelect = document.getElementById('panningMode');
                if (panningModeSelect) {
                    panningModeSelect.addEventListener('change', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        if (window.omnichord && window.omnichord.panning) {
                            window.omnichord.panning.mode = e.target.value;
                            console.log('?? Panning mode changed to:', window.omnichord.panning.mode);
                        } else {
                            console.error('?? omnichord instance or panning not available');
                        }
                    });
                } else {
                    console.error('panningMode select not found');
                }

                const panningWidthSlider = document.getElementById('panningWidth');
                if (panningWidthSlider) {
                    panningWidthSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        if (window.omnichord && window.omnichord.panning) {
                            window.omnichord.panning.width = e.target.value / 100; // 0-100% to 0-1
                            console.log('?? Panning width changed to:', window.omnichord.panning.width);
                            const panningWidthValue = document.getElementById('panningWidthValue');
                            if (panningWidthValue) {
                                panningWidthValue.textContent = `${e.target.value}%`;
                            }
                        } else {
                            console.error('?? omnichord instance or panning not available');
                        }
                    });
                } else {
                    console.error('panningWidth slider not found');
                }

                const panningSpeedSlider = document.getElementById('panningSpeed');
                if (panningSpeedSlider) {
                    panningSpeedSlider.addEventListener('input', (e) => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        if (window.omnichord && window.omnichord.panning) {
                            window.omnichord.panning.speed = parseInt(e.target.value);
                            console.log('?? Panning speed changed to:', window.omnichord.panning.speed);
                            const panningSpeedValue = document.getElementById('panningSpeedValue');
                            if (panningSpeedValue) {
                                panningSpeedValue.textContent = `${(e.target.value / 1000).toFixed(1)}s`;
                            }
                        } else {
                            console.error('?? omnichord instance or panning not available');
                        }
                    });
                } else {
                    console.error('panningSpeed slider not found');
                }

                const panningResetBtn = document.getElementById('panningReset');
                if (panningResetBtn) {
                    panningResetBtn.addEventListener('click', () => {
                        if (this.isActiveChordPianoLocked && this.isActiveChordPianoLocked()) { this.flashPianoLockFeedback && this.flashPianoLockFeedback(); return; }
                        if (window.omnichord && window.omnichord.panning) {
                            window.omnichord.panning.rotationAngle = 0;
                            window.omnichord.panning.alternateState = false;
                            console.log('?? Panning reset');
                        } else {
                            console.error('?? omnichord instance or panning not available');
                        }
                    });
                } else {
                    console.error('panningReset button not found');
                }

                // Enhanced string playing with ultra responsiveness (60 FPS optimized)
                const extensionColumns = document.getElementById('extensionColumns');
                
                // Mouse events for strings with optimized performance
                extensionColumns.addEventListener('mousedown', (e) => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    this.isPlayingStrings = true;
                    this.triggeredStrings.clear();
                    // Disarm edit during active strum
                    this.editArmed = false;
                    clearTimeout(this._editArmTimer);
                    this.handleStringTrigger(e);
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isPlayingStrings) {
                        this.handleStringTrigger(e);
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    this.isPlayingStrings = false;
                    this.triggeredStrings.clear();
                    this.stopAllActiveNotes();
                    // Re-arm editing 500ms after strum ends
                    this._scheduleEditArm();
                });

                // Touch events for strings
                extensionColumns.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    this.isPlayingStrings = true;
                    this.triggeredStrings.clear();
                    this.editArmed = false;
                    clearTimeout(this._editArmTimer);
                    
                    Array.from(e.changedTouches).forEach(touch => {
                        this.activeTouches.set(touch.identifier, touch);
                        this.handleStringTrigger(touch);
                    });
                }, { passive: false });
                
                extensionColumns.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.isPlayingStrings) {
                        Array.from(e.changedTouches).forEach(touch => {
                            this.activeTouches.set(touch.identifier, touch);
                            this.handleStringTrigger(touch);
                        });
                    }
                }, { passive: false });
                
        extensionColumns.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    Array.from(e.changedTouches).forEach(touch => {
                        this.activeTouches.delete(touch.identifier);
                    });
                    
                    if (this.activeTouches.size === 0) {
                        this.isPlayingStrings = false;
                        this.triggeredStrings.clear();
                        this.stopAllActiveNotes();
            this._scheduleEditArm();
                    }
                }, { passive: false });
                
        extensionColumns.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    Array.from(e.changedTouches).forEach(touch => {
                        this.activeTouches.delete(touch.identifier);
                    });
                    
                    if (this.activeTouches.size === 0) {
                        this.isPlayingStrings = false;
                        this.triggeredStrings.clear();
                        this.stopAllActiveNotes();
            this._scheduleEditArm();
                    }
                }, { passive: false });

                // Allow multitouch on control elements - prevent default only on strings
                document.addEventListener('touchstart', (e) => {
                    const target = e.target;
                    if (target.classList.contains('tuning-btn') || 
                        target.classList.contains('chord-btn') || 
                        target.classList.contains('quality-btn') || 
                        target.classList.contains('osc-btn')) {
                        // Don't prevent default on control buttons to allow multitouch
                        return;
                    }
                }, { passive: false });

                // Handle audio context resume on any interaction
                document.addEventListener('click', () => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        console.log('Attempting to resume AudioContext on click...');
                        this.audioContext.resume().then(() => {
                            console.log('AudioContext resumed successfully');
                        });
                    }
                });
                
                document.addEventListener('touchstart', () => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        console.log('Attempting to resume AudioContext on touch...');
                        this.audioContext.resume().then(() => {
                            console.log('AudioContext resumed successfully');
                        });
                    }
                });
                
                document.addEventListener('mousedown', () => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        console.log('Attempting to resume AudioContext on mousedown...');
                        this.audioContext.resume().then(() => {
                            console.log('AudioContext resumed successfully');
                        });
                    }
                });

                // Modal Event Listeners
                const closeColumnModalBtn = document.getElementById('closeColumnModal');
                const addCustomColumnBtn = document.getElementById('addCustomColumn');

                if (closeColumnModalBtn) {
                    closeColumnModalBtn.addEventListener('click', () => {
                        document.getElementById('columnModal').style.display = 'none';
                    });
                }

                if (addCustomColumnBtn) {
                    addCustomColumnBtn.addEventListener('click', () => {
                        document.getElementById('columnModal').style.display = 'none';
                        this.showChordBuilder();
                    });
                }

                // Add to favorites button
                const addToFavoritesBtn = document.getElementById('addToFavoritesBtn');
                if (addToFavoritesBtn) {
                    addToFavoritesBtn.addEventListener('click', () => {
                        this.addCurrentChordToFavorites();
                    });
                }

                // Initialize custom chords storage - no localStorage
                this.customChords = [];
                
                // Migrate old custom chords from 12-TET semitones to native tuning
                this.migrateCustomChords();
                
                this.hiddenColumns = [];
                this.favoriteChords = [];
                this.paletteChords = [];
                this.currentEditingColumn = null;
                
                // Set up context menu
                // Context menu setup removed for clean interface
                
                // Set up fretboard resize functionality
                this.setupFretboardResize();
                
                // Set up sonic chord functionality
                this.setupSonicChords();
                
                // Force initial generation
                console.log('Initializing omnichord with tuning:', this.currentTuning);
                setTimeout(() => {
                    this.generateRootButtons();
                    this.generateExtensionColumns();
                }, 100);
            }

            migrateCustomChords() {
                // Migrate old custom chords that used 12-TET semitones to native tuning
                let needsMigration = false;
                
                this.customChords.forEach(chord => {
                    // Check if this chord needs migration (has intervals property instead of notes)
                    if (chord.intervals && !chord.notes) {
                        // Convert from 12-TET semitones to native tuning
                        const originalTuning = this.currentTuning;
                        this.currentTuning = chord.tuning || 12;
                        
                        chord.notes = chord.intervals.map(semitone => {
                            // For chords saved in their original tuning, just use the intervals directly
                            return semitone;
                        });
                        
                        // Remove old intervals property
                        delete chord.intervals;
                        this.currentTuning = originalTuning;
                        needsMigration = true;
                        console.log(`Migrated custom chord: ${chord.name}`);
                    } else if (!chord.notes && chord.intervals) {
                        // Fallback: copy intervals to notes if notes missing
                        chord.notes = [...chord.intervals];
                        needsMigration = true;
                    }
                });
                
                if (needsMigration) {
                    // localStorage removed - no longer saving custom chords
                    console.log('Custom chords migrated to new format');
                }
            }

            // Context menu functionality removed for clean interface
            setupContextMenu() {
                console.log('🎵 Context menus disabled for cleaner interface');
                
                // Setup keyboard input only
                this.setupKeyboardInput();
            }
            
            setupKeyboardInput() {
                document.addEventListener('keydown', (e) => {
                    // Only handle number keys 1-0 and only if not typing in an input field
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        return; // Don't interfere with text input
                    }
                    
                    const key = e.key;
                    let chordIndex = -1;
                    
                    // Map number keys to chord indices (1-9, then 0 for 10th chord)
                    if (key >= '1' && key <= '9') {
                        chordIndex = parseInt(key) - 1; // 1 -> 0, 2 -> 1, etc.
                    } else if (key === '0') {
                        chordIndex = 9; // 0 -> 9 (10th chord)
                    }
                    
                    if (chordIndex >= 0) {
                        e.preventDefault();
                        this.playChordByIndex(chordIndex);
                    }
                });
            }
            
            playChordByIndex(index) {
                // First try to play from palette chords
                if (this.paletteChords && index < this.paletteChords.length) {
                    const chord = this.paletteChords[index];
                    console.log(`Playing palette chord ${index + 1}:`, chord.name);
                    this.playPaletteChord(chord);
                    return;
                }
                
                // If no palette chord at that index, try to play from extension columns
                const columns = document.querySelectorAll('.extension-column');
                if (index < columns.length) {
                    const column = columns[index];
                    const header = column.querySelector('.extension-header');
                    if (header) {
                        console.log(`Playing extension chord ${index + 1}:`, header.textContent);
                        // Simulate a click on the column to play the chord
                        const rect = column.getBoundingClientRect();
                        const centerY = rect.top + rect.height / 2;
                        this.playChordStrum(column, { name: header.textContent }, centerY - 10, centerY + 10);
                    }
                } else {
                    console.log(`No chord available at index ${index + 1}`);
                }
            }

            setupTouchGestures() {
                // Add touch gesture support to all chord elements
                this.addTouchGesturesToElements();
                
                // Re-apply gestures when DOM changes (for dynamically added elements)
                const observer = new MutationObserver(() => {
                    this.addTouchGesturesToElements();
                });
                
                observer.observe(document.getElementById('extensionColumns'), {
                    childList: true,
                    subtree: true
                });
            }
            
            addTouchGesturesToElements() {
                // Add gestures to chord buttons in extension columns
                document.querySelectorAll('.chord-btn').forEach(btn => {
                    this.addTouchGestureToElement(btn, 'chord');
                    this.addClickGestureToElement(btn, 'chord');
                });
                
                // SKIP extension headers - they're handled by addSimpleClickHandlers() for chord name context menu
                console.log('Skipping extension headers - handled by addSimpleClickHandlers for chord name context menu');
                
                // SKIP extension columns too - let the headers handle all interactions to avoid conflicts
                console.log('Skipping extension columns - headers handle all interactions to avoid conflicts');
                
                // Add gestures to palette chords
                document.querySelectorAll('.palette-chord').forEach(chord => {
                    this.addTouchGestureToElement(chord, 'palette');
                    this.addClickGestureToElement(chord, 'palette');
                });
                
                // Add gestures to root chord buttons
                document.querySelectorAll('.root-btn').forEach(btn => {
                    this.addTouchGestureToElement(btn, 'root');
                    this.addClickGestureToElement(btn, 'root');
                });
            }
            
            addTouchGestureToElement(element, type) {
                // Prevent duplicate listeners
                if (element.dataset.touchGestureAdded) return;
                element.dataset.touchGestureAdded = 'true';
                
                let touchData = {
                    startTime: 0,
                    longPressTimer: null,
                    isLongPress: false
                };
                
                // Store the type for later reference
                element.dataset.touchGestureType = type;
                
                // Touch start
                element.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    touchData.startTime = Date.now();
                    touchData.isLongPress = false;
                    
                    // Add visual feedback for touch press
                    element.classList.add('touch-pressed');
                    
                    // Clear any existing timer
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                    }
                    
                    // Start long press timer - use shorter delay for chord name buttons
                    const delay = (type === 'chord' && element.classList.contains('extension-header')) ? 
                        this.touchGestures.chordNameLongPressDelay : this.touchGestures.longPressDelay;
                    
                    touchData.longPressTimer = setTimeout(() => {
                        touchData.isLongPress = true;
                        element.classList.remove('touch-pressed');
                        element.classList.add('touch-long-press');
                        this.handleLongPress(element, type, touch.clientX, touch.clientY);
                        
                        // Add haptic feedback if available
                        if (navigator.vibrate) {
                            navigator.vibrate(50);
                        }
                    }, delay);
                    
                    // Only prevent default for extension headers, let root buttons work normally
                    if (type === 'chord' && element.classList.contains('extension-header')) {
                        e.preventDefault();
                    } else if (type === 'palette') {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Touch move - cancel long press if moving too much
                element.addEventListener('touchmove', (e) => {
                    // Cancel long press on any significant movement
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                        touchData.longPressTimer = null;
                        element.classList.remove('touch-pressed');
                    }
                    
                    // Only prevent default for extension headers, let root buttons work normally
                    if (type === 'chord' && element.classList.contains('extension-header')) {
                        e.preventDefault();
                    } else if (type === 'palette') {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Touch end
                element.addEventListener('touchend', (e) => {
                    // Clear long press timer
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                        touchData.longPressTimer = null;
                    }
                    
                    // Remove all touch feedback classes
                    element.classList.remove('touch-pressed', 'touch-long-press');
                    
                    // Handle normal tap if not a long press
                    if (!touchData.isLongPress) {
                        const delay = (type === 'chord' && element.classList.contains('extension-header')) ? 
                            this.touchGestures.chordNameLongPressDelay : this.touchGestures.longPressDelay;
                        if (Date.now() - touchData.startTime < delay) {
                            this.handleNormalTap(element, type);
                        }
                    }
                    
                    touchData.isLongPress = false;
                    
                    // Only prevent default for extension headers, let root buttons work normally
                    if (type === 'chord' && element.classList.contains('extension-header')) {
                        e.preventDefault();
                    } else if (type === 'palette') {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Touch cancel
                element.addEventListener('touchcancel', (e) => {
                    if (touchData.longPressTimer) {
                        clearTimeout(touchData.longPressTimer);
                        touchData.longPressTimer = null;
                    }
                    
                    // Remove all touch feedback classes
                    element.classList.remove('touch-pressed', 'touch-long-press');
                    
                    touchData.isLongPress = false;
                }, { passive: false });
            }
            
            addClickGestureToElement(element, type) {
                // Prevent duplicate listeners
                if (element.dataset.clickGestureAdded) return;
                element.dataset.clickGestureAdded = 'true';
                
                // Add click event listener for regular mouse clicks (using capture phase for higher priority)
                element.addEventListener('click', (e) => {
                    // Show context menu for chord headers or extension columns
                    if (type === 'chord' && (element.classList.contains('extension-header') || element.classList.contains('extension-column'))) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        // Show context menu on regular click for chord elements
                        this.handleClick(element, type, e.clientX, e.clientY);
                        return false; // Ensure event stops here
                    } else if (type === 'palette') {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        // Show context menu for palette chords
                        this.handleClick(element, type, e.clientX, e.clientY);
                        return false; // Ensure event stops here
                    }
                    // For root buttons (type === 'root'), let the normal click behavior happen
                }, true); // Use capture phase
                
                // Also add a mousedown listener for long-press support
                element.addEventListener('mousedown', (e) => {
                    // Only handle left click (button 0)
                    if (e.button === 0 && type === 'chord' && (element.classList.contains('extension-header') || element.classList.contains('extension-column'))) {
                        // For chord name buttons (extension-header), use 200ms delay
                        if (element.classList.contains('extension-header')) {
                            element.dataset.mouseDownTime = Date.now();
                            element.dataset.mouseDownX = e.clientX;
                            element.dataset.mouseDownY = e.clientY;
                            
                            // Start timer for 200ms long press
                            element.dataset.mouseLongPressTimer = setTimeout(() => {
                                element.dataset.isMouseLongPress = 'true';
                                this.handleLongPress(element, type, e.clientX, e.clientY);
                            }, this.touchGestures.chordNameLongPressDelay);
                        } else {
                            // Regular behavior for other chord elements
                            element.dataset.showContextMenuOnMouseup = 'true';
                        }
                    }
                }, true);
                
                // Add mousemove listener to cancel long press on movement
                element.addEventListener('mousemove', (e) => {
                    if (element.dataset.mouseLongPressTimer && element.dataset.mouseDownX && element.dataset.mouseDownY) {
                        const deltaX = Math.abs(e.clientX - parseInt(element.dataset.mouseDownX));
                        const deltaY = Math.abs(e.clientY - parseInt(element.dataset.mouseDownY));
                        
                        // Cancel long press if mouse moved too much (more than 10px)
                        if (deltaX > 10 || deltaY > 10) {
                            clearTimeout(parseInt(element.dataset.mouseLongPressTimer));
                            delete element.dataset.mouseLongPressTimer;
                            delete element.dataset.mouseDownTime;
                            delete element.dataset.mouseDownX;
                            delete element.dataset.mouseDownY;
                        }
                    }
                });
                
                // Add mouseup listener to complete the action
                element.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        // Handle chord name button mouseup
                        if (element.classList.contains('extension-header') && element.dataset.mouseDownTime) {
                            const holdTime = Date.now() - parseInt(element.dataset.mouseDownTime);
                            
                            // Clear the timer
                            if (element.dataset.mouseLongPressTimer) {
                                clearTimeout(parseInt(element.dataset.mouseLongPressTimer));
                                delete element.dataset.mouseLongPressTimer;
                            }
                            
                            // If it was a long press, don't do anything else (already handled)
                            if (element.dataset.isMouseLongPress === 'true') {
                                delete element.dataset.isMouseLongPress;
                            } else if (holdTime < this.touchGestures.chordNameLongPressDelay) {
                                // Short click - treat as normal tap
                                this.handleNormalTap(element, type);
                            }
                            
                            // Clean up
                            delete element.dataset.mouseDownTime;
                            delete element.dataset.mouseDownX;
                            delete element.dataset.mouseDownY;
                        } else if (element.dataset.showContextMenuOnMouseup === 'true') {
                            // Regular behavior for other chord elements
                            delete element.dataset.showContextMenuOnMouseup;
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            this.handleClick(element, type, e.clientX, e.clientY);
                            return false;
                        }
                    }
                }, true);
            }
            
            handleClick(element, type, x, y) {
                // For chords and palette items, trigger a strum instead of a context menu
                if (type === 'chord' && (element.classList.contains('extension-header') || element.classList.contains('extension-column'))) {
                    const column = element.classList.contains('extension-column') ? element : element.closest('.extension-column');
                    if (!column) { console.error('Could not find parent column'); return; }
                    const header = column.querySelector('.extension-header');
                    const chordData = (this.getChordDataFromColumn(column, header)) || { name: header ? header.textContent : 'Chord' };
                    const rect = column.getBoundingClientRect();
                    const startY = rect.top + Math.max(4, rect.height * 0.08);
                    const endY = rect.bottom - Math.max(4, rect.height * 0.08);
                    this.playChordStrum(column, chordData, startY, endY);
                    return;
                }
                if (type === 'palette') {
                    const chordData = this.getPaletteChordDataFromElement(element);
                    const column = element.closest('.palette-chord') || element.closest('.extension-column') || element;
                    if (column && chordData) {
                        const rect = column.getBoundingClientRect();
                        const startY = rect.top + Math.max(4, rect.height * 0.08);
                        const endY = rect.bottom - Math.max(4, rect.height * 0.08);
                        this.playChordStrum(column, chordData, startY, endY);
                    }
                    return;
                }
                // For other types (e.g., root), let normal behavior proceed
            }
            
            handleLongPress(element, type, x, y) {
                // Show appropriate context menu based on element type
                if (type === 'chord') {
                    // Check if this is an extension header (chord name button)
                    if (element.classList.contains('extension-header')) {
                        // Get the column data from the parent column
                        const column = element.closest('.extension-column');
                        if (column) {
                            // Extract the chord data for the chord name context menu
                            const chordData = this.getChordDataFromColumn(column, element);
                            
                            if (chordData) {
                                // Context menu removed - no action taken
                            }
                        }
                    } else {
                        // Fallback to original logic for other chord elements
                        const columnData = this.getColumnDataFromElement(element);
                        // Context menu removed - no action taken
                    }
                } else if (type === 'palette') {
                    const chordData = this.getPaletteChordDataFromElement(element);
                    // Context menu removed - no action taken
                } else if (type === 'root') {
                    // Root chords could have their own context menu
                }
            }
            
            handleNormalTap(element, type) {
                // Play a strum on normal tap for chord headers and palette chords
                if (type === 'chord' && element.classList.contains('extension-header')) {
                    const column = element.closest('.extension-column');
                    if (column) {
                        const header = column.querySelector('.extension-header');
                        const chordData = (this.getChordDataFromColumn(column, header)) || { name: header ? header.textContent : 'Chord' };
                        const rect = column.getBoundingClientRect();
                        const startY = rect.top + Math.max(4, rect.height * 0.08);
                        const endY = rect.bottom - Math.max(4, rect.height * 0.08);
                        this.playChordStrum(column, chordData, startY, endY);
                    }
                } else if (type === 'palette') {
                    const chordData = this.getPaletteChordDataFromElement(element);
                    const column = element.closest('.palette-chord') || element.closest('.extension-column') || element;
                    if (column && chordData) {
                        const rect = column.getBoundingClientRect();
                        const startY = rect.top + Math.max(4, rect.height * 0.08);
                        const endY = rect.bottom - Math.max(4, rect.height * 0.08);
                        this.playChordStrum(column, chordData, startY, endY);
                    }
                } else if (type === 'root') {
                    // For root buttons, perform normal click behavior
                    const rootBtn = element.closest('.root-btn');
                    if (rootBtn) rootBtn.click();
                }
            }
            
            getColumnDataFromElement(element) {
                const column = element.closest('[data-chord-type]');
                if (!column) return null;
                
                return {
                    name: column.dataset.chordType,
                    extensions: column.dataset.extensions ? column.dataset.extensions.split(',') : [],
                    element: column
                };
            }
            
            getPaletteChordDataFromElement(element) {
                const chordElement = element.closest('.palette-chord');
                if (!chordElement) return null;
                
                const chordIndex = parseInt(chordElement.dataset.chordIndex);
                return this.paletteChords[chordIndex] || null;
            }
            
            showPaletteContextMenu(x, y, chordData) {
                // Context menu removed - no action taken
            }
            
            handlePaletteContextMenuAction(action) {
                // Context menu removed - no action taken
            }

            showColumnContextMenu(x, y, columnData) {
                // Context menu removed - no action taken
            }

            getChordDataFromColumn(column, header) {
                const chordType = column.dataset.chordType;
                let chordData = null;
                
                console.log('?? getChordDataFromColumn called with chordType:', chordType);
                
                // Check if it's a custom chord
                if (chordType && chordType.startsWith('custom_')) {
                    const customIndex = parseInt(chordType.replace('custom_', ''));
                    const customChord = this.customChords[customIndex];
                    if (customChord) {
                        chordData = {
                            name: customChord.name,
                            extensions: [],
                            quality: 'custom',
                            id: chordType,
                            isCustom: true,
                            originalName: customChord.name,
                            customIndex: customIndex,
                            intervals: customChord.notes,
                            root: this.currentRoot,
                            tuning: this.currentTuning
                        };
                    }
                } else {
                    // Regular extension chord - determine quality and extension
                    let quality = 'major'; // default
                    
                    // Try to find quality from parent quality section first
                    let qualitySection = null;
                    if (header && header.closest) {
                        qualitySection = header.closest('.quality-section');
                    }
                    
                    if (qualitySection) {
                        const allQualitySections = Array.from(document.querySelectorAll('.quality-section'));
                        const qualityIndex = allQualitySections.indexOf(qualitySection);
                        const qualities = ['major', 'neutral', 'minor'];
                        quality = qualities[qualityIndex] || 'major';
                    } else {
                        // For basic triads mode, determine quality from chord type or header text
                        const headerText = header && header.textContent ? header.textContent : '';
                        if (chordType === 'major' || headerText === 'Major') {
                            quality = 'major';
                        } else if (chordType === 'neutral' || headerText === 'Neutral') {
                            quality = 'neutral';
                        } else if (chordType === 'minor' || headerText === 'Minor') {
                            quality = 'minor';
                        }
                    }
                    
                    // Find the extension - in basic triads mode, find by name
                    let chordExt = null;
                    if (chordType === 'major' || chordType === 'neutral' || chordType === 'minor') {
                        // Basic triads mode - find by name
                        chordExt = this.chordExtensions.find(ext => 
                            ext.name.toLowerCase() === header.textContent.toLowerCase()
                        );
                    } else {
                        // Complex mode - find by index
                        const chordIndex = parseInt(chordType);
                        chordExt = this.chordExtensions[chordIndex];
                    }
                    
                    if (chordExt) {
                        chordData = {
                            name: header.textContent,
                            extensions: chordExt.extensions || [],
                            quality: quality,
                            id: chordType,
                            isCustom: false,
                            originalName: chordExt.name,
                            extensionIndex: chordExt.name, // Use name as identifier in basic mode
                            intervals: this.getBaseTriadForQuality(quality).concat(chordExt.extensions || []),
                            root: this.currentRoot,
                            tuning: this.currentTuning
                        };
                        console.log('?? Created chordData:', chordData);
                    } else {
                        console.log('?? Failed to find chordExt for chordType:', chordType);
                    }
                }
                
                return chordData;
            }

            showChordNameContextMenu(x, y, chordData) {
                // Context menu removed - no action taken
            }

            handleContextMenuAction(action) {
                // Context menu removed - no action taken
                console.log('Context menu action requested but disabled:', action);
            }
            
            // New unified methods for the refactored system
            duplicateAndEditColumn() {
                if (!this.currentEditingColumn) return;
                
                // Create a duplicate chord with new ID
                const duplicateChord = {
                    name: this.currentEditingColumn.name + ' Copy',
                    intervals: [...(this.currentEditingColumn.intervals || [])],
                    isCustom: true,
                    id: Date.now()
                };
                
                // Open chord builder with the duplicate
                this.showChordBuilder(duplicateChord);
            }
            
            editColumnInChordBuilder() {
                if (!this.currentEditingColumn) return;
                
                // Open chord builder with current column data for editing
                this.showChordBuilder(this.currentEditingColumn);
            }

            // Palette chord context menu actions
            editPaletteChordNotes(chordData) {
                // Open a modal to edit chord notes
                console.log('Editing palette chord notes:', chordData);
                // TODO: Implement chord note editor
            }
            
            copyPaletteChord(chordData) {
                // Create a copy of the chord and add it to the palette
                const copy = {
                    ...chordData,
                    name: chordData.name + ' Copy'
                };
                this.paletteChords.push(copy);
                this.savePaletteChords();
                console.log('Copied palette chord:', copy);
            }
            
            movePaletteChord(chordData, direction) {
                const currentIndex = this.paletteChords.findIndex(chord => 
                    chord.name === chordData.name && 
                    JSON.stringify(chord.notes) === JSON.stringify(chordData.notes)
                );
                
                if (currentIndex === -1) return;
                
                const newIndex = currentIndex + direction;
                if (newIndex < 0 || newIndex >= this.paletteChords.length) return;
                
                // Swap positions
                [this.paletteChords[currentIndex], this.paletteChords[newIndex]] = 
                [this.paletteChords[newIndex], this.paletteChords[currentIndex]];
                
                this.savePaletteChords();
                console.log('Moved palette chord:', direction > 0 ? 'right' : 'left');
            }
            
            removePaletteChord(chordData) {
                const index = this.paletteChords.findIndex(chord => 
                    chord.name === chordData.name && 
                    JSON.stringify(chord.notes) === JSON.stringify(chordData.notes)
                );
                
                if (index !== -1) {
                    this.paletteChords.splice(index, 1);
                    this.savePaletteChords();
                    console.log('Removed palette chord:', chordData.name);
                }
            }

            setupFretboardResize() {
                const resizeHandle = document.querySelector('.resize-handle');
                const extensionColumns = document.getElementById('extensionColumns');
                let isResizing = false;
                let startY = 0;
                let startHeight = 0;

                if (!resizeHandle || !extensionColumns) return;

                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startY = e.clientY;
                    startHeight = extensionColumns.offsetHeight;
                    document.body.style.cursor = 'ns-resize';
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;
                    
                    const deltaY = e.clientY - startY;
                    const newHeight = Math.max(200, Math.min(800, startHeight + deltaY));
                    
                    // Update container height
                    extensionColumns.style.height = `${newHeight}px`;
                    
                    // Update string spacing by keeping strings thin (1px) with tight margins for 8-octave support
                    const strings = document.querySelectorAll('.string');
                    const stringHeight = 1; // Always keep strings thin at 1px
                    const stringMargin = 0.2; // Consistent tight margin for 8-octave support
                    
                    strings.forEach(string => {
                        string.style.height = `${stringHeight}px`;
                        string.style.margin = `${stringMargin}px 0`;
                    });
                    
                    e.preventDefault();
                });

                document.addEventListener('mouseup', () => {
                    if (isResizing) {
                        isResizing = false;
                        document.body.style.cursor = '';
                    }
                });

                // Touch support for mobile
                resizeHandle.addEventListener('touchstart', (e) => {
                    isResizing = true;
                    startY = e.touches[0].clientY;
                    startHeight = extensionColumns.offsetHeight;
                    e.preventDefault();
                });

                document.addEventListener('touchmove', (e) => {
                    if (!isResizing) return;
                    
                    const deltaY = e.touches[0].clientY - startY;
                    const newHeight = Math.max(200, Math.min(800, startHeight + deltaY));
                    
                    extensionColumns.style.height = `${newHeight}px`;
                    
                    const strings = document.querySelectorAll('.string');
                    const stringHeight = 1; // Always keep strings thin at 1px
                    const stringMargin = 0.2; // Consistent tight margin for 8-octave support
                    
                    strings.forEach(string => {
                        string.style.height = `${stringHeight}px`;
                        string.style.margin = `${stringMargin}px 0`;
                    });
                    
                    e.preventDefault();
                });

                document.addEventListener('touchend', () => {
                    if (isResizing) {
                        isResizing = false;
                    }
                });
            }

            setupSonicChords() {
                // No longer rendering sonic chords - lock buttons work directly on main chord grid
                console.log('Sonic chord system disabled - using direct chord locking');
            }

            handleSonicStringTrigger(e) {
                if (!e.target.classList.contains('string')) return;
                
                const stringElement = e.target;
                const column = stringElement.closest('.sonic-column');
                if (!column) return;
                
                const index = parseInt(column.dataset.index);
                const sonicChord = this.lockedSonicChords[index];
                if (!sonicChord) return;
                
                const stringIndex = parseInt(stringElement.dataset.string);
                const stringKey = `${index}-${stringIndex}`;
                
                if (!this.sonicTriggeredStrings.has(stringKey)) {
                    this.sonicTriggeredStrings.add(stringKey);
                    
                    // Apply sonic settings temporarily and play the string
                    this.playSonicChord(sonicChord, () => {
                        this.playStringAtIndex(stringIndex);
                    });
                }
            }

            playSonicChordStrum(column, sonicChord, startY, endY) {
                // Apply sonic settings temporarily and play chord strum
                this.playSonicChord(sonicChord, () => {
                    this.playChordStrum(column, sonicChord.chordData, startY, endY);
                });
            }

            addToPalette(chordData) {
                // Always add chords to palette, even duplicates for chord progressions
                // Add a unique ID to track individual instances
                const chordWithId = {
                    ...chordData,
                    paletteId: Date.now() + Math.random() // Unique identifier for this instance
                };
                
                this.paletteChords.push(chordWithId);
                // localStorage removed - no longer saving palette chords
                console.log(`Added "${chordData.fullName}" to palette (${this.paletteChords.length} total chords)`);
                this.renderPaletteChords();
            }

            removeFromPalette(index) {
                if (index >= 0 && index < this.paletteChords.length) {
                    const removedChord = this.paletteChords.splice(index, 1)[0];
                    // localStorage removed - no longer saving palette chords
                    this.renderPaletteChords();
                    console.log(`Removed "${removedChord.fullName}" from palette`);
                }
            }

            // =============================================================================
            // SONIC CHORD LOCKING SYSTEM - Complete snapshot of all settings
            // =============================================================================
            
            lockSonicChord(chordData, columnElement) {
                // Check if this chord is already locked
                if (!this.lockedChords) this.lockedChords = new Map();
                
                const isAlreadyLocked = this.lockedChords.has(columnElement);
                
                if (isAlreadyLocked) {
                    // UNLOCK the chord - make it editable but keep it visible
                    console.log('?? Unlocking chord but keeping it visible:', chordData.name);
                    
                    // Get the locked chord data before deleting
                    const lockedChordData = this.lockedChords.get(columnElement);
                    
                    this.lockedChords.delete(columnElement);
                    
                    // Update session data and saved locks
                    this.sessionData.lockedChords = Array.from(this.lockedChords.values());
                    this.savedLockedChords = Array.from(this.lockedChords.values());
                    
                    // Update UI - change lock button to unlocked state (buttons remain visible)
                    const lockButton = columnElement.querySelector('.lock-button');
                    if (lockButton) {
                        lockButton.innerHTML = '🔓';
                        lockButton.classList.remove('locked');
                        lockButton.title = 'Lock chord with current root & settings';
                    }
                    
                    // Keep action buttons visible when unlocked - they should always be available
                    
                    // Reset the column header color to indicate unlocked
                    const header = columnElement.querySelector('.extension-header');
                    const chordName = header.querySelector('.chord-name');
                    if (chordName) {
                        chordName.style.color = '#fff'; // Reset to default color
                        chordName.style.fontWeight = 'normal'; // Reset font weight
                        // Restore original chord name (remove lock icon and root prefix)
                        const originalName = chordData.name || (lockedChordData ? lockedChordData.chordName : 'Chord');
                        const qualityOnlyName = originalName.replace(/^🔒\s*/, '').replace(/^[A-G][#b]?\s*/, ''); // Remove lock icon and root
                        chordName.textContent = qualityOnlyName || originalName;
                        chordName.title = 'Unlocked - will follow current root'; // Update tooltip
                    }
                    
                    // Update the chord extension data to reflect unlocked state
                    if (lockedChordData) {
                        const chordExtension = this.chordExtensions.find(ext => 
                            ext.name === lockedChordData.chordName || 
                            (ext.lockedData && ext.lockedData.lockId === lockedChordData.lockId)
                        );
                        
                        if (chordExtension) {
                            // Convert back to unlocked state but keep the chord visible
                            chordExtension.isLocked = false;
                            chordExtension.lockedData = null;
                            // Keep the intervals so the chord structure remains
                            chordExtension.intervals = lockedChordData.intervals;
                            chordExtension.isCustom = true; // Mark as custom to preserve intervals
                            
                            console.log('?? Converted locked chord to unlocked custom chord:', chordExtension.name);
                        }
                    }
                    
                    // Update the strings in this column to use current root instead of locked root
                    const strings = columnElement.querySelectorAll('.string');
                    strings.forEach(string => {
                        const interval = parseInt(string.dataset.interval);
                        if (!isNaN(interval)) {
                            // Recalculate frequency with current root
                            const absStep3 = ((this.currentRoot + interval) % this.currentTuning + this.currentTuning) % this.currentTuning;
                            const frequency = this.getFrequency(absStep3, 4, this.currentTuning);
                            string.dataset.frequency = frequency;
                            
                            // Update note name and tooltip
                            const noteName = this.getIntervalNoteName(interval);
                            string.textContent = noteName;
                            string.title = `${noteName} (${interval} steps, ${frequency.toFixed(1)}Hz)`;
                        }
                    });
                    
                    console.log('?? Chord unlocked but remains visible as editable chord:', chordData.name);
                    return;
                }
                
                // LOCK the chord
                    console.log('?? Locking chord directly in main grid with current root and settings:', chordData);
                
                // Create a unique identifier for this specific chord + root combination
                const currentRoot = this.currentRoot || 0;
                const lockId = `${chordData.name}_${chordData.quality || 'major'}_${currentRoot}`;
                
                // Capture ALL current settings directly from UI controls
                const rootName = this.getNoteNames()[currentRoot] || currentRoot;
                // Avoid duplicating root if chordData.name already starts with a root (e.g., "C", "Bb7")
                const nameHasRoot = /^[A-G][#b]?/.test(chordData.name || '');
                const fullChordName = nameHasRoot ? (chordData.name || String(rootName)) : `${rootName}${chordData.name}`; // Full display name
                
                const lockedChordData = {
                    // Chord identification
                    lockId: lockId,
                    chordName: fullChordName, // Store full name (root + quality) when locked
                    quality: chordData.quality || this.currentQuality || 'major',
                    extensions: chordData.extensions || [],
                    lockedRoot: currentRoot, // THIS is the key - lock to current root
                    
                    // Position tracking - find current position in chordExtensions array
                    originalPosition: chordData.position !== undefined ? chordData.position : this.findChordPosition(chordData),
                    
                    // Store chord intervals for exact reconstruction
                    intervals: chordData.intervals || [],
                    isCustom: chordData.isCustom || false,
                    
                    // Tuning system (locked)
                    lockedTuning: this.currentTuning || 12,
                    lockedGamelanMode: this.gamelanMode || false,
                    
                    // Audio settings (locked)
                    lockedOsc1: {
                        type: document.getElementById('osc1Type')?.value || this.oscillators.osc1.type || 'sine',
                        level: parseFloat(document.getElementById('osc1Level')?.value || this.oscillators.osc1.level || 0.5),
                        octave: parseInt(document.getElementById('osc1Octave')?.value || this.oscillators.osc1.octave || 0),
                        coarse: parseInt(document.getElementById('osc1Coarse')?.value || this.oscillators.osc1.coarse || 0),
                        detune: parseFloat(document.getElementById('osc1Detune')?.value || this.oscillators.osc1.detune || 0)
                    },
                    
                    lockedOsc2: {
                        type: document.getElementById('osc2Type')?.value || this.oscillators.osc2.type || 'sine',
                        level: parseFloat(document.getElementById('osc2Level')?.value || this.oscillators.osc2.level || 0.5),
                        octave: parseInt(document.getElementById('osc2Octave')?.value || this.oscillators.osc2.octave || 0),
                        coarse: parseInt(document.getElementById('osc2Coarse')?.value || this.oscillators.osc2.coarse || 0),
                        detune: parseFloat(document.getElementById('osc2Detune')?.value || this.oscillators.osc2.detune || 0)
                    },
                    
                    lockedEnvelope: {
                        attack: parseFloat(document.getElementById('envAttack')?.value || this.envelope.attack || 0.01),
                        decay: parseFloat(document.getElementById('envDecay')?.value || this.envelope.decay || 0.3),
                        sustain: parseFloat(document.getElementById('envSustain')?.value || this.envelope.sustain || 0.5),
                        release: parseFloat(document.getElementById('envRelease')?.value || this.envelope.release || 1)
                    },
                    
                    lockedOsc2Envelope: {
                        attack: parseFloat(document.getElementById('osc2EnvAttack')?.value || this.osc2Envelope.attack || 0.01),
                        decay: parseFloat(document.getElementById('osc2EnvDecay')?.value || this.osc2Envelope.decay || 0.3),
                        sustain: parseFloat(document.getElementById('osc2EnvSustain')?.value || this.osc2Envelope.sustain || 0.5),
                        release: parseFloat(document.getElementById('osc2EnvRelease')?.value || this.osc2Envelope.release || 1)
                    },
                    
                    lockedEffects: {
                        reverbWet: parseFloat(document.getElementById('reverbWet')?.value || this.reverbWet || 0),
                        reverbDecay: parseFloat(document.getElementById('reverbDecay')?.value || (this.reverb ? this.reverb.decay : 1)),
                        reverbFilterCutoff: parseFloat(document.getElementById('reverbFilterCutoff')?.value || (this.reverbFilterNode ? this.reverbFilterNode.frequency.value : 20000)),
                        panningMode: document.getElementById('panningMode')?.value || this.panning.mode || 'center',
                        panningWidth: parseFloat(document.getElementById('panningWidth')?.value || this.panning.width || 1)
                    },
                    
                    lockedVolume: {
                        master: parseFloat(document.getElementById('masterVolume')?.value || this.masterVolume || 1),
                        main: parseFloat(document.getElementById('mainVolume')?.value || this.volume || 0.5)
                    },
                    
                    // CRITICAL: Capture exact string frequencies for perfect sound preservation
                    exactFrequencies: this.captureStringFrequencies(columnElement),
                    
                    // Timestamp
                    timestamp: Date.now()
                };
                
                // Store in lockedChords map using column element as key
                if (!this.lockedChords) this.lockedChords = new Map();
                this.lockedChords.set(columnElement, lockedChordData);
                
                // Store in session data and keep saved locks in sync
                this.sessionData.lockedChords = Array.from(this.lockedChords.values());
                this.savedLockedChords = Array.from(this.lockedChords.values());

                // Mark chord model as locked so regeneration uses snapshot
                if (chordData) {
                    chordData.isLocked = true;
                    chordData.lockedData = lockedChordData;
                }
                
                // Update UI - change lock button to locked state and show locked root
                const lockButton = columnElement.querySelector('.lock-button');
                if (lockButton) {
                    lockButton.innerHTML = '🔒';
                    lockButton.classList.add('locked');
                    lockButton.title = `Locked to ${this.getNoteNames()[currentRoot] || currentRoot} root with all settings`;
                }
                
                // Action buttons remain visible (they should always be available)
                // No edit/hide/duplicate header buttons anymore
                
                // Update the column header to show it's locked to a specific root
                const header = columnElement.querySelector('.extension-header');
                const chordName = header.querySelector('.chord-name');
                if (chordName) {
                    const rootName = this.getNoteNames()[currentRoot] || currentRoot;
                    chordName.style.color = '#4CAF50';
                    const alreadyHasRoot = /^[A-G][#b]?/.test(chordData.name || '');
                    const displayName = alreadyHasRoot ? chordData.name : `${rootName}${chordData.name}`;
                    chordName.textContent = `🔒 ${displayName}`;
                    chordName.title = `Locked to ${rootName} (oscillators & envelopes only)`;
                }
                
                console.log('?? Chord locked directly in main grid:', lockedChordData);
            }
            
            // ============= PIANO SETTINGS LOCK SYSTEM - Oscillator & Effect Settings Only =============
            
            // Store the original UI state to prevent contamination
            storeOriginalUIState() {
                if (!this.originalUIState) {
                    // Store the initial clean state when app starts
                    this.originalUIState = {
                        osc1: { ...this.oscillators.osc1 },
                        osc2: { ...this.oscillators.osc2 },
                        envelope: { ...this.envelope },
                        osc2Envelope: { ...this.osc2Envelope },
                        reverb: { ...this.reverb },
                        panning: { ...this.panning },
                        volume: this.volume,
                        masterVolume: this.masterVolume
                    };
                }
                return this.originalUIState;
            }
            
            // Capture current synthesizer state for piano lock with unique preset ID
            captureCurrentSynthState() {
                // Defensive: initialize counter/map if missing
                if (typeof this.pianoLockPresetCounter !== 'number' || !isFinite(this.pianoLockPresetCounter)) {
                    this.pianoLockPresetCounter = 0;
                }
                if (!this.preloadedPresets) {
                    this.preloadedPresets = new Map();
                }
                // Generate unique preset ID
                this.pianoLockPresetCounter++;
                const presetId = `ID${String(this.pianoLockPresetCounter).padStart(3, '0')}`;
                
                const synthState = {
                    // Unique preset identifier
                    presetId: presetId,
                    
                    // Oscillator 1 settings (COMPLETE)
                    osc1: { ...this.oscillators.osc1 },
                    
                    // Oscillator 2 settings (COMPLETE)
                    osc2: { ...this.oscillators.osc2 },
                    
                    // Envelope settings (OSC 1 COMPLETE ADSR)
                    envelope: { ...this.envelope },
                    
                    // OSC 2 Envelope settings (COMPLETE ADSR)
                    osc2Envelope: { ...this.osc2Envelope },
                    
                    // Volume settings
                    volume: {
                        main: this.volume,
                        master: this.masterVolume
                    }
                };
                
                // Preload this preset for instant switching
                this.preloadedPresets.set(presetId, synthState);
                
                console.log(`🎹 Created new piano lock preset: ${presetId}`);
                console.log(`🎹 OSC1: ${synthState.osc1.type} wave, A:${Math.round(synthState.envelope.attack*1000)} D:${Math.round(synthState.envelope.decay*1000)} S:${Math.round(synthState.envelope.sustain*100)}% R:${Math.round(synthState.envelope.release*1000)}`);
                console.log(`🎹 OSC2: ${synthState.osc2.type} wave, A:${Math.round(synthState.osc2Envelope.attack*1000)} D:${Math.round(synthState.osc2Envelope.decay*1000)} S:${Math.round(synthState.osc2Envelope.sustain*100)}% R:${Math.round(synthState.osc2Envelope.release*1000)}`);
                
                return synthState;
            }
            
            // Migrate existing piano locks from old format (with root) to new format (without root)
            migratePianoLocksToNewFormat() {
                if (!this.pianoLockedChords || this.pianoLockedChords.size === 0) return;
                
                console.log('🎹 MIGRATING piano locks to new format (removing root dependency)');
                const oldEntries = Array.from(this.pianoLockedChords.entries());
                const newPianoLocks = new Map();
                const newPreloadedPresets = new Map();
                
                oldEntries.forEach(([oldKey, pianoData]) => {
                    // Check if this is an old-format key (contains root)
                    const keyParts = oldKey.split('_');
                    if (keyParts.length >= 4) {
                        // Old format: chordName_quality_root_extensions_intervals
                        const [chordName, quality, root, ...rest] = keyParts;
                        
                        // Create new key without root
                        const extensions = rest.length > 1 ? rest[0] : '';
                        const intervals = rest.length > 1 ? rest[1] : rest[0] || '';
                        const newKey = `${chordName}_${quality}_${extensions}_${intervals}`;
                        
                        console.log(`🎹 Migrating: ${oldKey} → ${newKey}`);
                        
                        // Store with new key format
                        newPianoLocks.set(newKey, pianoData);
                        
                        // Also migrate preloaded preset
                        if (pianoData.presetId && this.preloadedPresets.has(pianoData.presetId)) {
                            newPreloadedPresets.set(pianoData.presetId, this.preloadedPresets.get(pianoData.presetId));
                        }
                    } else {
                        // Already new format, keep as-is
                        newPianoLocks.set(oldKey, pianoData);
                        if (pianoData.presetId && this.preloadedPresets.has(pianoData.presetId)) {
                            newPreloadedPresets.set(pianoData.presetId, this.preloadedPresets.get(pianoData.presetId));
                        }
                    }
                });
                
                // Replace old maps with migrated data
                this.pianoLockedChords = newPianoLocks;
                this.preloadedPresets = newPreloadedPresets;
                
                console.log('🎹 Migration complete. Piano locks now work across all root notes!');
            }
            
            // Generate a stable key for piano lock identification that is independent of display names/quality
            generatePianoLockKey(chordData) {
                // Prefer the chord's SHAPE (sorted intervals) so the key is stable across renames, roots, and qualities
                let iv = Array.isArray(chordData?.intervals) ? [...chordData.intervals] : [];
                if ((!iv || iv.length === 0) && typeof this.getChordIntervals === 'function') {
                    // Derive from extensions if explicit intervals were not provided
                    iv = this.getChordIntervals(chordData?.extensions || []);
                }
                if (!Array.isArray(iv)) iv = [];
                // Normalize numeric and sort
                const ivNums = iv.map(n => {
                    const v = Number(n);
                    return Number.isFinite(v) ? v : 0;
                }).sort((a,b)=> a-b);
                const intervalsSig = ivNums.join('.');

                // Include whether it's custom to reduce accidental collisions across radically different modes
                const customTag = chordData?.isCustom ? 'custom' : 'builtIn';
                const key = `shape:${intervalsSig}|${customTag}`;

                // Debug
                console.log('🔑 generatePianoLockKey:', {intervalsSig, customTag, key, chordData});
                return key;
            }
            
            // Find piano lock data by stable key
            findPianoLockData(chordData) {
                if (!this.pianoLockedChords) return null;
                const key = this.generatePianoLockKey(chordData);
                const direct = this.pianoLockedChords.get(key);
                if (direct) return direct;

                // Fallback 1: match by intervals signature against existing entries (backward compatibility)
                let iv = Array.isArray(chordData?.intervals) ? [...chordData.intervals] : [];
                if ((!iv || iv.length === 0) && typeof this.getChordIntervals === 'function') {
                    iv = this.getChordIntervals(chordData?.extensions || []);
                }
                const sig = (Array.isArray(iv) ? iv.map(n=> Number(n)||0).sort((a,b)=>a-b).join('.') : '');
                if (sig) {
                    for (const [k, data] of this.pianoLockedChords.entries()) {
                        if (data && data.intervalsSig === sig) return data;
                        // Old-style key may end with "_intervals"; compare last token if present
                        const lastUnderscore = k.lastIndexOf('_');
                        if (lastUnderscore > -1) {
                            const tail = k.slice(lastUnderscore+1);
                            if (tail.replace(/,/g,'.') === sig.replace(/\./g,'.')) return data;
                        }
                    }
                }
                return null;
            }
            
            lockPianoSettings(chordData, columnElement) {
                console.log('🎹 lockPianoSettings function called with:', chordData, columnElement);
                
                // Check if this chord already has piano-locked settings using stable key
                if (!this.pianoLockedChords) this.pianoLockedChords = new Map();
                
                const lockKey = this.generatePianoLockKey(chordData);
                const isAlreadyPianoLocked = this.pianoLockedChords.has(lockKey);
                
                if (isAlreadyPianoLocked) {
                    // UNLOCK the piano settings (backend only; UI buttons removed)
                    console.log('🎹 Unlocking piano settings (backend) for:', chordData.name, 'key:', lockKey);
                    this.pianoLockedChords.delete(lockKey);
                    chordData.isPianoLocked = false;
                    chordData.pianoLockedData = null;
                    return;
                }
                
                // If a different column with the same shape is already locked, transfer ownership to this column
                const existingData = this.pianoLockedChords.get(lockKey);
                if (existingData) {
                    // Find currently locked column for this key
                    let currentOwnerCol = null;
                    try {
                        // Find an owner column by matching stored pianoLockKey on chord data
                        document.querySelectorAll('.extension-column').forEach(col => {
                            if (currentOwnerCol) return;
                            const headerEl = col.querySelector('.extension-header');
                            const cd = this.getChordDataFromColumn(col, headerEl);
                            if (!cd) return;
                            const k = this.generatePianoLockKey(cd);
                            if (k === lockKey && cd.isPianoLocked) {
                                currentOwnerCol = col;
                            }
                        });
                    } catch (_) {}
                    // If the same column, treat as unlock (handled above). If different, switch UI ownership.
                    if (currentOwnerCol && currentOwnerCol !== columnElement) {
                        // Unlock previous owner's UI and model flags
                        try {
                            const prevHeader = currentOwnerCol.querySelector('.extension-header');
                            const prevData = this.getChordDataFromColumn(currentOwnerCol, prevHeader);
                            if (prevData) { prevData.isPianoLocked = false; prevData.pianoLockedData = null; }
                        } catch (_) {}
                        // Transfer ownership (backend) and warm this column for instant play
                        chordData.isPianoLocked = true;
                        chordData.pianoLockedData = existingData;
                        chordData.pianoLockKey = lockKey;
                        // Warm this chord for instant play
                        try { this.preloadPianoLockedChord(columnElement); } catch (_) {}
                        console.log('🎹 Transferred piano-lock ownership to clicked column for key:', lockKey);
                        return;
                    }
                }

                // LOCK the piano settings (no existing owner)
                console.log('🎹 Locking piano settings for:', chordData.name, 'key:', lockKey);
                const currentSynthState = this.captureCurrentSynthState();
                const pianoLockedData = {
                    chordName: chordData.name,
                    lockKey: lockKey,
                    intervalsSig: (Array.isArray(chordData?.intervals) && chordData.intervals.length)
                        ? chordData.intervals.map(n=> Number(n)||0).sort((a,b)=>a-b).join('.')
                        : (typeof this.getChordIntervals === 'function' ? (this.getChordIntervals(chordData.extensions||[]).map(n=> Number(n)||0).sort((a,b)=>a-b).join('.')) : ''),
                    ...currentSynthState,
                    timestamp: Date.now()
                };
                this.pianoLockedChords.set(lockKey, pianoLockedData);
                chordData.isPianoLocked = true;
                chordData.pianoLockedData = pianoLockedData;
                chordData.pianoLockKey = lockKey;
                // Piano-lock UI removed; only backend data stored. Warm this chord for instant play.
                try { this.preloadPianoLockedChord(columnElement); } catch(_) {}
            }
            
            // Apply piano-locked settings when playing a chord (NEVER modifies base synthesizer state)
            applyPianoLockedSettings(pianoLockedData) {
                if (!pianoLockedData) return;
                
                const presetId = pianoLockedData.presetId;
                console.log(`🎹 Applying piano-locked preset: ${presetId} (${pianoLockedData.chordName})`);
                
                // Use preloaded preset if available for instant switching
                let settingsToApply = pianoLockedData;
                if (this.preloadedPresets.has(presetId)) {
                    settingsToApply = this.preloadedPresets.get(presetId);
                    console.log(`🎹 Using preloaded preset for instant switching: ${presetId}`);
                } else {
                    console.log(`🎹 Preset not preloaded, using stored data: ${presetId}`);
                }
                
                console.log(`🎹 OSC1: ${settingsToApply.osc1.type} wave, A:${Math.round(settingsToApply.envelope.attack*1000)} D:${Math.round(settingsToApply.envelope.decay*1000)} S:${Math.round(settingsToApply.envelope.sustain*100)}% R:${Math.round(settingsToApply.envelope.release*1000)}`);
                console.log(`🎹 OSC2: ${settingsToApply.osc2.type} wave, A:${Math.round(settingsToApply.osc2Envelope.attack*1000)} D:${Math.round(settingsToApply.osc2Envelope.decay*1000)} S:${Math.round(settingsToApply.osc2Envelope.sustain*100)}% R:${Math.round(settingsToApply.osc2Envelope.release*1000)}`);
                
                // IMPORTANT: We directly modify the synthesizer objects only temporarily
                // These will be immediately restored after playFrequency starts
                
                // Apply oscillator settings (complete objects)
                if (settingsToApply.osc1) {
                    Object.assign(this.oscillators.osc1, settingsToApply.osc1);
                }
                if (settingsToApply.osc2) {
                    Object.assign(this.oscillators.osc2, settingsToApply.osc2);
                }
                
                // Apply envelope settings (complete objects)
                if (settingsToApply.envelope) {
                    Object.assign(this.envelope, settingsToApply.envelope);
                    // Sync ADSR 1 UI
                    const a = document.getElementById('attackSlider');
                    const d = document.getElementById('decaySlider');
                    const s = document.getElementById('sustainSlider');
                    const r = document.getElementById('releaseSlider');
                    const av = document.getElementById('attackValue');
                    const dv = document.getElementById('decayValue');
                    const sv = document.getElementById('sustainValue');
                    const rv = document.getElementById('releaseValue');
                    if (a) { const ms = Math.round((this.envelope.attack||0)*1000); a.value = String(ms); if (av) av.textContent = `${ms}ms`; }
                    if (d) { const ms = Math.round((this.envelope.decay||0)*1000); d.value = String(ms); if (dv) dv.textContent = `${ms}ms`; }
                    if (s) { const pct = Math.round((this.envelope.sustain||0)*100); s.value = String(pct); if (sv) sv.textContent = `${pct}%`; }
                    if (r) { const ms = Math.round((this.envelope.release||0)*1000); r.value = String(ms); if (rv) rv.textContent = `${ms}ms`; }
                }
                if (settingsToApply.osc2Envelope) {
                    Object.assign(this.osc2Envelope, settingsToApply.osc2Envelope);
                    // Sync ADSR 2 UI
                    const a2 = document.getElementById('osc2AttackSlider');
                    const d2 = document.getElementById('osc2DecaySlider');
                    const s2 = document.getElementById('osc2SustainSlider');
                    const r2 = document.getElementById('osc2ReleaseSlider');
                    const a2v = document.getElementById('osc2AttackValue');
                    const d2v = document.getElementById('osc2DecayValue');
                    const s2v = document.getElementById('osc2SustainValue');
                    const r2v = document.getElementById('osc2ReleaseValue');
                    if (a2) { const ms = Math.round((this.osc2Envelope.attack||0)*1000); a2.value = String(ms); if (a2v) a2v.textContent = `${ms}ms`; }
                    if (d2) { const ms = Math.round((this.osc2Envelope.decay||0)*1000); d2.value = String(ms); if (d2v) d2v.textContent = `${ms}ms`; }
                    if (s2) { const pct = Math.round((this.osc2Envelope.sustain||0)*100); s2.value = String(pct); if (s2v) s2v.textContent = `${pct}%`; }
                    if (r2) { const ms = Math.round((this.osc2Envelope.release||0)*1000); r2.value = String(ms); if (r2v) r2v.textContent = `${ms}ms`; }
                }
                
                // NOTE: Do NOT apply reverb or panning from piano-lock. Those are global per-user mix choices.
                
                // Apply volume settings
                if (settingsToApply.volume) {
                    this.volume = settingsToApply.volume.main;
                    this.masterVolume = settingsToApply.volume.master;
                    if (this.gainNode) {
                        this.gainNode.gain.value = this.volume * this.masterVolume;
                    }
                }

                // If OSC panel is open, reflect the currently applied settings for clarity
                const oscPanel = document.querySelector('.panel-content[data-panel="osc"]');
                if (oscPanel && window.getComputedStyle(oscPanel).display !== 'none') {
                    const syncOscUi = (num, data) => {
                        try {
                            // Activate waveform button
                            document.querySelectorAll(`.osc-btn[data-osc="${num}"]`).forEach(b => b.classList.remove('active'));
                            const active = document.querySelector(`.osc-btn[data-osc="${num}"][data-wave="${data.type}"]`);
                            if (active) active.classList.add('active');
                            // Pulse width visibility/value
                            const pwContainer = document.querySelector(`.pulse-width-container[data-osc="${num}"]`);
                            if (pwContainer) pwContainer.style.display = (data.type === 'pulse') ? 'block' : 'none';
                            const pwSlider = document.getElementById(`osc${num}PulseWidth`);
                            const pwValue = document.getElementById(`osc${num}PulseWidthValue`);
                            if (pwSlider && typeof data.pulseWidth === 'number') {
                                const pct = Math.round((data.pulseWidth || 0.5) * 100);
                                pwSlider.value = String(pct);
                                if (pwValue) pwValue.textContent = `${pct}%`;
                            }
                            // Level
                            const lvl = document.getElementById(`osc${num}Level`);
                            const lvlV = document.getElementById(`osc${num}LevelValue`);
                            if (lvl) {
                                const slider = Math.round(((data.level || 0) / 0.125) * 10);
                                lvl.value = String(slider);
                                if (lvlV) lvlV.textContent = `${slider * 10}%`;
                            }
                            // Fine
                            const det = document.getElementById(`osc${num}Detune`);
                            const detV = document.getElementById(`osc${num}DetuneValue`);
                            if (det) {
                                det.value = String(Math.round(data.detune || 0));
                                if (detV) detV.textContent = `${Math.round(data.detune || 0)}¢`;
                            }
                            // Octave/coarse
                            const oct = document.getElementById(`osc${num}Octave`);
                            const octV = document.getElementById(`osc${num}OctaveValue`);
                            if (oct) { oct.value = String(data.octave || 0); if (octV) octV.textContent = String(data.octave || 0); }
                            const crs = document.getElementById(`osc${num}Coarse`);
                            const crsV = document.getElementById(`osc${num}CoarseValue`);
                            if (crs) { crs.value = String(data.coarse || 0); if (crsV) crsV.textContent = `${data.coarse || 0} steps`; }
                        } catch(_) {}
                    };
                    syncOscUi(1, this.oscillators.osc1);
                    syncOscUi(2, this.oscillators.osc2);
                }
                
                console.log(`🎹 Applied piano-locked preset: ${presetId} for ${pianoLockedData.chordName}`);
            }
            
            // Helper to capture exact frequencies from a column's strings when locking
            captureStringFrequencies(columnElement) {
                console.log('?? Capturing exact string frequencies for locked chord');
                const stringElements = columnElement.querySelectorAll('.string');
                const frequencies = [];
                
                stringElements.forEach(stringElement => {
                    // Get exact frequency from the element dataset
                    // This will be the actual frequency value used in playback
                    const freq = parseFloat(stringElement.dataset.frequency);
                    if (!isNaN(freq)) {
                        frequencies.push(freq);
                        console.log(`?? Captured frequency: ${freq.toFixed(2)} Hz`);
                    }
                });
                
                console.log(`?? Total frequencies captured: ${frequencies.length}`);
                return frequencies.length > 0 ? frequencies : null;
            }
            
            // Create strings using exact captured frequencies - guaranteed perfect reproduction
            generateStringsWithExactFrequencies(column, lockedData) {
                console.log('?? Generating strings with EXACT frequencies for perfect reproduction');
                
                // Clear any existing strings
                const stringsContainer = document.createElement('div');
                stringsContainer.className = 'strings-column';
                // Apply subtle root tint gradient matching locked root
                try {
                    const semi = this.stepToSemitone(lockedData.lockedRoot || 0, lockedData.lockedTuning || (this.currentTuning||12));
                    const accent = this.getChromaticColorForSemitone(semi) || '#000000';
                    const tint = (hex => {
                        const m = /^#?([0-9a-f]{6})$/i.exec(hex || '');
                        if (!m) return 'rgba(0,0,0,0)';
                        const n = parseInt(m[1], 16);
                        let r = (n >> 16) & 0xff, g = (n >> 8) & 0xff, b = n & 0xff;
                        r = Math.max(6, Math.floor(r * 0.08));
                        g = Math.max(6, Math.floor(g * 0.08));
                        b = Math.max(6, Math.floor(b * 0.08));
                        return `linear-gradient(to bottom, rgba(${r},${g},${b},0.12), rgba(${r},${g},${b},0.08))`;
                    })(accent);
                    stringsContainer.style.setProperty('--root-tint-gradient', tint);
                    const headerEl = column.querySelector('.extension-header');
                    if (headerEl) headerEl.style.setProperty('--root-tint-gradient', tint);
                } catch (_) {}
                
                // Style the container like main columns
                stringsContainer.style.cssText = `
                    flex: 1;
                    overflow: hidden;
                    padding: 1px;
                    height: calc(100% - 40px);
                    display: flex;
                    flex-direction: column;
                    justify-content: space-evenly;
                `;
                
                // Remove old strings container if exists
                const oldContainer = column.querySelector('.strings-column');
                if (oldContainer) {
                    column.removeChild(oldContainer);
                }
                
                // Create strings using exact frequencies
                lockedData.exactFrequencies.forEach((freq, index) => {
                    const stringElement = document.createElement('div');
                    stringElement.className = 'string';

                    // Store exact frequency for playback - CRITICAL
                    stringElement.dataset.frequency = freq;

                    // Estimate note and octave for display and color calculation
                    const noteInfo = this.estimateNoteFromFrequency(freq);
                    stringElement.dataset.note = noteInfo.note;
                    stringElement.dataset.octave = noteInfo.octave;

                    // Calculate interval from the locked root to get proper color
                    const intervalFromRoot = (noteInfo.note - lockedData.lockedRoot + lockedData.lockedTuning) % lockedData.lockedTuning;
                    const intervalColor = this.getIntervalColor(intervalFromRoot);
                    const baseColor = intervalColor.color;
                    const glowColor = (baseColor && baseColor.toLowerCase() === '#000000') ? '#555555' : baseColor;
                    stringElement.dataset.glowColor = glowColor;

                    // Visible core
                    const core = document.createElement('div');
                    core.className = 'string-core';
                    core.style.background = baseColor;
                    core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;

                    // Tooltip with exact frequency
                    const noteDisplay = this.getNoteNames()[noteInfo.note] || noteInfo.note;
                    stringElement.title = `${noteDisplay}${noteInfo.octave} - LOCKED: ${freq.toFixed(2)}Hz`;

                    // Precompute vibration period
                    const period = this.computeVibrationPeriod(freq, noteInfo.note);
                    core.style.setProperty('--vib-period', period + 'ms');

                    // Click handlers for playback
                    this.addStringPlaybackHandlers(stringElement, freq);

                    // Attach
                    stringElement.appendChild(core);
                    stringsContainer.appendChild(stringElement);
                });
                
                column.appendChild(stringsContainer);
                
                // Add locked icon and visual indication this is using exact frequencies
                const header = column.querySelector('.extension-header');
                if (header) {
                    const chordName = header.querySelector('.chord-name');
                    if (chordName) {
                        chordName.style.color = '#ff9500'; // Bright orange to indicate exact frequency preservation
                        chordName.title = `LOCKED: Using exact frequencies (${lockedData.exactFrequencies.length}) for perfect reproduction`;
                    }
                }
                
                console.log(`?? Generated ${lockedData.exactFrequencies.length} strings with exact frequencies`);
            }
            
            // Helper to add click handlers to strings
            addStringPlaybackHandlers(stringElement, frequency) {
                // Add click handlers for immediate playback
                stringElement.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.playStringNote(frequency, 0); // Use exact frequency

                    // Visual feedback on core
                    const glow = stringElement.dataset.glowColor || '#FFFFFF';
                    const core = stringElement.querySelector('.string-core');
                    if (core) {
                        core.style.transform = 'scaleY(1.3)';
                        core.style.boxShadow = `0 0 6px ${glow}, 0 0 16px ${glow}B3, 0 0 24px ${glow}80`;
                        core.style.filter = 'brightness(1.15)';
                        const stepIndex = parseInt(stringElement.dataset.noteIndex||'0',10);
                        const period = this.computeVibrationPeriod(frequency, stepIndex);
                        core.style.setProperty('--vib-period', period + 'ms');
                        core.classList.add('vibrating');
                        setTimeout(() => core.classList.remove('vibrating'), 220);
                        setTimeout(() => {
                            core.style.transform = 'scaleY(1)';
                            core.style.boxShadow = `0 0 4px ${glow}, 0 0 10px ${glow}AA, 0 0 18px ${glow}66`;
                            core.style.filter = 'brightness(1)';
                        }, 200);
                    }
                });
                
                // Touch support
                stringElement.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.playStringNote(frequency, 0); // Use exact frequency
                });
            }
            
            // ============= PROPER CHORD NAMING SYSTEM =============
            
            // Template library for exact chord recognition, including micro (^/v) variants.
            // Each template defines a name suffix (to append after the root) and an interval list
            // expressed in 12-TET semitones with optional '^'/'v' to indicate +1/-1 EDO step.
            // Example: { name: '7^', intervals: ['0','4^','7','10'] }
            getChordTemplates() {
                // Helper to DRY strings
                const T = [];
                const add = (name, iv) => T.push({ name, intervals: iv });
                // Power/dyads/triads
                add('5', ['0','7']);
                add('b5', ['0','6']);
                add('+', ['0','4','8']);
                add('aug', ['0','4','8']);
                add('dim', ['0','3','6']);
                add('', ['0','4','7']); // major triad
                add('m', ['0','3','7']);
                add('sus2', ['0','2','7']);
                add('sus4', ['0','5','7']);
                // 6ths/7ths/maj7/etc
                add('6', ['0','4','7','9']);
                add('m6', ['0','3','7','9']);
                add('7', ['0','4','7','10']);
                add('m7', ['0','3','7','10']);
                add('maj7', ['0','4','7','11']);
                add('mMaj7', ['0','3','7','11']);
                add('dim7', ['0','3','6','9']);
                add('m7b5', ['0','3','6','10']);
                add('aug7', ['0','4','8','10']);
                // 9ths
                add('9', ['0','4','7','10','14']);
                add('m9', ['0','3','7','10','14']);
                add('maj9', ['0','4','7','11','14']);
                add('mMaj9', ['0','3','7','11','14']);
                add('6/9', ['0','4','7','9','14']);
                add('m6/9', ['0','3','7','9','14']);
                // sus with 7/9
                add('7sus4', ['0','5','7','10']);
                add('9sus4', ['0','5','7','10','14']);
                // altered dominants
                add('7b9', ['0','4','7','10','13']);
                add('7#9', ['0','4','7','10','15']);
                add('7b5', ['0','4','6','10']);
                add('7#5', ['0','4','8','10']);
                add('7alt', ['0','4','8','10','13','15']); // (#5, b9, #9)
                // 11ths / 13ths
                add('11', ['0','4','7','10','14','17']);
                add('m11', ['0','3','7','10','14','17']);
                add('maj11', ['0','4','7','11','14','17']);
                add('mMaj11', ['0','3','7','11','14','17']);
                add('11sus', ['0','5','7','10','14','17']);
                add('13', ['0','4','7','10','14','17','21']);
                add('m13', ['0','3','7','10','14','17','21']);
                add('maj13', ['0','4','7','11','14','17','21']);
                add('mMaj13', ['0','3','7','11','14','17','21']);
                // Micro-root triads (name becomes just root with micro, so empty suffix still OK)
                // We keep them implicit via root note name, no extra template needed.
                // Micro variants (caret up / v down) for common degrees
                add('7^', ['0','4^','7','10']);
                add('7v', ['0','3v','7','10']);
                add('9^', ['0','4','7','10','14^']);
                add('9v', ['0','4','7','10','14v']);
                add('maj9^', ['0','4^','7','11','14']);
                add('mMaj9v', ['0','3','7','11v','14']);
                add('6^', ['0','4^','7','9']);
                add('m6v', ['0','3','7','9v']);
                add('^sus2', ['0','2','7']); // root micro handled by root name; keep suffix distinct
                add('vsus4', ['0','5','7']);
                add('7#11^', ['0','4','7','10','18^']);
                add('7b13v', ['0','4','7','10','20v']);
                add('maj7#11^', ['0','4','7','11','18^']);
                add('m7b5v', ['0','3','6','10']); // symbol carries 'v' to indicate template request
                add('aug7^', ['0','4','8','10']);
                add('dim7v', ['0','3','6','9v']);
                // Add-chords
                add('add9', ['0','4','7','14']);
                add('madd9', ['0','3','7','14']);
                add('add4', ['0','4','7','5']);
                add('madd4', ['0','3','7','5']);
                return T;
            }

            // Convert a 12-TET semitone count (as string; may include '^'/'v') to an EDO step for matching
            _templateSemitoneToStep(semiStr, edo){
                const m = String(semiStr);
                const up = m.endsWith('^');
                const down = m.endsWith('v');
                const core = up || down ? m.slice(0, -1) : m;
                const semi = parseFloat(core) || 0;
                let step = Math.round((semi * edo) / 12);
                if (up) step += 1; else if (down) step -= 1;
                return ((step % edo) + edo) % edo;
            }

            // Attempt to recognize chord by template; returns best match with steps and type
            // { name, steps, matchType: 'exact' | 'subset' } or null
            tryMatchChordTemplate(relativeSteps, edo){
                const uniq = [...new Set(relativeSteps)].map(v=> ((v%edo)+edo)%edo).sort((a,b)=>a-b);
                const containsAll = (a,b)=> b.every(x=> a.includes(x));
                const eqSet = (a,b)=> a.length===b.length && a.every((v,i)=> v===b[i]);
                const templates = this.getChordTemplates();
                let bestSubset = null;
                for (const t of templates) {
                    const steps = t.intervals
                        .map(s=> this._templateSemitoneToStep(s, edo))
                        .map(v=> ((v%edo)+edo)%edo);
                    const uniqT = [...new Set(steps)].sort((a,b)=>a-b);
                    if (eqSet(uniq, uniqT)) return { name: t.name, steps: uniqT, matchType: 'exact' };
                    if (containsAll(uniq, uniqT)) {
                        if (!bestSubset || uniqT.length > bestSubset.steps.length) {
                            bestSubset = { name: t.name, steps: uniqT, matchType: 'subset' };
                        }
                    }
                }
                return bestSubset;
            }
            
            getProperChordSymbol(intervals) {
                if (!intervals || intervals.length === 0) return '';
                
                // Sort intervals and remove duplicates (EDO steps, relative to chosen root)
                const uniqueIntervals = [...new Set(intervals)].sort((a, b) => a - b);
                const numNotes = uniqueIntervals.length;
                const edo = this.currentTuning || 12;
                
                // Helper: map semitone target to EDO step and compute accidentals for deltas
                const stepForSemi = (semi)=> ((Math.round((semi*edo)/12))%edo+edo)%edo;
                const accidentalForDiff = (d)=> d===0?'':(d===1?'^':(d===-1?'v':(d===2?'#':(d===-2?'b':''))));
                const near = (x,y,tol=0.35)=> Math.abs(x-y) <= tol;
                const sFloat = (st)=> (st*12)/edo;
                // Allow calling hasNear(target[, tol]) by defaulting to uniqueIntervals when set not passed
                const hasNear = (maybeSet, target, tol=0.35)=> {
                    const arr = Array.isArray(maybeSet) ? maybeSet : uniqueIntervals;
                    const tgt = Array.isArray(maybeSet) ? target : maybeSet;
                    const tolVal = Array.isArray(maybeSet) ? tol : (typeof target === 'number' ? target : 0.35);
                    // If called as hasNear(target[, tol]) then tol comes in as second/third arg; normalize
                    const finalTol = Array.isArray(maybeSet)
                        ? tolVal
                        : (arguments.length >= 2 ? target : 0.35);
                    const finalTarget = Array.isArray(maybeSet) ? target : maybeSet;
                    return arr.some(i => near(sFloat(i), finalTarget, finalTol));
                };
                const removeSteps = (src,rm)=> src.filter(x=> !rm.includes(x));
                const uniqSteps = (arr)=> [...new Set(arr)].sort((a,b)=>a-b);

                // First: try template (exact or best subset)
                let baseName = '';
                let baseSteps = [];
                try {
                    const m = this.tryMatchChordTemplate(uniqueIntervals, edo);
                    if (m && m.matchType === 'exact') return m.name; // perfect match
                    if (m) { baseName = m.name; baseSteps = m.steps.slice(); }
                } catch(_) {}
                
                // Map to 12-TET pitch classes relative to the chosen root
                const pcs12 = [...new Set(uniqueIntervals.map(i => this.stepToSemitone(i, edo)))].sort((a,b)=>a-b);
                const has = (x)=> pcs12.includes(x);
                // Compare ignoring order by sorting the candidate array
                const setEq = (arr)=>{
                    const a = [...arr].sort((x,y)=> x-y);
                    return a.length===pcs12.length && a.every((v,i)=> v===pcs12[i]);
                };

                // Float semitone approximations for neutral detection
                const relSemi = uniqueIntervals.map(i => (i * 12) / edo);

                // 🎵 UNISON (single note) - only root note
                if (numNotes === 1 && uniqueIntervals[0] === 0) {
                    return 'Unison';
                }
                
                // 🎵 DYADS (2-note intervals) - adjusted for current tuning
                if (numNotes === 2 && uniqueIntervals[0] === 0) {
                    const interval12TET = pcs12[1] ?? 0;
                    
                    const intervalNames = {
                        1: 'Minor 2nd',
                        2: 'Major 2nd', 
                        3: 'Minor 3rd',
                        4: 'Major 3rd',
                        5: 'Perfect 4th',
                        6: 'Tritone',
                        7: 'Perfect 5th',
                        8: 'Minor 6th',
                        9: 'Major 6th',
                        10: 'Minor 7th',
                        11: 'Major 7th'
                    };
                    
                    return intervalNames[interval12TET] || `${interval12TET} semitones`;
                }
                
                // 🎵 TRIADS (3-note chords) - inversion-invariant
                if (pcs12.length === 3) {
                    // Neutral triad: ~3.5 and ~7 present
                    if (hasNear(0.0) && hasNear(3.5) && hasNear(7.0)) return 'n';
                    if (setEq([0,4,7])) return '';
                    if (setEq([0,3,7])) return 'm';
                    if (setEq([0,3,6])) return '°';
                    if (setEq([0,4,8])) return '+';
                    if (setEq([0,2,7])) return 'sus2';
                    if (setEq([0,5,7])) return 'sus4';
                }

                // 🎵 TETRADS (4-note chords) - favor simplest (triad + one extension)
                if (pcs12.length === 4) {
                    // Neutral 7 detection (~10.5)
                    if (hasNear(uniqueIntervals,0.0) && hasNear(uniqueIntervals,7.0) && hasNear(uniqueIntervals,10.5)) {
                        if (hasNear(3.0) || hasNear(3.5)) return 'm7v';
                        if (hasNear(4.0)) return '7v';
                    }
                    // Strict sets relative to chosen root (no inversion search)
                    if (setEq([0,4,7,9]))  return (hasNear(uniqueIntervals,10.0,0.5)? '7':'6');
                    if (setEq([0,3,7,9]))  return (hasNear(uniqueIntervals,10.0,0.5)? 'm7':'m6');
                    if (setEq([0,4,7,10])) return '7';
                    if (setEq([0,3,7,10])) return 'm7';
                    if (setEq([0,4,7,11])) return 'maj7';
                    if (setEq([0,3,7,11])) return 'mMaj7';
                    if (setEq([0,5,7,10])) return '7sus4';
                    if (setEq([0,3,6,10])) return 'ø7';
                    if (setEq([0,3,6,9]))  return '°7';
                    // Add chords (no 7 or 6)
                    if (setEq([0,2,4,7]))  return 'add9';
                    if (setEq([0,3,7,2]))  return 'madd9';
                    if (setEq([0,4,5,7]))  return 'add4';
                    if (setEq([0,3,5,7]))  return 'madd4';
                }
                
                // 🎵 5-NOTE CHORDS - keep minimal; prefer single extension naming
                if (numNotes === 5) {
                    const eq = (...arr)=> setEq(arr);
                    if (eq(0,3,7,10,2)) return 'm9';
                    if (eq(0,4,7,10,2)) return '9';
                    if (eq(0,3,7,5,2))  return 'm11';
                    if (eq(0,4,7,5,2))  return '11';
                    if (eq(0,3,7,2))    return 'madd9';
                    if (eq(0,4,7,2))    return 'add9';
                }
                
                // 🎵 6-NOTE CHORDS - cap at 11/13 families, still minimal
                if (numNotes === 6) {
                    const eq = (...a)=> setEq(a);
                    if (eq(0,3,7,10,2,5)) return 'm11';
                    if (eq(0,4,7,10,2,5)) return '11';
                    if (eq(0,3,7,10,2,9)) return 'm13';
                    if (eq(0,4,7,10,2,9)) return '13';
                }
                
                // Build a base symbol via minimal core if no template subset chosen
                if (!baseName) {
                    const core = this.findCoreChord(uniqueIntervals);
                    baseName = core.symbol;
                    baseSteps = core.intervals.map(semi=> stepForSemi(semi));
                }

                // Append add-extensions for any remaining tones not covered by base
                const extraSteps = removeSteps(uniqueIntervals, uniqSteps(baseSteps));
                if (!extraSteps.length) return baseName;

                // Context flags
                const hasMaj3 = hasNear(uniqueIntervals,4.0);
                const hasMin3 = hasNear(uniqueIntervals,3.0);
                const hasB7 = hasNear(uniqueIntervals,10.0);
                const hasMaj7 = hasNear(uniqueIntervals,11.0);

                const addParts = [];
                for (const st of extraSteps) {
                    const sf = sFloat(st);
                    // Special case: major triad plus ~3.0 -> #9
                    if (hasMaj3 && near(sf,3.0,0.5)) {
                        const base = stepForSemi(15);
                        let d = st - base; if (d>edo/2) d-=edo; if (d<-edo/2) d+=edo; d = Math.max(-2, Math.min(2, d));
                        const acc = accidentalForDiff(d);
                        addParts.push(`add${acc}#9`); // keep #9 label, include micro if any
                        continue;
                    }
                    // Map to 9 family
                    const base9 = stepForSemi(14);
                    const d9 = (()=>{ let d=st-base9; if(d>edo/2)d-=edo; if(d<-edo/2)d+=edo; return d; })();
                    if (Math.abs(d9) <= 2 && near(sf,2.0,1.0)) {
                        const acc = accidentalForDiff(Math.max(-2, Math.min(2, d9)));
                        const qual = acc==='#'?'#':(acc==='b'?'b':acc); // '^'/'v' retained
                        addParts.push(`add${acc?acc:''}9`);
                        continue;
                    }
                    // Map to 4 family (use 4 naming, not 11)
                    const base4 = stepForSemi(5);
                    const d4 = (()=>{ let d=st-base4; if(d>edo/2)d-=edo; if(d<-edo/2)d+=edo; return d; })();
                    if (Math.abs(d4) <= 2 && near(sf,5.0,1.0)) {
                        const acc = accidentalForDiff(Math.max(-2, Math.min(2, d4)));
                        addParts.push(`add${acc?acc:''}4`);
                        continue;
                    }
                    // Map to 13/6 family
                    const base13 = stepForSemi(21);
                    const d13 = (()=>{ let d=st-base13; if(d>edo/2)d-=edo; if(d<-edo/2)d+=edo; return d; })();
                    if (Math.abs(d13) <= 2 && near(sf,9.0,1.0)) {
                        const acc = accidentalForDiff(Math.max(-2, Math.min(2, d13)));
                        const deg = (hasB7||hasMaj7)? '13':'6';
                        addParts.push(`add${acc?acc:''}${deg}`);
                        continue;
                    }
                    // b9
                    if (near(sf,1.0,0.6)) { addParts.push('addb9'); continue; }
                    // #11 as fallback for tritone-ish
                    if (near(sf,6.0,0.6)) { addParts.push('add#4'); continue; }

                    // Generic fallback: produce add with degree and micro (^/v) when applicable
                    const s12 = ((Math.round((sf)) % 12) + 12) % 12; // nearest semitone
                    const baseForS = stepForSemi(s12);
                    let diff = st - baseForS; if (diff>edo/2) diff-=edo; if (diff<-edo/2) diff+=edo;
                    const micro = diff>0 ? '^' : (diff<0 ? 'v' : '');
                    // Degree label map by semitone
                    const degMap = ['1','b2','2','b3','3','4','#4','5','#5','6','b7','7'];
                    const degree = degMap[s12] || String(s12);
                    addParts.push(`add${micro}${degree}`);
                }
                return baseName + (addParts.length? addParts.join('') : '');
            }
            
            findNearestChordFit(intervals) {
                // Minimal nearest: triad + the single simplest added degree (9 or 11). Avoid piling on.
                const core = this.findCoreChord(intervals);
                const coreSet = new Set(core.intervals);
                // candidates in minimal order
        const order = [2,5,9,10,11]; // 9, 11, 13(=6/13 approx), b7, M7
                for (const iv of order) {
                    if (intervals.includes(iv) && !coreSet.has(iv)) {
            if (core.symbol === 'm' && iv === 5) return 'madd11';
            if (core.symbol === '' && iv === 5) return 'add11';
                        if (iv === 2) return (core.symbol === 'm') ? 'madd9' : 'add9';
                        if (iv === 10) return (core.symbol === 'm') ? 'm7' : '7';
                        if (iv === 11) return (core.symbol === 'm') ? 'mΔ7' : 'Δ7';
                    }
                }
                return core.symbol;
            }
            
            findCoreChord(intervals) {
                // Find the best matching triad or tetrad
                const intervalSet = new Set(intervals);
                
                // Check tetrads first (more specific)
                const tetrads = [
                    { intervals: [0, 3, 7, 5], symbol: 'madd11' },
                    { intervals: [0, 4, 7, 5], symbol: 'add11' },
                    { intervals: [0, 3, 7, 2], symbol: 'madd9' },
                    { intervals: [0, 4, 7, 2], symbol: 'add9' },
                    { intervals: [0, 3, 7, 10], symbol: 'm7' },
                    { intervals: [0, 4, 7, 10], symbol: '7' },
                    { intervals: [0, 4, 7, 9], symbol: '6' },
                    { intervals: [0, 3, 7, 9], symbol: 'm6' },
                    { intervals: [0, 3, 6, 10], symbol: 'ø7' },
                    { intervals: [0, 3, 6, 9], symbol: '°7' }
                ];
                
                for (const tetrad of tetrads) {
                    if (tetrad.intervals.every(interval => intervalSet.has(interval))) {
                        return tetrad;
                    }
                }
                
                // Check triads
                const triads = [
                    { intervals: [0, 4, 7], symbol: '' }, // Major = simplest, no suffix
                    { intervals: [0, 3, 7], symbol: 'm' },
                    { intervals: [0, 3, 6], symbol: '°' },
                    { intervals: [0, 4, 8], symbol: '+' },
                    { intervals: [0, 2, 7], symbol: 'sus2' },
                    { intervals: [0, 5, 7], symbol: 'sus4' }
                ];
                
                for (const triad of triads) {
                    if (triad.intervals.every(interval => intervalSet.has(interval))) {
                        return triad;
                    }
                }
                
                // Default to neutral minimal
                return { intervals: [0], symbol: '' };
            }
            
            findExtensions(intervals, coreIntervals) {
                const extensions = [];
                const coreSet = new Set(coreIntervals);
                
                for (const interval of intervals) {
                    if (!coreSet.has(interval) && interval !== 0) {
                        // Convert interval to extension name
                        const extName = this.intervalToExtensionName(interval);
                        if (extName) extensions.push(extName);
                    }
                }
                
                return extensions;
            }
            
            intervalToExtensionName(interval) {
                const extensionMap = {
                    1: '♭9', 2: '9', 3: '♯9', 4: '3', 5: '11', 6: '♯11',
                    7: '5', 8: '♭13', 9: '6/13', 10: '♭7', 11: '7'
                };
                return extensionMap[interval] || interval.toString();
            }
            
            // Estimate note and octave from frequency (for display only)
            estimateNoteFromFrequency(freq) {
                // A4 = 440 Hz is our reference
                const a4 = 440.0;
                const a4NoteNumber = 69; // MIDI note number for A4
                
                // Calculate MIDI note number from frequency
                const noteNumber = 12 * Math.log2(freq / a4) + a4NoteNumber;
                const roundedNoteNumber = Math.round(noteNumber);
                
                // Convert MIDI note number to note and octave
                const octave = Math.floor((roundedNoteNumber - 12) / 12);
                const note = roundedNoteNumber % 12;
                
                return { note, octave };
            }
            
            editLockedChord(chordData, columnElement) {
                // Get the locked chord data to extract the intervals
                const lockedChord = this.lockedChords.get(columnElement);
                if (!lockedChord) {
                    alert('This chord must be locked before it can be edited');
                    return;
                }
                
                console.log('? Editing locked chord:', chordData.name, 'with intervals:', lockedChord.intervals);
                
                // Enter chord creation mode with the locked chord's intervals
                this.enterChordCreationMode();
                
                // Set the intervals from the locked chord
                this.selectedIntervals = [...(lockedChord.intervals || [])];
                
                // Update the note selector to show these intervals
                // Refresh interval selection UI and preview column in builder
                this.updateIntervalButtons();
                this.updatePreviewChordColumn();
                
                // Show the chord name input with current name
                const modal = document.getElementById('chordBuilderModal');
                if (modal) {
                    modal.style.display = 'block';
                    const nameInput = document.getElementById('chordNameInput');
                    if (nameInput) {
                        nameInput.value = chordData.name;
                    }
                }
                
                console.log('? Chord edit mode activated with existing intervals');
            }
            
            hideLockedChord(chordData, columnElement) {
                if (!this.hiddenColumns) this.hiddenColumns = [];
                
                const chordId = chordData.id || chordData.name.toLowerCase().replace(/\s+/g, '_');
                
                if (confirm(`Hide the locked chord "${chordData.name}"? You can show it again from the settings.`)) {
                    // Add to hidden columns
                    if (!this.hiddenColumns.includes(chordId)) {
                        this.hiddenColumns.push(chordId);
                        // localStorage removed - no longer saving hidden columns
                    }
                    
                    // Regenerate columns to hide this one
                    this.generateExtensionColumns();
                    
                    console.log('?? Hidden locked chord:', chordData.name);
                }
            }
            
            duplicateLockedChord(chordData, columnElement) {
                // Get the locked chord data
                const lockedChord = this.lockedChords.get(columnElement);
                if (!lockedChord) {
                    alert('This chord must be locked before it can be duplicated');
                    return;
                }
                
                console.log('? Duplicating locked chord:', chordData.name, 'with intervals:', lockedChord.intervals);
                
                // Create a new chord extension with a copy name
                const duplicateChord = {
                    name: chordData.name + ' Copy',
                    intervals: [...(lockedChord.intervals || [])],
                    extensions: [...(chordData.extensions || [])],
                    quality: chordData.quality || 'major',
                    isCustom: true,
                    id: 'duplicate_' + Date.now()
                };
                
                // Add to chord extensions
                this.chordExtensions.push(duplicateChord);
                this.saveChordConfiguration();
                
                // Regenerate columns
                this.generateExtensionColumns();
                
                console.log('? Duplicated chord:', duplicateChord.name);
            }
            
            // Generic functions that work for ALL chords (not just locked ones)
            editChordFromButton() { /* removed: live edit via keyboard */ }
            
            hideChordFromButton(chordData, columnElement) {
                // Repurpose as Delete Chord
                console.log('🗑️ DELETE for:', chordData?.name);
                if (!chordData || !chordData.name) {
                    alert('Error: Invalid chord data for delete');
                    return;
                }
                if (!confirm(`Delete the chord "${chordData.name}"? This cannot be undone.`)) return;
                const idx = this.getIndexFromColumn(columnElement, chordData);
                if (idx !== -1) {
                    this.chordExtensions.splice(idx, 1);
                    this.normalizeChordPositions();
                }
                this.generateExtensionColumns();
            }
            
            duplicateChordFromButton(chordData, columnElement) {
                console.log('📋 DUPLICATE for:', chordData?.name);
                if (!chordData || !chordData.name) {
                    alert('Error: Invalid chord data for duplication');
                    return;
                }
                // Find base chord and position
                const idx = this.getIndexFromColumn(columnElement, chordData);
                const base = (idx !== -1 && this.chordExtensions[idx]) ? this.chordExtensions[idx] : chordData;
                const intervals = (base.intervals && base.intervals.length)
                    ? [...base.intervals]
                    : (this.getBaseTriadForQuality(this.stripRootFromName(base.name).toLowerCase()) || [0,4,7]);

                const newChord = {
                    name: `${base.name} Copy`,
                    intervals: intervals,
                    extensions: Array.isArray(base.extensions) ? [...base.extensions] : [],
                    quality: base.quality || 'major',
                    isCustom: true,
                    id: `duplicate_${Date.now()}_${Math.floor(Math.random()*1e6)}`
                };
                const insertAt = (idx !== -1) ? (idx + 1) : this.chordExtensions.length;
                this.chordExtensions.splice(insertAt, 0, newChord);
                this.normalizeChordPositions?.();
                this.generateExtensionColumns();
            }

            // --- Helpers to robustly find the clicked chord in this.chordExtensions ---
            findChordIndex(chordData) {
                // Prefer exact id match
                if (chordData && chordData.id) {
                    const byId = this.chordExtensions.findIndex(ext => ext && ext.id === chordData.id);
                    if (byId !== -1) return byId;
                }
                // Fallback: name + intervals match
                const intervals = (chordData && (chordData.intervals || chordData.notes)) || [];
                const key = JSON.stringify(intervals);
                const byStruct = this.chordExtensions.findIndex(ext => {
                    if (!ext) return false;
                    if (ext.name !== chordData.name) return false;
                    const extIntervals = ext.intervals || [];
                    return JSON.stringify(extIntervals) === key;
                });
                if (byStruct !== -1) return byStruct;
                // Last resort: position if present
                if (typeof chordData.position === 'number') return chordData.position;
                return -1;
            }

            getIndexFromColumn(columnElement, chordData) {
                // First trust the dataset from the DOM column created with this chord
                const ds = columnElement && columnElement.dataset ? columnElement.dataset : {};
                if (ds && typeof ds.originalPosition !== 'undefined') {
                    const idx = parseInt(ds.originalPosition, 10);
                    if (!Number.isNaN(idx) && idx >= 0 && idx < this.chordExtensions.length) return idx;
                }
                // Then try to calculate from chordData
                const fallbackIdx = this.findChordIndex(chordData);
                if (fallbackIdx !== -1) return fallbackIdx;
                // Give up gracefully
                return -1;
            }
            
            findChordPosition(chordData) {
                // Find the position of this chord in the chordExtensions array
                for (let i = 0; i < this.chordExtensions.length; i++) {
                    const chord = this.chordExtensions[i];
                    if (chord.name === chordData.name && 
                        chord.id === chordData.id ||
                        (chord.isCustom === chordData.isCustom && chord.name === chordData.name)) {
                        return i;
                    }
                }
                return this.chordExtensions.length; // Default to end if not found
            }

            // Remove pitch-class prefix from chord names (e.g., "Csus4" -> "sus4")
            stripRootFromName(name) {
                if (!name) return '';
                return String(name).replace(/^[A-G][#b]?\s*/, '').trim();
            }
            
            applyLockedChordSettings(lockedChord) {
                console.log('?? Applying locked chord settings:', lockedChord);
                
                // Apply locked musical settings (MOST IMPORTANT - the locked root!)
                this.currentRoot = lockedChord.lockedRoot;
                this.currentQuality = lockedChord.quality;
                this.currentTuning = lockedChord.lockedTuning;
                this.gamelanMode = lockedChord.lockedGamelanMode;
                
                // Apply locked oscillator settings
                this.oscillators.osc1 = { ...lockedChord.lockedOsc1 };
                this.oscillators.osc2 = { ...lockedChord.lockedOsc2 };
                
                // Apply locked envelope settings
                this.envelope = { ...lockedChord.lockedEnvelope };
                this.osc2Envelope = { ...lockedChord.lockedOsc2Envelope };
                
                // Apply locked effects settings
                this.reverbWet = lockedChord.lockedEffects.reverbWet;
                if (this.reverb) this.reverb.decay = lockedChord.lockedEffects.reverbDecay;
                if (this.reverbFilterNode) this.reverbFilterNode.frequency.value = lockedChord.lockedEffects.reverbFilterCutoff;
                this.panning.mode = lockedChord.lockedEffects.panningMode;
                this.panning.width = lockedChord.lockedEffects.panningWidth;
                
                // Apply locked volume settings
                this.masterVolume = lockedChord.lockedVolume.master;
                this.volume = lockedChord.lockedVolume.main;
                
                console.log('?? Applied locked settings - root:', this.currentRoot, 'tuning:', this.currentTuning, 'quality:', this.currentQuality);
            }
            
            loadLockedChords() {
                // No localStorage - always return empty (start fresh each session)
                return null;
            }
            
            restoreLockedChordStates() {
                if (!this.savedLockedChords || this.savedLockedChords.length === 0) {
                    console.log('?? No saved locked chords to restore');
                    return;
                }
                
                // Ensure lockedChords Map is initialized
                if (!this.lockedChords) this.lockedChords = new Map();
                
                console.log('?? Restoring locked chord states for', this.savedLockedChords.length, 'locked chords');
                
                // After columns are generated, restore locked states using position-based matching
                this.savedLockedChords.forEach((lockedChord, index) => {
                    console.log('?? Restoring locked chord:', lockedChord.chordName, 'at position:', lockedChord.originalPosition);
                    
                    // Find the matching column element by position and chord data
                    const columns = Array.from(document.querySelectorAll('.extension-column'));
                    
                    // Method 1: Try position-based matching first (most reliable)
                    let targetColumn = null;
                    if (lockedChord.originalPosition !== undefined && columns[lockedChord.originalPosition]) {
                        targetColumn = columns[lockedChord.originalPosition];
                        console.log('?? Using position-based match at index', lockedChord.originalPosition);
                    }
                    
                    // Method 2: If position doesn't work, try finding by chord data
                    if (!targetColumn) {
                        targetColumn = columns.find(column => {
                            const chordType = column.dataset.chordType;
                            const header = column.querySelector('.extension-header');
                            const chordName = header?.querySelector('.chord-name');
                            
                            if (chordName) {
                                const currentText = chordName.textContent.trim();
                                console.log('?? Checking column with text:', currentText, 'against locked chord:', lockedChord.chordName);
                                return this.isChordMatch(currentText, lockedChord);
                            }
                            return false;
                        });
                        
                        if (targetColumn) {
                            console.log('?? Using name-based match');
                        }
                    }
                    
                    // Method 3: If still no match, try by original chord extension index
                    if (!targetColumn && lockedChord.originalPosition !== undefined) {
                        // Find chord extension that matches the locked chord
                        const matchingExtension = this.chordExtensions.find(ext => 
                            ext.name === lockedChord.chordName || 
                            (ext.isCustom && ext.id && lockedChord.lockId && lockedChord.lockId.includes(ext.id))
                        );
                        
                        if (matchingExtension) {
                            const extensionIndex = this.chordExtensions.indexOf(matchingExtension);
                            if (columns[extensionIndex]) {
                                targetColumn = columns[extensionIndex];
                                console.log('?? Using extension-based match at index', extensionIndex);
                            }
                        }
                    }
                    
                    if (targetColumn) {
                        console.log('?? Found matching column for:', lockedChord.chordName);
                        
                        // Restore the locked state
                        this.lockedChords.set(targetColumn, lockedChord);
                        
                        // No lock/duplicate/edit/hide buttons to update anymore
                        
                        // Update visual styling and show locked root in name (respect per-column local transpose)
                        const chordNameElement = targetColumn.querySelector('.chord-name');
                        if (chordNameElement) {
                            chordNameElement.style.color = '#4CAF50';
                            chordNameElement.style.fontWeight = 'bold';
                            const edo = lockedChord.lockedTuning || this.currentTuning || 12;
                            const localDelta = ((+targetColumn.dataset.localTranspose || 0) % edo + edo) % edo;
                            const effRoot = ((lockedChord.lockedRoot ?? 0) + localDelta + edo) % edo;
                            const rootName = this.getRootNameForStep(effRoot, edo);
                            
                            // ALWAYS show the locked root in the chord name
                            if (lockedChord.chordName.match(/^[A-G][#b]?/)) {
                                // Already has root in name (like "CMaj6"), keep it exactly as locked
                                chordNameElement.textContent = lockedChord.chordName;
                            } else {
                                // Standard chord name, prepend the locked root
                                chordNameElement.textContent = `${rootName}${lockedChord.chordName}`;
                            }
                            
                            chordNameElement.title = `?? LOCKED: ${rootName} root, ${lockedChord.lockedTuning}TET, ${lockedChord.lockedOsc1.type}/${lockedChord.lockedOsc2.type} waves`;
                            
                            // Mark the effective locked label so future ops parse the correct root
                            chordNameElement.dataset.isLocked = 'true';
                            chordNameElement.dataset.lockedName = chordNameElement.textContent;
                        }
                        
                        console.log('?? Successfully restored locked chord:', lockedChord.chordName, 'at position', lockedChord.originalPosition);
                    } else {
                        console.warn('?? Could not find matching column for locked chord:', lockedChord.chordName, 'position:', lockedChord.originalPosition);
                        console.warn('?? Available columns:', columns.length, 'chord extensions:', this.chordExtensions.length);
                    }
                });
                
                console.log('?? Finished restoring locked chord states. Active locked chords:', this.lockedChords.size);
            }
            
            isChordMatch(currentText, lockedChord) {
                const chordBaseName = lockedChord.chordName;
                
                // Exact match (for custom chords like "CMaj6")
                if (currentText === chordBaseName) {
                    return true;
                }
                // Partial match (for complex chord names)
                if (currentText.includes(chordBaseName) || chordBaseName.includes(currentText)) {
                    return true;
                }
                // Quality-based match (for standard chords)
                if (lockedChord.quality && (
                    currentText.toLowerCase().includes(lockedChord.quality.toLowerCase()) ||
                    currentText.includes('Maj') && lockedChord.quality.includes('major') ||
                    currentText.includes('Min') && lockedChord.quality.includes('minor') ||
                    currentText.includes('Neu') && lockedChord.quality.includes('neutral')
                )) {
                    return true;
                }
                return false;
            }
            
            clearLockedChords() {
                if (confirm('Clear all locked chords?')) {
                    // Clear the locked chords map
                    this.lockedChords = new Map();
                    
                    // Clear localStorage
                    // localStorage removed
                    
                    // Reset all lock buttons to unlocked state
                    document.querySelectorAll('.lock-button').forEach(button => {
                        button.innerHTML = '🔓';
                        button.classList.remove('locked');
                        button.title = 'Lock chord with current root & settings';
                    });
                    
                    // Reset chord header colors to indicate unlocked
                    document.querySelectorAll('.extension-header .chord-name').forEach(chordName => {
                        chordName.style.color = '#fff'; // Reset to default color
                        chordName.title = ''; // Clear locked indicator
                    });
                    
                    console.log('?? All locked chords cleared from main grid');
                }
            }

            playPaletteChord(chord) {
                // Use locked settings from when the chord was dragged
                const originalRoot = this.currentRoot;
                const originalQuality = this.currentQuality;
                const originalTuning = this.currentTuning;
                const originalGamelanMode = this.gamelanMode;
                
                // Temporarily switch to the chord's locked settings
                this.currentRoot = chord.lockedRoot || chord.root;
                this.currentQuality = chord.quality;
                if (chord.lockedTuning !== undefined) {
                    this.currentTuning = chord.lockedTuning;
                }
                if (chord.lockedGamelanMode !== undefined) {
                    this.gamelanMode = chord.lockedGamelanMode;
                }
                
                // Generate intervals for this chord using locked settings
                let intervals;
                if (chord.intervals) {
                    // Custom chord with specific intervals (already in native tuning)
                    intervals = chord.intervals.map(interval => 
                        (this.currentRoot + interval) % this.currentTuning
                    );
                } else {
                    // Standard chord with extensions
                    const chordIntervals = this.getChordIntervals(chord.extensions);
                    intervals = chordIntervals.map(interval => 
                        (this.currentRoot + interval) % this.currentTuning
                    );
                }
                
                // Play the chord for 1 second with proper ADSR routing
                const baseOctave = 4;
                intervals.forEach(step => {
                    const freq = this.getFrequency(step, baseOctave, this.currentTuning);
                    // Create a dummy element for proper ADSR handling
                    const dummyElement = { classList: { add: () => {}, remove: () => {} } };
                    this.playFrequency(freq, dummyElement);
                });
                
                // Stop all notes after 1 second
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 1000);
                
                // Restore original settings
                this.currentRoot = originalRoot;
                this.currentQuality = originalQuality;
                this.currentTuning = originalTuning;
                this.gamelanMode = originalGamelanMode;
                
                console.log(`Played chord: ${chord.fullName} (${chord.tuningName || 'current tuning'})`);
            }

            renameColumn() {
                const newName = prompt('Enter new column name:', this.currentEditingColumn.name);
                if (newName && newName.trim()) {
                    this.currentEditingColumn.name = newName.trim();
                    this.updateColumnInStorage();
                    this.generateExtensionColumns();
                }
            }

            copyColumn() {
                // Create a copy of the current column as a new chord extension (not custom chord)
                const baseName = this.currentEditingColumn.originalName || this.currentEditingColumn.name.replace(/^(Maj|Neu|Min)/, '');
                const columnCopy = {
                    name: `${baseName} Copy`,
                    extensions: [...(this.currentEditingColumn.extensions || [])],
                    intervals: this.currentEditingColumn.intervals || null
                };
                
                // Add to chord extensions so it gets all 3 flavors
                this.chordExtensions.push(columnCopy);
                this.saveChordConfiguration();
                this.generateExtensionColumns();
                
                console.log(`Copied column: ${columnCopy.name}`);
            }

            editColumnPattern() {
                const modal = document.getElementById('editPatternModal');
                const title = document.getElementById('editPatternTitle');
                const nameInput = document.getElementById('editPatternName');
                
                title.textContent = `Edit Pattern: ${this.currentEditingColumn.name}`;
                nameInput.value = this.currentEditingColumn.name;
                
                this.setupIntervalEditor();
                modal.style.display = 'block';
            }

            setupIntervalEditor() {
                const editor = document.getElementById('intervalEditor');
                editor.innerHTML = '';
                
                // Create interval input fields for common intervals
                const intervals = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
                
                intervals.forEach(interval => {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `interval_${interval}`;
                    checkbox.value = interval;
                    
                    const label = document.createElement('label');
                    label.htmlFor = `interval_${interval}`;
                    label.textContent = interval;
                    label.style.cssText = 'display: flex; align-items: center; gap: 5px; padding: 5px; background: #16213e; border-radius: 3px; cursor: pointer;';
                    
                    label.prepend(checkbox);
                    editor.appendChild(label);
                });
            }

            setQuickPattern(intervals) {
                // Convert 12TET intervals to current tuning system
                const currentTuning = this.getTuningStepsPerOctave();
                const convertedIntervals = intervals.map(interval => {
                    // Convert from 12TET to current tuning
                    return Math.round((interval / 12) * currentTuning);
                });
                
                console.log(`?? Converting intervals from 12TET ${intervals} to ${currentTuning}EDO: ${convertedIntervals}`);
                
                // Clear all checkboxes
                document.querySelectorAll('#intervalEditor input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                
                // Check the converted intervals
                convertedIntervals.forEach(interval => {
                    const checkbox = document.getElementById(`interval_${interval}`);
                    if (checkbox) {
                        checkbox.checked = true;
                        console.log(`? Checked interval ${interval} in ${currentTuning}EDO`);
                    }
                });
                
                // Also update the chord creation mode if active
                if (this.chordCreationMode) {
                    this.selectedIntervals = [...convertedIntervals];
                    this.updateIntervalButtons();
                    this.updatePreviewChordColumn();
                }
            }

            saveEditedPattern() {
                const nameInput = document.getElementById('editPatternName');
                const selectedIntervals = Array.from(document.querySelectorAll('#intervalEditor input[type="checkbox"]:checked'))
                    .map(cb => parseInt(cb.value))
                    .sort((a, b) => a - b);

                if (selectedIntervals.length === 0) {
                    alert('Please select at least one interval.');
                    return;
                }

                // Update the column
                this.currentEditingColumn.name = nameInput.value;
                this.currentEditingColumn.intervals = selectedIntervals;
                
                this.updateColumnInStorage();
                document.getElementById('editPatternModal').style.display = 'none';
                this.generateExtensionColumns();
            }

            moveColumn(direction) {
                const currentId = this.currentEditingColumn.id || this.currentEditingColumn.name.toLowerCase();
                const currentIndex = this.chordExtensions.findIndex(ext => 
                    ext.name.toLowerCase() === currentId || ext.name === this.currentEditingColumn.name
                );
                
                if (currentIndex === -1) return;
                
                const newIndex = currentIndex + direction;
                if (newIndex < 0 || newIndex >= this.chordExtensions.length) return;
                
                // Swap the chord extensions
                [this.chordExtensions[currentIndex], this.chordExtensions[newIndex]] = 
                [this.chordExtensions[newIndex], this.chordExtensions[currentIndex]];
                
                // Save configuration
                this.saveChordConfiguration();
                
                // Regenerate columns
                this.generateExtensionColumns();
                
                console.log(`Moved column ${this.currentEditingColumn.name} ${direction > 0 ? 'right' : 'left'}`);
            }

            loadChordConfiguration() {
                // No localStorage - always return null (start fresh each session)
                return null;
            }

            saveChordConfiguration() {
                // No localStorage - update session data instead
                this.sessionData.chordExtensions = this.chordExtensions;
                console.log('?? Chord configuration updated in session data');
            }
            
            // ============= OMG FILE SYSTEM =============
            
            saveSessionToFile() {
                // Collect all session data
                const sessionData = {
                    version: "1.0",
                    timestamp: Date.now(),
                    customChords: this.customChords,
                    favoriteChords: this.favoriteChords,
                    paletteChords: this.paletteChords,
                    lockedSonicChords: this.lockedSonicChords,
                    hiddenColumns: this.hiddenColumns,
                    chordExtensions: this.chordExtensions,
                    lockedChords: this.lockedChords ? Array.from(this.lockedChords.values()) : [],
                    currentTuning: this.currentTuning || 12,
                    gamelanMode: this.gamelanMode || false,
                    currentRoot: this.currentRoot || 0,
                    volume: this.volume || 0.5,
                    masterVolume: this.masterVolume || 1,
                    oscillators: this.oscillators,
                    envelope: this.envelope,
                    osc2Envelope: this.osc2Envelope
                };
                
                const dataStr = JSON.stringify(sessionData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `omnichord-session-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.omg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                console.log('?? Session saved to OMG file');
            }
            
            loadSessionFromFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const sessionData = JSON.parse(e.target.result);
                            
                            // Restore all data
                            this.customChords = sessionData.customChords || [];
                            this.favoriteChords = sessionData.favoriteChords || [];
                            this.paletteChords = sessionData.paletteChords || [];
                            this.lockedSonicChords = sessionData.lockedSonicChords || [];
                            this.hiddenColumns = sessionData.hiddenColumns || [];
                            this.chordExtensions = sessionData.chordExtensions || [];
                            
                            // Restore locked chords if any
                            if (sessionData.lockedChords && sessionData.lockedChords.length > 0) {
                                // Convert back to Map structure
                                this.savedLockedChords = sessionData.lockedChords;
                            }
                            
                            // Restore settings
                            if (sessionData.currentTuning) {
                                this.currentTuning = sessionData.currentTuning;
                                const tuningSelect = document.getElementById('edoDivisions');
                                if (tuningSelect) tuningSelect.value = sessionData.currentTuning;
                            }
                            
                            if (sessionData.gamelanMode !== undefined) {
                                this.gamelanMode = sessionData.gamelanMode;
                            }
                            
                            if (sessionData.currentRoot !== undefined) {
                                this.currentRoot = sessionData.currentRoot;
                            }
                            
                            // Restore audio settings
                            if (sessionData.oscillators) {
                                this.oscillators = sessionData.oscillators;
                            }
                            if (sessionData.envelope) {
                                this.envelope = sessionData.envelope;
                            }
                            if (sessionData.osc2Envelope) {
                                this.osc2Envelope = sessionData.osc2Envelope;
                            }
                            
                            // Regenerate the interface
                            this.generateExtensionColumns();
                            this.generateRootButtons();
                            
                            console.log('?? Session loaded from OMG file:', sessionData);
                            resolve(sessionData);
                        } catch (error) {
                            console.error('Error loading session file:', error);
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }
            
            promptSaveOnExit() {
                if (confirm('Save current session to OMG file before exiting?')) {
                    this.saveSessionToFile();
                }
            }
            
            clearUnlockedChords() {
                // Remove all unlocked chords, keeping only locked ones
                console.log('??? Clearing all unlocked chords...');
                console.log('?? Before clearing - chord extensions:', this.chordExtensions.length, 'chords:', this.chordExtensions.map(c => c.name));
                
                // Filter to keep only locked chords
                const lockedChords = this.chordExtensions.filter(chord => chord.isLocked && chord.lockedData);
                
                console.log('? Found locked chords:', lockedChords.length, 'chords:', lockedChords.map(c => c.name));
                
                // If no locked chords, start in chord creation mode
                if (lockedChords.length === 0) {
                    console.log('?? No chords available, starting in chord creation mode');
                    // Start empty - user must create chords from scratch
                    this.chordExtensions = [];
                } else {
                    console.log('?? Keeping only locked chords with preserved data');
                    // IMPORTANT: Keep the full locked chord data structure intact
                    this.chordExtensions = lockedChords.map(chord => ({
                        ...chord,
                        // Ensure intervals from locked data are preserved
                        intervals: chord.lockedData?.intervals || chord.intervals,
                        // Preserve all locked settings
                        lockedRoot: chord.lockedData?.lockedRoot,
                        lockedTuning: chord.lockedData?.lockedTuning,
                        lockedGamelanMode: chord.lockedData?.lockedGamelanMode,
                        // Keep the lock state
                        isLocked: true,
                        lockedData: chord.lockedData
                    }));
                }
                
                // Clear any old localStorage keys that might be confusing things
                // localStorage removed // Clear old key
                
                // Save the cleaned configuration
                this.saveChordConfiguration();
                
                console.log('?? After clearing - chord extensions:', this.chordExtensions.length, 'chords:', this.chordExtensions.map(c => c.name));
                
                // Regenerate the display
                this.generateExtensionColumns();
            }

            addColumn() {
                // Show modal to select chord type
                this.showAddColumnModal();
            }

            showAddColumnModal() {
                // Create modal for adding new column
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 800px;">
                        <h3>Add New Chord Column</h3>
                        <div style="display: flex; gap: 20px;">
                            <div style="flex: 1;">
                                <h4>Preset Chords</h4>
                                <div class="add-column-grid">
                                    ${this.availableChordTypes.map(chord => `
                                        <button class="add-chord-btn" data-chord='${JSON.stringify(chord)}'>
                                            ${chord.name}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <h4>Create Custom Chord</h4>
                                <div style="margin-bottom: 15px;">
                                    <label>Chord Name:</label>
                                    <input type="text" id="customChordName" placeholder="My Chord" style="width: 100%; padding: 5px; margin-top: 5px;">
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <label>Select Notes (0-11 semitones):</label>
                                    <div id="noteSelector" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 10px;">
                                        ${Array.from({length: 12}, (_, i) => `
                                            <label style="display: flex; align-items: center; gap: 5px; padding: 8px; background: #333; border-radius: 4px; cursor: pointer;">
                                                <input type="checkbox" value="${i}" class="note-checkbox" style="cursor: pointer;">
                                                <span class="note-label">${this.getNoteNameFromSemitone(i)}</span>
                                                <button type="button" class="preview-btn" data-note="${i}" style="margin-left: auto; padding: 2px 6px; font-size: 10px; background: #555; border: none; color: white; border-radius: 3px; cursor: pointer;">?</button>
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <button type="button" id="previewChord" class="osc-btn" style="width: 100%;">?? Preview Full Chord</button>
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <button type="button" id="createCustomChord" class="osc-btn" style="width: 100%; background: #059669;">Create Custom Chord</button>
                                </div>
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                        </div>
                    </div>
                `;
                
                // Add event listeners for preset chord selection
                modal.querySelectorAll('.add-chord-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const chordData = JSON.parse(e.target.dataset.chord);
                        this.addChordColumn(chordData);
                        modal.remove();
                    });
                });
                
                // Add event listeners for custom chord creation
                const previewButtons = modal.querySelectorAll('.preview-btn');
                previewButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const note = parseInt(e.target.dataset.note);
                        this.previewNote(note);
                    });
                });
                
                const previewChordBtn = modal.querySelector('#previewChord');
                previewChordBtn.addEventListener('click', () => {
                    this.previewSelectedChord(modal);
                });
                
                const createCustomBtn = modal.querySelector('#createCustomChord');
                createCustomBtn.addEventListener('click', () => {
                    this.createCustomChordFromModal(modal);
                });
                
                document.body.appendChild(modal);
                
                // Close on ESC
                const closeOnEsc = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', closeOnEsc);
                    }
                };
                document.addEventListener('keydown', closeOnEsc);
            }

            getNoteNameFromSemitone(semitone) {
                const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                return notes[semitone];
            }

            previewNote(semitone) {
                // Calculate frequency for the note (using C4 as base)
                const baseFreq = 261.626; // C4
                const frequency = baseFreq * Math.pow(2, semitone / 12);
                
                // Play the note briefly
                this.playFrequency(frequency, 0.5); // 0.5 second duration
                
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 500);
            }

            previewSelectedChord(modal) {
                const selectedNotes = Array.from(modal.querySelectorAll('.note-checkbox:checked'))
                    .map(cb => parseInt(cb.value))
                    .sort((a, b) => a - b);
                
                if (selectedNotes.length === 0) {
                    alert('Please select at least one note to preview.');
                    return;
                }
                
                // Play all selected notes as a chord
                const baseFreq = 261.626; // C4
                selectedNotes.forEach(semitone => {
                    const frequency = baseFreq * Math.pow(2, semitone / 12);
                    this.playFrequency(frequency, 1.0); // 1 second duration
                });
                
                setTimeout(() => {
                    this.stopAllActiveNotes();
                }, 1000);
            }

            createCustomChordFromModal(modal) {
                const chordName = modal.querySelector('#customChordName').value.trim();
                const selectedNotes = Array.from(modal.querySelectorAll('.note-checkbox:checked'))
                    .map(cb => parseInt(cb.value))
                    .sort((a, b) => a - b);
                
                if (!chordName) {
                    alert('Please enter a chord name.');
                    return;
                }
                
                if (selectedNotes.length === 0) {
                    alert('Please select at least one note.');
                    return;
                }
                
                // Create custom chord data
                const customChordData = {
                    name: chordName,
                    extensions: [], // Custom chords don't use extensions
                    intervals: selectedNotes,
                    isCustomPattern: true
                };
                
                this.addChordColumn(customChordData);
                modal.remove();
            }

            addChordColumn(chordData) {
                if (chordData.isCustomPattern) {
                    // Handle custom chord with specific intervals
                    if (!this.customChords) this.customChords = [];
                    
                    const customChord = {
                        name: chordData.name,
                        notes: chordData.intervals
                    };
                    
                    this.customChords.push(customChord);
                    // localStorage removed - no longer saving custom chords
                } else {
                    // Handle standard chord extension
                    this.chordExtensions.push({ ...chordData });
                    this.saveChordConfiguration();
                }
                
                // Regenerate columns
                this.generateExtensionColumns();
                
                console.log(`Added new chord column: ${chordData.name}`);
            }

            exportChordConfiguration() {
                const config = {
                    chordExtensions: this.chordExtensions,
                    customChords: this.customChords || [],
                    hiddenColumns: this.hiddenColumns || [],
                    exportDate: new Date().toISOString(),
                    version: '1.0'
                };
                
                const dataStr = JSON.stringify(config, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `microtonal-omnichord-config-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
            }
            
            saveSessionAsOMG() {
                // Save complete session state including all settings and locked chords
                const sessionData = {
                    // Chord data
                    chordExtensions: this.chordExtensions,
                    customChords: this.customChords || [],
                    lockedChords: this.savedLockedChords || Array.from(this.lockedChords?.values() || []),
                    paletteChords: this.paletteChords || [],
                    
                    // Piano lock data - COMPLETE PRESERVATION
                    pianoLockedChords: this.pianoLockedChords ? Array.from(this.pianoLockedChords.entries()) : [],
                    preloadedPresets: this.preloadedPresets ? Array.from(this.preloadedPresets.entries()) : [],
                    pianoLockPresetCounter: this.pianoLockPresetCounter || 0,
                    
                    // UI state
                    hiddenColumns: this.hiddenColumns || [],
                    currentRoot: this.currentRoot,
                    currentTuning: this.currentTuning,
                    gamelanMode: this.gamelanMode,
                    
                    // Audio settings
                    masterVolume: this.masterVolume || 0.7,
                    reverbLevel: this.reverbLevel || 0.3,
                    
                    // Oscillator settings
                    osc1: {
                        type: this.osc1Type || 'sine',
                        attack: this.osc1Attack || 10,
                        decay: this.osc1Decay || 200,
                        sustain: this.osc1Sustain || 70,
                        release: this.osc1Release || 800
                    },
                    osc2: {
                        type: this.osc2Type || 'sine',
                        attack: this.osc2Attack || 5,
                        decay: this.osc2Decay || 30,
                        sustain: this.osc2Sustain || 50,
                        release: this.osc2Release || 1000
                    },
                    
                    // Session metadata
                    savedDate: new Date().toISOString(),
                    version: '1.1',
                    fileType: 'OMG-nichord Session'
                };
                
                const dataStr = JSON.stringify(sessionData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `OMG-session-${new Date().toISOString().split('T')[0]}.omg`;
                link.click();
                
                URL.revokeObjectURL(url);
                
                console.log('?? Session saved as .OMG file');
            }
            
            loadSessionFromOMG(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                // Check file extension
                if (!file.name.toLowerCase().endsWith('.omg')) {
                    alert('Please select a .OMG session file');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const sessionData = JSON.parse(e.target.result);
                        
                        // Verify it's an OMG session file
                        if (sessionData.fileType !== 'OMG-nichord Session') {
                            alert('Invalid .OMG session file format');
                            return;
                        }
                        
                        console.log('?? Loading .OMG session file:', sessionData);
                        
                        // Clear ALL existing data first - start fresh
                        this.chordExtensions = [];
                        this.customChords = [];
                        this.paletteChords = [];
                        this.hiddenColumns = [];
                        this.lockedChords = new Map();
                        
                        // ONLY restore locked chords from the OMG file
                        if (sessionData.lockedChords && sessionData.lockedChords.length > 0) {
                            console.log('?? Restoring ONLY locked chords from OMG file:', sessionData.lockedChords.length, 'chords');
                            
                            // Convert locked chords to chord extensions that will appear as locked
                            this.chordExtensions = sessionData.lockedChords.map(locked => ({
                                name: locked.chordName,
                                intervals: locked.intervals,
                                extensions: locked.extensions || [],
                                quality: locked.quality || 'custom',
                                isCustom: true,
                                isLocked: true,
                                lockedData: locked,
                                position: locked.originalPosition || 0
                            }));
                            
                            // Store for restoration after regeneration
                            this.savedLockedChords = sessionData.lockedChords;
                        } else {
                            console.log('?? No locked chords found in OMG file - starting empty');
                        }
                        
                        // Restore global settings (these are OK to restore)
                        if (sessionData.currentRoot !== undefined) {
                            this.currentRoot = sessionData.currentRoot;
                        }
                        if (sessionData.currentTuning !== undefined) {
                            this.currentTuning = sessionData.currentTuning;
                        }
                        if (sessionData.gamelanMode !== undefined) {
                            this.gamelanMode = sessionData.gamelanMode;
                        }
                        
                        // Restore audio settings
                        if (sessionData.masterVolume !== undefined) {
                            this.masterVolume = sessionData.masterVolume;
                        }
                        if (sessionData.reverbLevel !== undefined) {
                            this.reverbLevel = sessionData.reverbLevel;
                        }
                        
                        // Restore oscillator settings
                        if (sessionData.osc1) {
                            this.osc1Type = sessionData.osc1.type || 'sine';
                            this.osc1Attack = sessionData.osc1.attack || 10;
                            this.osc1Decay = sessionData.osc1.decay || 200;
                            this.osc1Sustain = sessionData.osc1.sustain || 70;
                            this.osc1Release = sessionData.osc1.release || 800;
                        }
                        if (sessionData.osc2) {
                            this.osc2Type = sessionData.osc2.type || 'sine';
                            this.osc2Attack = sessionData.osc2.attack || 5;
                            this.osc2Decay = sessionData.osc2.decay || 30;
                            this.osc2Sustain = sessionData.osc2.sustain || 50;
                            this.osc2Release = sessionData.osc2.release || 1000;
                        }
                        
                        // Restore piano lock data - COMPLETE RESTORATION
                        if (sessionData.pianoLockedChords && sessionData.pianoLockedChords.length > 0) {
                            console.log('🎹 Restoring piano locks from OMG file:', sessionData.pianoLockedChords.length, 'locks');
                            this.pianoLockedChords = new Map(sessionData.pianoLockedChords);
                        } else {
                            this.pianoLockedChords = new Map();
                        }
                        
                        if (sessionData.preloadedPresets && sessionData.preloadedPresets.length > 0) {
                            console.log('🎹 Restoring preloaded presets from OMG file:', sessionData.preloadedPresets.length, 'presets');
                            this.preloadedPresets = new Map(sessionData.preloadedPresets);
                        } else {
                            this.preloadedPresets = new Map();
                        }
                        
                        if (sessionData.pianoLockPresetCounter !== undefined) {
                            this.pianoLockPresetCounter = sessionData.pianoLockPresetCounter;
                        }
                        
                        // Save all data to localStorage
                        this.saveChordConfiguration();
                        
                        // Regenerate everything with only locked chords
                        this.generateRootButtons();
                        this.generateExtensionColumns();
                        this.renderPaletteChords();
                        
                        // Restore locked chord states after generation
                        if (this.savedLockedChords && this.savedLockedChords.length > 0) {
                            setTimeout(() => {
                                this.restoreLockedChordStates();
                            }, 100); // Small delay to ensure DOM is ready
                        }
                        
                        // Ensure ready for new chord creation without auto-entering chord mode
                        console.log('🎹 OMG session loaded - ready for new chord creation with "New Chord" button');
                        // DO NOT auto-enter chord creation mode - user should click "New Chord" when ready
                        
                        alert(`Session restored successfully!\nLoaded ${sessionData.lockedChords ? sessionData.lockedChords.length : 0} locked chords and ${sessionData.pianoLockedChords ? sessionData.pianoLockedChords.length : 0} piano locks from: ${sessionData.savedDate}`);
                        console.log('?? OMG session loaded - showing only locked chords, tuning and root changeable');
                        
                    } catch (error) {
                        alert('Error loading session: Invalid .OMG file format');
                        console.error('Load error:', error);
                    }
                };
                reader.readAsText(file);
                
                // Reset file input
                event.target.value = '';
            }

            importChordConfiguration(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const config = JSON.parse(e.target.result);
                        
                        if (config.chordExtensions) {
                            this.chordExtensions = config.chordExtensions;
                        }
                        if (config.customChords) {
                            this.customChords = config.customChords;
                            // localStorage removed - no longer saving custom chords
                        }
                        if (config.hiddenColumns) {
                            this.hiddenColumns = config.hiddenColumns;
                            // localStorage removed - no longer saving hidden columns
                        }
                        
                        this.saveChordConfiguration();
                        this.generateExtensionColumns();
                        
                        alert('Configuration imported successfully!');
                    } catch (error) {
                        alert('Error importing configuration: Invalid file format');
                        console.error('Import error:', error);
                    }
                };
                reader.readAsText(file);
                
                // Reset file input
                event.target.value = '';
            }

            resetToDefaults() {
                if (confirm('Reset completely? This will remove ALL chords and start fresh.')) {
                    // Clear all storage
                    // localStorage removed - no longer clearing chord config
                    // localStorage removed
                    // localStorage removed
                    // localStorage removed
                    // localStorage removed
                    
                    // Reset to completely empty state
                    this.chordExtensions = [];
                    this.customChords = [];
                    this.hiddenColumns = [];
                    this.lockedChords = new Map();
                    this.savedLockedChords = [];
                    this.currentEditingColumn = null;
                    
                    // Start in chord creation mode since no chords exist
                    this.enterChordCreationMode();
                    
                    alert('Reset complete - you can now create chords from scratch');
                }
            }

            hideColumn() {
                if (!this.hiddenColumns) this.hiddenColumns = [];
                const columnId = this.currentEditingColumn.id || this.currentEditingColumn.name.toLowerCase();
                
                if (!this.hiddenColumns.includes(columnId)) {
                    this.hiddenColumns.push(columnId);
                    // localStorage removed - no longer saving hidden columns
                    this.generateExtensionColumns();
                }
            }

            addToFavorites() {
                if (!this.favoriteChords) this.favoriteChords = [];
                
                const favoriteChord = {
                    name: this.currentEditingColumn.name,
                    originalName: this.currentEditingColumn.originalName || this.currentEditingColumn.name,
                    extensions: this.currentEditingColumn.extensions || [],
                    quality: this.currentEditingColumn.quality,
                    intervals: this.currentEditingColumn.intervals,
                    root: this.currentRoot, // Store current root note
                    isCustom: this.currentEditingColumn.isCustom || false,
                    addedAt: Date.now()
                };
                
                // Check if already in favorites
                const exists = this.favoriteChords.some(fav => 
                    fav.name === favoriteChord.name && 
                    fav.quality === favoriteChord.quality &&
                    fav.root === favoriteChord.root
                );
                
                if (!exists) {
                    this.favoriteChords.push(favoriteChord);
                    // localStorage removed - no longer saving favorite chords
                    this.generateExtensionColumns();
                    console.log(`Added "${favoriteChord.name}" to favorites with root ${this.getNoteNames()[favoriteChord.root]}`);
                } else {
                    alert('This chord with this root is already in favorites!');
                }
            }

            addCurrentChordToFavorites() {
                const chordName = document.getElementById('customChordName').value.trim();
                if (!chordName) {
                    alert('Please enter a chord name first!');
                    return;
                }
                
                const selectedNotes = this.getSelectedNotes();
                if (selectedNotes.length === 0) {
                    alert('Please select at least one note!');
                    return;
                }
                
                if (!this.favoriteChords) this.favoriteChords = [];
                
                const favoriteChord = {
                    name: chordName,
                    originalName: chordName,
                    extensions: [],
                    quality: this.currentQuality,
                    intervals: selectedNotes,
                    notes: selectedNotes,
                    root: this.currentRoot,
                    isCustom: true,
                    addedAt: Date.now(),
                    tuning: this.currentTuning
                };
                
                // Check if already in favorites
                const exists = this.favoriteChords.some(fav => 
                    fav.name === favoriteChord.name && 
                    fav.quality === favoriteChord.quality &&
                    fav.root === favoriteChord.root
                );
                
                if (!exists) {
                    this.favoriteChords.push(favoriteChord);
                    // localStorage removed - no longer saving favorite chords
                    this.updateFavoritesDisplay();
                    console.log(`Added "${favoriteChord.name}" to favorites`);
                    alert(`Added "${favoriteChord.name}" to favorites!`);
                } else {
                    alert('This chord is already in favorites!');
                }
            }
            
            updateFavoritesDisplay() {
                const favoritesList = document.getElementById('favoriteChordsList');
                if (!favoritesList) return;
                
                favoritesList.innerHTML = '';
                
                if (!this.favoriteChords || this.favoriteChords.length === 0) {
                    favoritesList.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #8fb3d3; font-style: italic; padding: 20px;">No favorite chords yet</div>';
                    return;
                }
                
                this.favoriteChords.forEach((chord, index) => {
                    const chordElement = document.createElement('div');
                    chordElement.style.cssText = `
                        background: linear-gradient(135deg, #f39c12, #e67e22);
                        border: 1px solid #d68910;
                        border-radius: 6px;
                        padding: 8px;
                        text-align: center;
                        cursor: pointer;
                        font-size: 12px;
                        color: #fff;
                        position: relative;
                        transition: all 0.2s ease;
                        user-select: none;
                    `;
                    
                    chordElement.innerHTML = `
                        <div style="font-weight: bold;">${chord.name}</div>
                        <div style="font-size: 10px; opacity: 0.8;">${this.getNoteNames()[chord.root] || 'C'} ${chord.quality}</div>
                        <div style="position: absolute; top: 2px; right: 2px; background: rgba(0,0,0,0.3); border-radius: 50%; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; font-size: 10px; cursor: pointer;" class="remove-favorite" data-index="${index}"> </div>
                    `;
                    
                    // Play chord on click
                    chordElement.addEventListener('click', (e) => {
                        if (e.target.classList.contains('remove-favorite')) return;
                        this.playChord(chord.intervals || chord.notes, chord.root);
                    });
                    
                    // Hover effects
                    chordElement.addEventListener('mouseenter', () => {
                        chordElement.style.transform = 'scale(1.05)';
                        chordElement.style.boxShadow = '0 4px 12px rgba(243, 156, 18, 0.4)';
                    });
                    
                    chordElement.addEventListener('mouseleave', () => {
                        chordElement.style.transform = 'scale(1)';
                        chordElement.style.boxShadow = 'none';
                    });
                    
                    favoritesList.appendChild(chordElement);
                });
                
                // Add remove functionality
                favoritesList.addEventListener('click', (e) => {
                    if (e.target.classList.contains('remove-favorite')) {
                        const index = parseInt(e.target.dataset.index);
                        this.removeFavoriteChord(index);
                    }
                });
            }
            
            removeFavoriteChord(index) {
                if (confirm('Remove this chord from favorites?')) {
                    this.favoriteChords.splice(index, 1);
                    // localStorage removed - no longer saving favorite chords
                    this.updateFavoritesDisplay();
                }
            }
            
            getSelectedNotes() {
                const selector = document.getElementById('edoNoteSelector');
                if (!selector) return [];
                
                const selectedButtons = selector.querySelectorAll('.note-btn.selected');
                return Array.from(selectedButtons).map(btn => parseInt(btn.dataset.note));
            }

            removeFromFavorites() {
                if (this.currentEditingColumn.favoriteIndex !== undefined) {
                    const favoriteName = this.favoriteChords[this.currentEditingColumn.favoriteIndex].name;
                    this.favoriteChords.splice(this.currentEditingColumn.favoriteIndex, 1);
                    // localStorage removed - no longer saving favorite chords
                    this.generateExtensionColumns();
                    console.log(`Removed "${favoriteName}" from favorites`);
                }
            }

            addToPalette() {
                if (!this.paletteChords) this.paletteChords = [];
                
                const noteNames = this.getNoteNames();
                const rootName = noteNames[this.currentRoot] || this.currentRoot;
                
                // Generate the actual chord intervals for this column
                let chordIntervals = [];
                if (this.currentEditingColumn.intervals && this.currentEditingColumn.intervals.length > 0) {
                    // Use stored intervals (for custom chords)
                    chordIntervals = this.currentEditingColumn.intervals;
                } else {
                    // Generate intervals from extensions and quality (for standard chords)
                    const originalQuality = this.currentQuality;
                    this.currentQuality = this.currentEditingColumn.quality || 'major';
                    chordIntervals = this.getChordIntervals(this.currentEditingColumn.extensions || []);
                    // Convert EDO steps back to semitones for storage
                    chordIntervals = chordIntervals.map(step => (step * 12) / this.currentTuning);
                    this.currentQuality = originalQuality;
                }
                
                const paletteChord = {
                    name: this.currentEditingColumn.name,
                    fullName: `${rootName}${this.currentEditingColumn.name}`,
                    extensions: this.currentEditingColumn.extensions || [],
                    quality: this.currentEditingColumn.quality || 'major',
                    rootNote: this.currentRoot,
                    originalName: this.currentEditingColumn.originalName || this.currentEditingColumn.name,
                    isCustom: this.currentEditingColumn.isCustom || false,
                    intervals: chordIntervals,
                    root: this.currentRoot,
                    lockedTuning: this.currentTuning,
                    lockedGamelanMode: this.gamelanMode
                };
                
                // Always allow adding chords to create sequences
                this.paletteChords.push(paletteChord);
                // localStorage removed - no longer saving palette chords
                this.renderPaletteChords();
                console.log(`Added "${paletteChord.fullName}" to palette with intervals:`, chordIntervals);
            }

            deleteColumn() {
                console.log('?? deleteColumn called, currentEditingColumn:', this.currentEditingColumn);
                
                if (!this.currentEditingColumn) {
                    console.error('?? No currentEditingColumn set for deleteColumn');
                    alert('Error: No column selected for deletion');
                    return;
                }
                
                if (this.currentEditingColumn.isCustom) {
                    console.log('?? Deleting custom chord:', this.currentEditingColumn.name);
                    if (confirm(`Delete custom column "${this.currentEditingColumn.name}"?`)) {
                        const index = this.customChords.findIndex(chord => chord.name === this.currentEditingColumn.name);
                        console.log('?? Found custom chord at index:', index);
                        if (index !== -1) {
                            this.customChords.splice(index, 1);
                            // localStorage removed - no longer saving custom chords
                            console.log('?? Custom chord deleted, regenerating columns');
                            this.generateExtensionColumns();
                            // Custom chords automatically appear in extensions
                        } else {
                            console.error('?? Custom chord not found for deletion');
                            alert('Error: Custom chord not found for deletion');
                        }
                    }
                } else {
                    console.log('?? Deleting standard chord:', this.currentEditingColumn.originalName || this.currentEditingColumn.name);
                    // Allow deleting standard chord columns too
                    if (confirm(`Delete column "${this.currentEditingColumn.originalName || this.currentEditingColumn.name}"? This will remove all 3 flavors (Maj/Neu/Min) permanently.`)) {
                        // Use extension index if available, otherwise find by name
                        let index = -1;
                        if (this.currentEditingColumn.extensionIndex !== undefined) {
                            index = this.currentEditingColumn.extensionIndex;
                            console.log('?? Using extensionIndex:', index);
                        } else {
                            const searchName = this.currentEditingColumn.originalName || this.currentEditingColumn.name;
                            index = this.chordExtensions.findIndex(ext => 
                                ext.name === searchName || ext.name.toLowerCase() === searchName.toLowerCase()
                            );
                            console.log('?? Found extension by name at index:', index);
                        }
                        
                        if (index !== -1 && index < this.chordExtensions.length) {
                            console.log('?? Deleting chord extension at index:', index);
                            this.chordExtensions.splice(index, 1);
                            this.saveChordConfiguration();
                            this.generateExtensionColumns();
                            console.log(`?? Deleted chord extension at index ${index}`);
                        } else {
                            console.error('?? Could not find chord extension to delete:', this.currentEditingColumn);
                            alert('Error: Could not find chord extension to delete');
                        }
                    }
                }
            }

            updateColumnInStorage() {
                if (this.currentEditingColumn.isCustom) {
                    const index = this.customChords.findIndex(chord => chord.name === this.currentEditingColumn.originalName || this.currentEditingColumn.name);
                    if (index !== -1) {
                        this.customChords[index].name = this.currentEditingColumn.name;
                        if (this.currentEditingColumn.intervals) {
                            this.customChords[index].notes = this.currentEditingColumn.intervals;
                        }
                        // localStorage removed - no longer saving custom chords
                    }
                }
            }

            // Chord Name Context Menu Methods
            hideChord() {
                this.pushState();
                console.log('?? hideChord called, currentEditingChord:', this.currentEditingChord);
                
                if (!this.currentEditingChord) {
                    console.error('?? No currentEditingChord set for hideChord');
                    alert('Error: No chord selected for hiding');
                    return;
                }
                
                const chordId = this.currentEditingChord.id;
                if (!this.hiddenColumns.includes(chordId)) {
                    this.hiddenColumns.push(chordId);
                    // localStorage removed - no longer saving hidden columns
                    this.generateExtensionColumns();
                    console.log(`?? Hidden chord: ${this.currentEditingChord.name}`);
                }
            }

            duplicateChord() {
                this.pushState();
                console.log('?? duplicateChord called, currentEditingChord:', this.currentEditingChord);
                
                if (!this.currentEditingChord) {
                    console.error('?? No currentEditingChord set for duplicateChord');
                    alert('Error: No chord selected for duplication');
                    return;
                }
                
                // Create a duplicate chord
                const duplicateChord = {
                    name: this.currentEditingChord.name + ' Copy',
                    intervals: [...(this.currentEditingChord.intervals || [])],
                    isCustom: true,
                    id: 'custom_' + Date.now()
                };
                
                // Open chord builder with the duplicate
                this.showChordBuilder(duplicateChord);
            }

            editChord() {
                console.log('?? editChord called, currentEditingChord:', this.currentEditingChord);
                
                if (!this.currentEditingChord) {
                    console.error('?? No currentEditingChord set for editChord');
                    alert('Error: No chord selected for editing');
                    return;
                }
                
                // Open chord builder with the current chord
                this.showChordBuilder(this.currentEditingChord);
            }

            copyToCustomChords() {
                console.log('?? copyToCustomChords called, currentEditingChord:', this.currentEditingChord);
                
                if (!this.currentEditingChord) {
                    console.error('?? No currentEditingChord set for copyToCustomChords');
                    alert('Error: No chord selected for copying');
                    return;
                }
                
                // Get safe root note name
                const noteNames = this.getNoteNames();
                const rootIndex = this.currentEditingChord.root || this.currentRoot || 0;
                const rootName = noteNames[rootIndex] || `Note${rootIndex}`;
                
                console.log('?? Root details - index:', rootIndex, 'name:', rootName, 'noteNames:', noteNames);
                
                // Create a custom chord copy with root and tuning system
                const customChord = {
                    name: this.currentEditingChord.name + ` (${rootName})`,
                    notes: [...(this.currentEditingChord.intervals || [])],
                    id: Date.now()
                };
                
                console.log('?? Created customChord:', customChord);
                
                // Add to custom chords storage
                if (!this.customChords) this.customChords = [];
                this.customChords.push(customChord);
                // localStorage removed - no longer saving custom chords
                
                // Add to palette for immediate use
                const paletteChord = {
                    name: customChord.name,
                    fullName: customChord.name,
                    extensions: [],
                    quality: 'custom',
                    id: 'custom_' + customChord.id,
                    isCustom: true,
                    originalName: customChord.name,
                    intervals: customChord.notes,
                    root: this.currentEditingChord.root || this.currentRoot || 0,
                    lockedTuning: this.currentEditingChord.tuning || this.currentTuning,
                    lockedGamelanMode: this.gamelanMode
                };
                
                console.log('?? Created paletteChord:', paletteChord);
                
                if (!this.paletteChords) this.paletteChords = [];
                this.paletteChords.push(paletteChord);
                // localStorage removed - no longer saving palette chords
                
                // Regenerate everything
                this.generateExtensionColumns();
                this.renderPaletteChords();
                
                // Show success message
                alert(`Successfully copied "${customChord.name}" to custom palette!`);
                
                console.log(`?? Copied chord "${customChord.name}" to custom chords and palette`);
            }

            getNotesFromExtensions(extensions) {
                // Convert chord extensions to note intervals
                const intervals = this.getChordIntervals(extensions);
                return intervals;
            }

            // =============================================================================
            // LEGACY CODE REMOVED - Replaced by Unified Chord Builder
            // =============================================================================
            
            // OLD: showColumnModal(), showCustomChordModal(), saveCustomChord()
            // NEW: All functionality moved to unified ChordBuilder module above
            
            toggleColumnVisibility(columnId, visible) {
                if (visible) {
                    this.hiddenColumns = this.hiddenColumns.filter(id => id !== columnId);
                } else {
                    if (!this.hiddenColumns.includes(columnId)) {
                        this.hiddenColumns.push(columnId);
                    }
                }
                // localStorage removed - no longer saving hidden columns
                this.generateExtensionColumns();
            }

            deleteCustomChord(index) {
                if (confirm('Delete this custom chord?')) {
                    this.customChords.splice(index, 1);
                    // localStorage removed - no longer saving custom chords
                    this.generateExtensionColumns();
                }
            }

            updateChordDisplay() {
                // Chord display removed for cleaner interface
            }

            translateSemitoneToTuning(semitone) {
                // Translate 12-TET semitone to nearest step in current tuning
                // This ensures custom chords sound close in different tunings
                const exactStep = (semitone / 12) * this.currentTuning;
                return Math.round(exactStep) % this.currentTuning;
            }

            generateRootButtons() {
                const rootGrid = document.getElementById('rootGrid');
                if (!rootGrid) return;
                // Reuse existing keyboard element to avoid layout shift flicker
                let keyboard = rootGrid.querySelector('.piano-keyboard');
                if (!keyboard) {
                    // First-time creation
                    keyboard = document.createElement('div');
                    keyboard.className = 'piano-keyboard';
                    const by = document.createElement('div');
                    by.className = 'by-fastfast';
                    // Make last four letters clickable ("FAST")
                    by.innerHTML = 'By FAST<span class="fastfast-link" title="Open FASTFAST Bandcamp">FAST</span>';
                    // Click handler (only on the link span)
                    by.querySelector('.fastfast-link')?.addEventListener('click', (e)=>{
                        e.stopPropagation();
                        try { window.open('https://fastfast.bandcamp.com/', '_blank', 'noopener,noreferrer'); } catch(_) { }
                    });
                    keyboard.appendChild(by);
                    // Transpose controls: up (top-left), down (bottom-left), and delta between
                    const up = document.createElement('button');
                    up.id = 'transposeUp';
                    up.title = 'Transpose up 1 step';
                    up.textContent = '▲';
                    up.style.cssText = 'position:absolute;left:10px;top:8px;background:#1f3a4a;color:#e8f5ff;border:1px solid #3b6a7a;border-radius:6px;padding:4px 6px;font-size:14px;z-index:5;';
                    const down = document.createElement('button');
                    down.id = 'transposeDown';
                    down.title = 'Transpose down 1 step';
                    down.textContent = '▼';
                    down.style.cssText = 'position:absolute;left:10px;bottom:8px;background:#1f3a4a;color:#e8f5ff;border:1px solid #3b6a7a;border-radius:6px;padding:4px 6px;font-size:14px;z-index:5;';
                    const delta = document.createElement('div');
                    delta.id = 'transposeDelta';
                    delta.textContent = String(this.transposeDelta || 0);
                    delta.style.cssText = 'position:absolute;left:10px;top:50%;transform:translateY(-50%);color:#9db6c8;font-weight:700;font-size:14px;z-index:5;';
                    keyboard.appendChild(up);
                    keyboard.appendChild(delta);
                    keyboard.appendChild(down);
                    // Wire handlers
                    up.addEventListener('click', ()=> this.applyTransposeStep(1));
                    down.addEventListener('click', ()=> this.applyTransposeStep(-1));
                    rootGrid.appendChild(keyboard);
                } else {
                    // Clear dynamic children (keys + dots) only
                    keyboard.querySelectorAll('.white-key.root-btn, .black-key.root-btn, .edo-dot').forEach(el=> el.remove());
                    // Ensure transpose controls exist on refresh
                    if (!keyboard.querySelector('#transposeUp')) {
                        const up = document.createElement('button');
                        up.id = 'transposeUp';
                        up.title = 'Transpose up 1 step';
                        up.textContent = '▲';
                        up.style.cssText = 'position:absolute;left:10px;top:8px;background:#1f3a4a;color:#e8f5ff;border:1px solid #3b6a7a;border-radius:6px;padding:4px 6px;font-size:14px;z-index:5;';
                        up.addEventListener('click', ()=> this.applyTransposeStep(1));
                        keyboard.appendChild(up);
                    }
                    if (!keyboard.querySelector('#transposeDelta')) {
                        const delta = document.createElement('div');
                        delta.id = 'transposeDelta';
                        delta.textContent = String(this.transposeDelta || 0);
                        delta.style.cssText = 'position:absolute;left:10px;top:50%;transform:translateY(-50%);color:#9db6c8;font-weight:700;font-size:14px;z-index:5;';
                        keyboard.appendChild(delta);
                    } else {
                        keyboard.querySelector('#transposeDelta').textContent = String(this.transposeDelta || 0);
                    }
                    if (!keyboard.querySelector('#transposeDown')) {
                        const down = document.createElement('button');
                        down.id = 'transposeDown';
                        down.title = 'Transpose down 1 step';
                        down.textContent = '▼';
                        down.style.cssText = 'position:absolute;left:10px;bottom:8px;background:#1f3a4a;color:#e8f5ff;border:1px solid #3b6a7a;border-radius:6px;padding:4px 6px;font-size:14px;z-index:5;';
                        down.addEventListener('click', ()=> this.applyTransposeStep(-1));
                        keyboard.appendChild(down);
                    }
                    // Ensure attribution present
                    if (!keyboard.querySelector('.by-fastfast')) {
                        const by = document.createElement('div');
                        by.className = 'by-fastfast';
                        by.innerHTML = 'By FAST<span class="fastfast-link" title="Open FASTFAST Bandcamp">FAST</span>';
                        by.querySelector('.fastfast-link')?.addEventListener('click', (e)=>{
                            e.stopPropagation();
                            try { window.open('https://fastfast.bandcamp.com/', '_blank', 'noopener,noreferrer'); } catch(_) { }
                        });
                        keyboard.appendChild(by);
                    }
                }

                // Attach drag-to-rotate across all EDOs (cyclic modulo currentTuning)
                if (!keyboard.dataset.rotateBound) {
                    keyboard.dataset.rotateBound = '1';
                    let dragging = false; let startX = 0; let startRot = 0;
                    const applyDrag = (dx)=>{
                        const stepPx = Math.max(12, (keyboard.clientWidth || 600) / 12);
                        const delta = -Math.round(dx / stepPx);
                        const edo = this.currentTuning || 12;
                        let next = ((startRot + delta) % edo + edo) % edo;
                        if (next !== this.keyboardRotation) {
                            this.keyboardRotation = next;
                            this.generateRootButtons();
                            if (this.chordCreationMode) { this.setupIntervalSelection(); this.updatePreviewChordColumn(); }
                            if (this.currentActiveColumnEl) this.highlightKeyboardForColumn(this.currentActiveColumnEl);
                        }
                    };
                    keyboard.addEventListener('mousedown', (e)=>{ dragging=true; startX=e.clientX; startRot=this.keyboardRotation|0; });
                    window.addEventListener('mousemove', (e)=>{ if(!dragging) return; applyDrag(e.clientX - startX); });
                    window.addEventListener('mouseup', ()=>{ dragging=false; });
                    keyboard.addEventListener('touchstart', (e)=>{ dragging=true; startX=e.touches[0].clientX; startRot=this.keyboardRotation|0; }, {passive:false});
                    window.addEventListener('touchmove', (e)=>{ if(!dragging) return; applyDrag(e.touches[0].clientX - startX); }, {passive:false});
                    window.addEventListener('touchend', ()=>{ dragging=false; }, {passive:false});
                }

                // Fallback to legacy buttons in gamelan mode (7-tone pelog)
                if (this.gamelanMode) {
                    const noteNames = this.getNoteNames();
                    for (let i = 0; i < this.currentTuning; i++) {
                        const b = document.createElement('div');
                        b.className = 'root-btn';
                        b.textContent = noteNames[i] || i;
                        // legacy gamelan root selection removed; treat as preview tap
                        b.addEventListener('click', async ()=>{
                            const ok = await this.ensureAudioContext();
                            if (ok) {
                                const f = this.getFrequency(i % this.currentTuning, 4, this.currentTuning);
                                this.playFrequency(f, null);
                            }
                            const activeCol = this.getActiveColumnElement?.();
                            if (activeCol && this.editArmed) {
                                this.toggleNoteInActiveChord(i % this.currentTuning);
                                this._scheduleEditSave(activeCol);
                            }
                            this._scheduleEditArm();
                        });
                        rootGrid.appendChild(b);
                    }
                    return;
                }

                // Piano layout definitions
                const whiteOrder = [0,2,4,5,7,9,11]; // semitone numbers for C D E F G A B
                const whiteLabels = ['C','D','E','F','G','A','B'];
                const blackMap = { 1:'C#',3:'D#',6:'F#',8:'G#',10:'A#' };
                const blackPositionsRelativeToWhite = {1:0,3:1,6:3,8:4,10:5}; // index of white to left

                // Precompute cent positions of all current tuning steps (0..currentTuning-1)
                const stepCents = Array.from({length:this.currentTuning},(_,i)=> this.getCentValue(i));

                // Map each tuning step to nearest 12TET semitone (0..11)
                const semitoneCenters = Array.from({length:12},(_,i)=> i*100);
                const stepToSemitone = stepCents.map(c=>{
                    let best=0; let mind=Infinity;
                    for (let s=0;s<12;s++){const d=Math.abs(c-semitoneCenters[s]); if(d<mind){mind=d;best=s;}}
                    return {cent:c, step: c/ (1200/ this.currentTuning), idx:best, dist:mind};
                });

                // For deciding which standard keys (white/black) are represented by an EDO step
                const threshold = 35; // cents tolerance to claim a semitone
                const semitoneHasStep = new Array(12).fill(false);
                stepToSemitone.forEach(o=>{ if(o.dist<=threshold) semitoneHasStep[o.idx]=true; });

                // keyboard already prepared above
                // Dynamic width scaling for higher EDO counts
                this.adjustKeyboardWidth(keyboard);

                // Root selection UI removed; keyboard is now an editor and preview surface only

                // Pick representative step for each claimed semitone (closest)
                const semitoneToStep = new Array(12).fill(null);
                for (let s=0;s<12;s++){
                    let best=null; let mind=Infinity;
                    stepToSemitone.forEach(o=>{ if(o.idx===s && o.dist < mind){ mind=o.dist; best=o; }});
                    semitoneToStep[s]=best; // may be null
                }

                // Horizontal positions for 7 white circles equally spaced across width
                const whiteCenters = whiteOrder.map((_,i)=> ( (i+0.5)/7 )*100 );
                let centersUsed = whiteCenters.slice();

                // Uniform-slot keyboard for all EDOs: 12 visual slots that rotate, keys map to nearest EDO steps
                const edo = this.currentTuning || 12;
                const rotBase = (this.keyboardRotation||0) % 12; // visual rotation in 12 slots
                const slotCenters = Array.from({length:12},(_,i)=> ((i+0.5)/12)*100);
                centersUsed = slotCenters.slice();
                // Track which EFFECTIVE steps are already used to avoid duplicates across keys/dots
                const usedEffSteps = new Set();
                for (let i = 0; i < 12; i++) {
                    const semi = (rotBase + i) % 12; // visual semitone
                    // find nearest step for this semitone in current EDO
                    let stepIndex;
                    if (edo === 12) stepIndex = semi;
                    else stepIndex = this.findNearestStepForSemitone(semi, stepCents);
                    const isWhite = whiteOrder.includes(semi);
                    const el = document.createElement('div');
                    el.className = (isWhite? 'white-key' : 'black-key') + ' root-btn';
            // Store the EFFECTIVE step (what you hear) so selection and glow match labels
                    el.dataset.semitone = semi;
                    // no persistent 'active' highlight for root; only chord-tone glow handled elsewhere
                    el.style.left = slotCenters[i] + '%';
                    // Label reflects global transpose so keys show what you hear
                    const effStep = ((stepIndex + (this.transposeDelta||0)) % edo + edo) % edo;
                    // Record the key's effective step to prevent duplicate dots, but never alter the key mapping
                    usedEffSteps.add(effStep);
            el.dataset.step = effStep;
                    el.textContent = this.getMicrotonalNoteName(effStep);
                    el.addEventListener('click', async (ev)=>{
                        try { ev.stopPropagation(); ev.stopImmediatePropagation && ev.stopImmediatePropagation(); } catch(_){ }
                        // mark interaction and ensure audio; keep editArmed state
                        this.userInteracted = true;
                        // Clear preview highlight if any immediately
                        this.previewInterval = null;
                        try { document.querySelectorAll('#rootGrid [data-step].preview').forEach(x=> x.classList.remove('preview')); } catch {}
                        try { this.updateIntervalButtons(); } catch {}
                        let activeCol = this.getActiveColumnElement?.();
                        if (!activeCol) { activeCol = document.querySelector('.extension-column'); if (activeCol) this.currentActiveColumnEl = activeCol; }
                        const ok = await this.ensureAudioContext();
                        if (ok) {
                const eff = parseInt(el.dataset.step,10);
                const f = this.getFrequency(eff, 4, edo);
                            this.playFrequency(f, null);
                        }
                        const eff = parseInt(el.dataset.step,10);
                        if (activeCol) {
                            // Toggle this exact step into/out of the current chord
                            this.toggleNoteInActiveChord(eff);
                            this._scheduleEditSave(activeCol);
                        } else {
                            // No active column, just arm editing for soon
                            this._scheduleEditArm();
                        }
                    });
                    keyboard.appendChild(el);
                }

                // For non-12 EDO, place micro dots between the current rotated semitone slots
                if (this.currentTuning !== 12) {
                    // Build a mapping from semitone -> slot center based on current rotation
                    const centersBySemitone = {};
                    for (let i = 0; i < 12; i++) {
                        const semi = (rotBase + i) % 12;
                        centersBySemitone[semi] = slotCenters[i];
                    }

                    // Helper to add a micro dot at a fractional position between two adjacent slots
                    // stepIndex is the exact EDO step we want this dot to represent (no nearest rounding)
            const addMicroDot = (s, frac01, color, stepIndex) => {
                        // j is the slot index for semitone s in the rotated view
                        const j = ((s - rotBase) % 12 + 12) % 12;
                        const jNext = (j + 1) % 12;
                        let leftPct = slotCenters[j];
                        let rightPct = slotCenters[jNext];
                        // Handle wrap-around across 100% -> 0%
                        if (rightPct < leftPct) rightPct += 100;
            let pct = leftPct + (rightPct - leftPct) * frac01;
                        if (pct >= 100) pct -= 100;

                        // Create the dot element and map it to the nearest EDO step inside this gap
                        const d = document.createElement('div');
                        d.className = `edo-dot edo-lane-${color} ${color}`;
                        d.style.left = pct + '%';
        let effStep = ((stepIndex + (this.transposeDelta||0)) % this.currentTuning + this.currentTuning)%this.currentTuning;
        // Skip creating a dot if its effective step is already represented (avoid duplicates like E^ and Ev coupling)
        if (usedEffSteps.has(effStep)) return;
        usedEffSteps.add(effStep);
            // Store effective step so click and highlight align with label
            d.dataset.step = effStep;
            d.textContent = this.getMicrotonalNoteName(effStep);
                        d.title = `${d.textContent}`;
                        d.addEventListener('click', async (ev)=>{
                            try { ev.stopPropagation(); ev.stopImmediatePropagation && ev.stopImmediatePropagation(); } catch(_){ }
                            let activeCol = this.getActiveColumnElement?.();
                            if (!activeCol) { activeCol = document.querySelector('.extension-column'); if (activeCol) this.currentActiveColumnEl = activeCol; }
                            // Clear preview highlight if any immediately
                            this.previewInterval = null;
                            try { document.querySelectorAll('#rootGrid [data-step].preview').forEach(x=> x.classList.remove('preview')); } catch {}
                            try { this.updateIntervalButtons(); } catch {}
                            const ok = await this.ensureAudioContext();
                            if (ok) {
                const eff = parseInt(d.dataset.step,10);
                const f = this.getFrequency(eff, 4, this.currentTuning);
                                this.playFrequency(f, null);
                            }
                            const eff = parseInt(d.dataset.step,10);
                            if (activeCol) {
                                this.toggleNoteInActiveChord(eff);
                                this._scheduleEditSave(activeCol);
                            } else {
                                this._scheduleEditArm();
                            }
                        });
                        keyboard.appendChild(d);
                    };

                    // Determine which EDO steps already claimed a main 12-slot key
                    const claimedSteps = new Set();
                    semitoneToStep.forEach(rep=>{ if(rep) claimedSteps.add(Math.round(rep.step)); });

                    // Iterate each 12-TET gap in cents space and drop dots between its rotated slots
                    const whiteSemis = new Set([0,2,4,5,7,9,11]);
                    const blackSemis = new Set([1,3,6,8,10]);
                    for (let s = 0; s < 12; s++) {
                        const nextSemi = (s + 1) % 12;
                        const gapStartCent = s * 100;
                        const gapEndCent = ((s + 1) % 12) * 100;
                        // Collect EDO steps whose cents fall strictly inside this 12-TET gap
                        const candidates = [];
                        stepCents.forEach((c,i)=>{
                            const cent = c % 1200;
                            // Handle wrap for 11->0 gap by treating end at 1200
                            if (s === 11) {
                                if (cent > 1100 && cent < 1200 && !claimedSteps.has(i)) {
                                    candidates.push({cent, offset: cent - 1100, step: i});
                                }
                            } else {
                                if (cent > gapStartCent && cent < gapEndCent && !claimedSteps.has(i)) {
                                    candidates.push({cent, offset: cent - gapStartCent, step: i});
                                }
                            }
                        });
                        if (!candidates.length) continue;
                        candidates.sort((a,b)=> a.offset - b.offset);

                        // Distribute all candidate dots with color ordering depending on WB/BW gap
                        const gapType = (whiteSemis.has(s) && blackSemis.has(nextSemi)) ? 'WB'
                                       : (blackSemis.has(s) && whiteSemis.has(nextSemi)) ? 'BW' : 'OTHER';
                        const colorOrder = (gapType==='WB') ? ['red','green','blue'] : ['blue','green','red'];
                        candidates.forEach((obj,idx)=>{
                            const frac = obj.offset/100;
                            const color = colorOrder[idx % colorOrder.length];
                            addMicroDot(s, Math.min(Math.max(frac, 0.02), 0.98), color, obj.step);
                        });
                    }
                }
                // After constructing all keys, resize to fit; skip dot overlap fixes in 12EDO
                this.resizeKeyboardKeys(keyboard, centersUsed);
                if (this.currentTuning !== 12) {
                    this.adjustForDotOverlap(keyboard);
                    // Removed enforceEquidistantCenters to prevent squishing layout after rotation
                    this.resizeDotsToKeySize(keyboard);
                }
                // Reapply highlight if a chord is currently active
                try {
                    const activeCol = this.getActiveColumnElement?.();
                    if (activeCol) this.highlightKeyboardForColumn(activeCol);
                } catch(_){}

                // If in creation mode, re-bind interval selection to include new UI and reflect state
                if (this.chordCreationMode) {
                    this.setupIntervalSelection();
                    this.updatePreviewChordColumn();
                }
            }

            getNoteNames() {
                if (this.gamelanMode) {
                    // Gamelan pelog note names
                    return ['Bem', 'Gulu', 'Dada', 'Pelog', 'Lima', 'Nem', 'Barang'];
                }
                
                // Use microtonal directional notation system
                const names = [];
                for (let i = 0; i < this.currentTuning; i++) {
                    names.push(this.getMicrotonalNoteName(i));
                }
                return names;
            }

            getCentValue(step, tuning = null) {
                const currentTuning = tuning || this.currentTuning;
                console.log('getCentValue called with step:', step, 'tuning:', tuning, 'gamelanMode:', this.gamelanMode, 'currentTuning:', currentTuning);
                
                if (this.gamelanMode) {
                    // Gamelan pelog scale approximation in cents from root
                    const gamelanCents = [0, 136, 348, 560, 704, 840, 1056]; // 7-note pelog scale
                    const result = gamelanCents[step % 7] + (Math.floor(step / 7) * 1200);
                    console.log('gamelan cents result:', result);
                    return result;
                }
                const result = (step * 1200) / currentTuning;
                console.log('equal temperament cents result:', result);
                return result;
            }

            // Find nearest EDO step (index) whose cent value is closest to a given 12-TET semitone center
            findNearestStepForSemitone(semitone, stepCents){
                const targetCent = semitone * 100;
                let bestIdx = 0; let bestDist = Infinity;
                stepCents.forEach((c,i)=>{
                    const dist = Math.abs((c%1200) - targetCent);
                    if(dist < bestDist){ bestDist = dist; bestIdx = i; }
                });
                return bestIdx;
            }

            // Dynamically resize circular keys to avoid overflow and keep everything after first C
            resizeKeyboardKeys(keyboard, whiteCenters){
                if(!keyboard || !whiteCenters || whiteCenters.length < 2) return;
                const kbWidth = (keyboard.clientWidth || 1000);
                const edo = this.currentTuning || 12;
                const densityFactor = edo/12;
                let diameter = 70 / densityFactor;
                const spacingPct = whiteCenters[1]-whiteCenters[0];
                const spacingPx = (spacingPct/100) * kbWidth;
                diameter = Math.min(diameter, spacingPx * 0.85);
                const minReadable = edo >= 72 ? 12 : 16;
                if (diameter < minReadable) diameter = minReadable;
                this.currentKeyDiameter = diameter;
                const renderD = diameter;
                keyboard.querySelectorAll('.white-key.root-btn').forEach(el=>{
                    el.style.width = renderD + 'px';
                    el.style.height = renderD + 'px';
                });
                keyboard.querySelectorAll('.black-key.root-btn').forEach(el=>{
                    el.style.width = renderD + 'px';
                    el.style.height = renderD + 'px';
                });
                keyboard.querySelectorAll('.edo-dot').forEach(el=>{
                    const dotD = renderD * 0.55;
                    el.style.width = dotD + 'px';
                    el.style.height = dotD + 'px';
                });
            }

            // Widen keyboard proportionally with EDO so higher divisions have more horizontal space
            adjustKeyboardWidth(keyboard){
                // Legacy function retained for compatibility; intentionally does nothing now.
                if(!keyboard) return;
            }

            // Detect dot/key overlaps; shrink keys globally until all dots clear or min size reached
            adjustForDotOverlap(keyboard){
                if(!keyboard) return;
                const kbWidth = keyboard.clientWidth || 1000;
                const percentPerPx = 100 / kbWidth;
                const padPx = 2;
                const dotRadiusPx = 10; // 20px diameter per CSS
                let diameter = this.currentKeyDiameter || 70;
                const minDiameter = 34;
                const dots = Array.from(keyboard.querySelectorAll('.edo-dot'));
                if(!dots.length) return;
                const getOverlapExists = ()=>{
                    const keyCenters = [];
                    keyboard.querySelectorAll('.white-key.root-btn, .black-key.root-btn').forEach(k=>{
                        const leftPct = parseFloat(k.style.left);
                        keyCenters.push(leftPct);
                    });
                    const keyRadiusPct = (diameter/2) * percentPerPx;
                    const dotRadiusPct = dotRadiusPx * percentPerPx;
                    const padPct = padPx * percentPerPx;
                    for(const d of dots){
                        const dPct = parseFloat(d.style.left);
                        for(const kc of keyCenters){
                            if (Math.abs(dPct - kc) < (keyRadiusPct + dotRadiusPct + padPct)){
                                return true;
                            }
                        }
                    }
                    return false;
                };
                let guard=0;
                while(getOverlapExists() && diameter>minDiameter && guard<20){
                    guard++;
                    diameter -= 3; // shrink step
                    this.currentKeyDiameter = diameter;
                    // Use the same scale logic as in resizeKeyboardKeys
                    const renderD = diameter;
                    keyboard.querySelectorAll('.white-key.root-btn').forEach(el=>{
                        el.style.width = renderD + 'px';
                        el.style.height = renderD + 'px';
                    });
                    keyboard.querySelectorAll('.black-key.root-btn').forEach(el=>{
                        el.style.width = renderD + 'px';
                        el.style.height = renderD + 'px';
                    });
                }
             }

            // Reposition all key & dot centers to be perfectly equidistant while preserving ordering
            enforceEquidistantCenters(keyboard){
                if(!keyboard) return;
                const all = Array.from(keyboard.querySelectorAll('.white-key.root-btn, .black-key.root-btn, .edo-dot'));
                if(all.length < 2) return;
                // Sort by current left
                all.sort((a,b)=> parseFloat(a.style.left) - parseFloat(b.style.left));
                // Determine first C (white key with label starting C) to lock at current position
                const firstCEl = all.find(el=> el.classList.contains('white-key') && /C/.test(el.textContent));
                const firstLeft = firstCEl ? parseFloat(firstCEl.style.left) : parseFloat(all[0].style.left);
                const lastEl = all[all.length-1];
                const lastLeft = parseFloat(lastEl.style.left);
                if (lastLeft <= firstLeft) return;
                // If any element already exceeds 100%, abort normalization (shouldn't happen after earlier clamps)
                if (all.some(el=> parseFloat(el.style.left) > 100)) return;
                const span = lastLeft - firstLeft;
                const uniformGap = span / (all.length - 1);
                all.forEach((el,idx)=>{
                    if (el===firstCEl || el===lastEl) return; // lock ends
                    const newLeft = firstLeft + idx*uniformGap;
                    // Safety clamp
                    el.style.left = Math.min(99.5, Math.max(firstLeft, newLeft)) + '%';
                });
            }

            // Make colored micro dots same diameter as (reduced) black/white keys for easier tapping
            resizeDotsToKeySize(keyboard){
                if(!keyboard) return;
                const diameter = (this.currentKeyDiameter || 70) * 0.97; // match black key size
                keyboard.querySelectorAll('.edo-dot').forEach(dot=>{
                    dot.style.width = diameter + 'px';
                    dot.style.height = diameter + 'px';
                    dot.style.lineHeight = diameter + 'px';
                    // Adjust font size relative to diameter
                    const fs = Math.max(10, Math.min(14, diameter * 0.22));
                    dot.style.fontSize = fs + 'px';
                });
            }

            getFrequency(step, octave = 4, tuning = null) {
                console.log('getFrequency called with step:', step, 'octave:', octave, 'tuning:', tuning, 'currentTuning:', this.currentTuning);
                
                const cents = this.getCentValue(step, tuning);
                console.log('cents calculated:', cents);
                
                // Use C4 as base frequency (261.626 Hz) since step 0 = C
                const baseFreq = 261.626 * Math.pow(2, (octave - 4)); // C4 = 261.626Hz
                console.log('baseFreq calculated:', baseFreq);
                
                const finalFreq = baseFreq * Math.pow(2, cents / 1200);
                console.log('finalFreq calculated:', finalFreq);
                
                if (isNaN(finalFreq)) {
                    console.error('NaN frequency detected! step:', step, 'octave:', octave, 'cents:', cents, 'baseFreq:', baseFreq);
                }
                
                return finalFreq;
            }

            generateChordPattern(extensions) {
                // Generate a pattern of chord intervals
                const intervals = this.getChordIntervals(extensions);
                return intervals;
            }

            getTuningDivisions() {
                return this.currentTuning;
            }

            getNoteName(noteIndex) {
                if (noteIndex === undefined || noteIndex === null) {
                    return 'C'; // Default to C if undefined
                }
                const noteNames = this.getNoteNames();
                return noteNames[noteIndex] || noteIndex.toString();
            }

            getChordIntervals(extensions = []) {
                let intervals = [0]; // Root
                
                // Base triad
                switch (this.currentQuality) {
                    case 'major':
                        intervals.push(Math.round(4 * this.currentTuning / 12)); // Major third
                        intervals.push(Math.round(7 * this.currentTuning / 12)); // Perfect fifth
                        break;
                    case 'minor':
                        intervals.push(Math.round(3 * this.currentTuning / 12)); // Minor third
                        intervals.push(Math.round(7 * this.currentTuning / 12)); // Perfect fifth
                        break;
                    case 'neutral':
                        intervals.push(Math.round(3.5 * this.currentTuning / 12)); // Neutral third
                        intervals.push(Math.round(7 * this.currentTuning / 12)); // Perfect fifth
                        break;
                }
                
                // Apply extensions
                extensions.forEach(ext => {
                    switch (ext) {
                        case '6':
                            intervals.push(Math.round(9 * this.currentTuning / 12));
                            break;
                        case '7':
                            intervals.push(Math.round(10 * this.currentTuning / 12));
                            break;
                        case 'maj7':
                            intervals.push(Math.round(11 * this.currentTuning / 12));
                            break;
                        case '9':
                            intervals.push(Math.round(10 * this.currentTuning / 12)); // Add 7th first
                            intervals.push(Math.round(14 * this.currentTuning / 12)); // Then 9th
                            break;
                        case 'sus2':
                            intervals = intervals.filter(i => i !== Math.round(4 * this.currentTuning / 12) && i !== Math.round(3 * this.currentTuning / 12) && i !== Math.round(3.5 * this.currentTuning / 12));
                            intervals.push(Math.round(2 * this.currentTuning / 12));
                            break;
                        case 'sus4':
                            intervals = intervals.filter(i => i !== Math.round(4 * this.currentTuning / 12) && i !== Math.round(3 * this.currentTuning / 12) && i !== Math.round(3.5 * this.currentTuning / 12));
                            intervals.push(Math.round(5 * this.currentTuning / 12));
                            break;
                        case 'add9':
                            intervals.push(Math.round(14 * this.currentTuning / 12));
                            break;
                        case '13':
                            intervals.push(Math.round(10 * this.currentTuning / 12)); // Add 7th
                            intervals.push(Math.round(21 * this.currentTuning / 12)); // Add 13th
                            break;
                        case '#11':
                            intervals.push(Math.round(18 * this.currentTuning / 12)); // #11
                            break;
                        case '7#9':
                            intervals.push(Math.round(10 * this.currentTuning / 12)); // 7th
                            intervals.push(Math.round(15 * this.currentTuning / 12)); // #9 (raised 9th)
                            break;
                        case '#9':
                            intervals.push(Math.round(15 * this.currentTuning / 12)); // #9 (raised 9th)
                            break;
                        case 'n7':
                            intervals.push(Math.round(10.5 * this.currentTuning / 12)); // neutral 7th
                            break;
                        case 'n11':
                            intervals.push(Math.round(16.5 * this.currentTuning / 12)); // neutral 11th
                            break;
                    }
                });
                
                return [...new Set(intervals)].sort((a, b) => a - b);
            }

            // Build the visible sequence string from current columns, preserving sections "|"
            buildCurrentSequenceString(includeSections = true) {
                const cols = Array.from(document.querySelectorAll('#extensionColumns .extension-column'));
                const parts = [];
                cols.forEach(col => {
                    const nameEl = col.querySelector('.extension-header .chord-name');
                    if (!nameEl) return;
                    const t = (nameEl.dataset.lockedName || nameEl.textContent || '').trim();
                    if (!t) return;
                    if (t === '|' || col.dataset.chordId === '__SECTION__') {
                        if (includeSections) parts.push('|');
                    } else {
                        parts.push(t);
                    }
                });
                return parts.join(' ');
            }
            
            regenerateAllColumnsPreservingLocks() {
                console.log('?? Regenerating all columns while preserving locked chord settings');
                
                // Get all current columns
                const container = document.getElementById('extensionColumns');
                const allColumns = Array.from(container.querySelectorAll('.extension-column'));
                
                // For each column, regenerate its strings using appropriate settings
                allColumns.forEach(column => {
                    const isLocked = this.lockedChords && this.lockedChords.has(column);
                    
                    if (isLocked) {
                        // This column is locked - regenerate using its locked settings
                        const lockedChord = this.lockedChords.get(column);
                        console.log('?? Regenerating locked column:', lockedChord.chordName, 'with locked root:', lockedChord.lockedRoot);
                        
                        // Resolve the backing chord model by stable id/position if possible
                        let chordExt = null;
                        try {
                            if (column.dataset.chordId) {
                                chordExt = (this.chordExtensions || []).find(c => String(c.id) === String(column.dataset.chordId));
                            }
                            if (!chordExt && column.dataset.originalPosition != null) {
                                const op = parseInt(column.dataset.originalPosition, 10);
                                if (!isNaN(op) && op >= 0 && this.chordExtensions && this.chordExtensions[op]) {
                                    chordExt = this.chordExtensions[op];
                                }
                            }
                        } catch(_) {}
                        // Fallback to name match only if id/position not found
                        if (!chordExt) {
                            chordExt = this.chordExtensions.find(ext => 
                                ext.name === lockedChord.chordName || 
                                ext.name === lockedChord.originalChordName ||
                                (ext.symbol && lockedChord.chordName && lockedChord.chordName.includes(ext.symbol))
                            );
                        }
                        
                        if (chordExt) {
                            // Clear existing strings and regenerate with locked settings
                            const stringsContainer = column.querySelector('.strings-column');
                            if (stringsContainer) {
                                stringsContainer.remove();
                            }
                            
                            // Generate strings using locked settings
                            this.generateStringsForColumnWithLockedSettings(column, chordExt.intervals, lockedChord);
                        }
                    } else {
                        // This column is unlocked - regenerate using current global settings
                        // Resolve the backing chord model by stable id/position; do not depend on header text
                        let chordExt = null;
                        try {
                            if (column.dataset.chordId) {
                                chordExt = (this.chordExtensions || []).find(c => String(c.id) === String(column.dataset.chordId));
                            }
                            if (!chordExt && column.dataset.originalPosition != null) {
                                const op = parseInt(column.dataset.originalPosition, 10);
                                if (!isNaN(op) && op >= 0 && this.chordExtensions && this.chordExtensions[op]) {
                                    chordExt = this.chordExtensions[op];
                                }
                            }
                        } catch(_) {}
                        console.log('?? Regenerating unlocked column using model:', chordExt?.name, 'with current root:', this.currentRoot, 'transposeDelta:', this.transposeDelta);
                        
                        if (chordExt) {
                            // Clear existing strings and regenerate with current settings
                            const stringsContainer = column.querySelector('.strings-column');
                            if (stringsContainer) {
                                stringsContainer.remove();
                            }
                            
                            // Generate strings using current global settings
                            this.generateStringsForColumn(column, chordExt.intervals, chordExt.isCustom);
                        }
                    }
                });
                
                console.log('?? Completed regeneration preserving', this.lockedChords ? this.lockedChords.size : 0, 'locked chords');
            }

            regenerateUnlockedChordsOnly() {
                console.log('?? Regenerating only unlocked chords, preserving locked ones exactly as they are');
                
                if (!this.lockedChords || this.lockedChords.size === 0) {
                    // No locked chords, just regenerate everything normally
                    console.log('?? No locked chords found, regenerating all chords normally');
                    this.preserveLockedChordsAndRegenerate();
                    return;
                }
                
                // Get all columns currently in the DOM
                const container = document.getElementById('extensionColumns');
                const existingColumns = Array.from(container.querySelectorAll('.extension-column'));
                
                console.log('?? Found', existingColumns.length, 'existing columns,', this.lockedChords.size, 'are locked');
                
                // Separate locked and unlocked columns
                const lockedColumns = [];
                const unlockedColumns = [];
                
                existingColumns.forEach(column => {
                    if (this.lockedChords.has(column)) {
                        lockedColumns.push(column);
                        console.log('?? Preserving locked column:', column.querySelector('.chord-name')?.textContent);
                    } else {
                        unlockedColumns.push(column);
                        console.log('?? Will regenerate unlocked column:', column.querySelector('.chord-name')?.textContent);
                    }
                });
                
                // Remove only the unlocked columns from DOM (keep locked ones in place)
                unlockedColumns.forEach(column => {
                    column.remove();
                });
                
                // Update chord names in locked columns to ensure they display correctly
                // but preserve their locked root information
                lockedColumns.forEach(column => {
                    const lockedChord = this.lockedChords.get(column);
                    if (lockedChord) {
                        const chordNameElement = column.querySelector('.chord-name');
                        if (chordNameElement) {
                            // Keep the locked chord name exactly as it was locked
                            // This prevents it from being rewritten with the new root
                            const lockedName = lockedChord.chordName;
                            chordNameElement.textContent = `🔒 ${lockedName}`;
                            chordNameElement.style.color = '#4CAF50';
                            chordNameElement.style.fontWeight = 'bold';
                            
                            const rootName = this.getNoteNames()[lockedChord.lockedRoot] || lockedChord.lockedRoot;
                            chordNameElement.title = `LOCKED: ${rootName} root, ${lockedChord.lockedTuning}TET, ${lockedChord.lockedOsc1.type}/${lockedChord.lockedOsc2.type} waves`;
                            
                            console.log('?? Preserved locked chord display:', lockedName, 'locked to root:', lockedChord.lockedRoot);
                        }
                    }
                });
                
                // Now regenerate only the chord extensions that correspond to unlocked columns
                // Find which chord extensions were unlocked
                const unlockedExtensions = this.chordExtensions.filter(ext => {
                    // Check if this extension had a locked column
                    const wasLocked = lockedColumns.some(column => {
                        const lockedChord = this.lockedChords.get(column);
                        return lockedChord && (
                            ext.name === lockedChord.chordName ||
                            (ext.isCustom && lockedChord.lockId && lockedChord.lockId.includes(ext.id || ext.name))
                        );
                    });
                    return !wasLocked;
                });
                
                console.log('?? Found', unlockedExtensions.length, 'unlocked extensions to regenerate');
                
                // Generate new columns for unlocked extensions with the new root
                unlockedExtensions.forEach(ext => {
                    console.log('?? Regenerating column for unlocked extension:', ext.name);
                    this.generateSingleChordColumn(ext, container);
                });
                
                console.log('?? Completed regeneration - preserved', lockedColumns.length, 'locked chords, regenerated', unlockedExtensions.length, 'unlocked chords');
            }
            
            generateSingleChordColumn(chordExt, container) {
                // This function generates a single chord column for the given chord extension
                // This is extracted from the main generateExtensionColumns function
                const noteNames = this.getNoteNames();
                
                const column = document.createElement('div');
                column.className = 'extension-column';
                // Provide stable identifiers so delete/reorder logic can map back to data
                try {
                    const absoluteIndex = (typeof chordExt.position === 'number')
                        ? chordExt.position
                        : (this.findChordIndex ? this.findChordIndex(chordExt) : (this.chordExtensions ? this.chordExtensions.indexOf(chordExt) : -1));
                    if (absoluteIndex !== -1) column.dataset.originalPosition = String(absoluteIndex);
                    const slug = (chordExt.id || (chordExt.name || '').toLowerCase().replace(/\s+/g, '_'));
                    column.dataset.chordId = slug;
                    column.dataset.chordType = slug;
                } catch (_) { /* non-fatal */ }
                column.style.flex = '1';
                column.style.height = '100%';
                column.style.border = 'none';
                column.style.borderRadius = '0';
                column.style.margin = '0';
                column.style.padding = '0';
                
                // Create header with chord name and action buttons
                const header = document.createElement('div');
                header.className = 'extension-header';
                
                // Create chord name span
                const chordName = document.createElement('span');
                chordName.className = 'chord-name';
                chordName.textContent = chordExt.name;
                
                // Create buttons container
                const buttonsContainer = document.createElement('div');
                buttonsContainer.className = 'header-buttons';
                
                // Duplicate and full padlock removed per requirements
                
                // piano-lock button removed: instrument presets handle sound recall now
                // (buttonsContainer kept for other action buttons)
                
                header.appendChild(chordName);
                header.appendChild(buttonsContainer);
                
                // Color coding by type
                let qualityColor;
                if (chordExt.name === 'Major') qualityColor = { bg: '#1e40af', border: '#3b82f6' };
                else if (chordExt.name === 'Neutral') qualityColor = { bg: '#059669', border: '#10b981' };
                else if (chordExt.name === 'Minor') qualityColor = { bg: '#dc2626', border: '#ef4444' };
                else qualityColor = { bg: '#4a5568', border: '#718096' }; // Default for custom
                
                header.style.backgroundColor = qualityColor.bg;
                header.style.borderColor = qualityColor.border;
                header.style.color = 'white';
                header.style.border = `1px solid ${qualityColor.border}`;
                
                // Add context menu handlers
                header.addEventListener('click', (e) => {
                    // Don't interfere with header action buttons
                    if (
                        e.target.classList.contains('lock-button') ||
                        e.target.classList.contains('chord-action-button') ||
                        e.target.tagName === 'BUTTON'
                    ) {
                        return; // Let the buttons handle their own clicks
                    }
                    
                    console.log('?? Single chord header clicked:', chordExt.name);
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const columnData = {
                        name: chordExt.name,
                        extensions: chordExt.extensions || [],
                        quality: chordExt.name.toLowerCase(),
                        id: chordExt.name.toLowerCase().replace(/\s+/g, '_'),
                        intervals: this.getChordIntervals(chordExt.extensions || []),
                        isCustom: chordExt.isCustom || false
                    };
                    
                    this.currentEditingColumn = columnData;
                    this.showColumnContextMenu(e.clientX, e.clientY);
                });
                
                column.appendChild(header);
                
                // Generate strings for this chord using the shared renderer
                const intervals = this.getChordIntervals(chordExt.extensions || []);
                this.generateStringsForColumn(column, intervals, chordExt.isCustom || false);
                
                // Add to container
                container.appendChild(column);
                
                // Ensure new single-generated columns are draggable like others
                if (this.attachColumnDragHandlers) {
                    this.attachColumnDragHandlers(column);
                }
                
                return column;
            }
            
            preserveLockedChordsAndRegenerate() {
                console.log('?? Preserving locked chords before regeneration');
                
                // Store current locked chords before regeneration
                if (this.lockedChords && this.lockedChords.size > 0) {
                    this.savedLockedChords = Array.from(this.lockedChords.values());
                    console.log('?? Saved', this.savedLockedChords.length, 'locked chords before regeneration');
                    
                    // Store the original root before any changes occur
                    const originalRoot = this.currentRoot;
                    console.log('?? Original root before regeneration:', originalRoot);
                    
                    // CRITICAL: Preserve the chord extensions that are locked
                    // Don't let them get overwritten during regeneration
                    this.savedLockedChords.forEach(lockedChord => {
                        console.log('?? Preserving chord extension for locked chord:', lockedChord.chordName, 'with locked root:', lockedChord.lockedRoot);
                        
                        // Find the corresponding chord extension and mark it as locked
                        const chordExtension = this.chordExtensions.find(ext => {
                            // Try exact match first
                            if (ext.name === lockedChord.chordName) return true;
                            
                            // Try match with root prefix removed (e.g. "CTetrad" -> "Tetrad")
                            const nameWithoutRoot = lockedChord.chordName.replace(/^[A-G][#b]?/, '');
                            if (ext.name === nameWithoutRoot) return true;
                            
                            // Try custom chord match
                            if (ext.isCustom && lockedChord.lockId && lockedChord.lockId.includes(ext.id || ext.name)) return true;
                            
                            return false;
                        });
                        
                        if (chordExtension) {
                            // Mark this extension as locked so it won't be modified
                            chordExtension.isLocked = true;
                            chordExtension.lockedData = lockedChord;
                            console.log('?? Marked chord extension as locked:', chordExtension.name, 'for locked chord:', lockedChord.chordName);
                        } else {
                            console.warn('?? Could not find chord extension for locked chord:', lockedChord.chordName);
                        }
                    });
                }
                
                // Store current piano locked chords before regeneration
                if (this.pianoLockedChords && this.pianoLockedChords.size > 0) {
                    this.savedPianoLockedChords = Array.from(this.pianoLockedChords.values());
                    console.log('🎹 Saved', this.savedPianoLockedChords.length, 'piano locked chords before regeneration');
                    
                    // Mark chord extensions as piano locked
                    this.savedPianoLockedChords.forEach(pianoLockedData => {
                        const chordExtension = this.chordExtensions.find(ext => ext.name === pianoLockedData.chordName);
                        if (chordExtension) {
                            chordExtension.isPianoLocked = true;
                            chordExtension.pianoLockedData = pianoLockedData;
                            console.log('🎹 Marked chord extension as piano locked:', chordExtension.name);
                        }
                    });
                }
                
                // Clear the Maps since DOM elements will be destroyed
                this.lockedChords = new Map();
                this.pianoLockedChords = new Map();
                
                // Check if we have custom chords - if so, use exact regeneration
                const hasCustomChords = this.chordExtensions.some(chord => chord.isCustom);
                
                if (hasCustomChords) {
                    console.log('?? Has custom chords - using exact regeneration');
                    this.generateExactChordColumns();
                } else {
                    console.log('?? No custom chords - using standard regeneration');
                    this.generateExtensionColumns();
                }
            }

            generateExtensionColumns() {
                // Generating extension columns for current tuning
                const container = document.getElementById('extensionColumns');
                
                // Clear container completely to remove any leftover columns
                container.innerHTML = '';
                container.style.display = 'flex';
                container.style.gap = '0px';
                container.style.width = '100%';
                container.style.height = '100%';
                // Always reset to one-row layout by default; we may switch to two rows below
                container.style.flexDirection = 'row';
                
                const noteNames = this.getNoteNames();
                
                // Initialize hiddenColumns if not exists
                if (!this.hiddenColumns) {
                    this.hiddenColumns = [];
                }
                
                // Map chord extensions to identifiers for hiding (per-instance)
                const chordIds = this.chordExtensions.map((chord, index) => {
                    const id = (chord.id || (chord.name + '_' + index)).toLowerCase().replace(/\s+/g, '_');
                    console.log(`Mapping chord ${index}: "${chord.name}" -> ID: "${id}"`);
                    return id;
                });
                
                // Filter visible chord extensions
                const visibleExtensions = this.chordExtensions.filter((chordExt, index) => {
                    const chordId = chordIds[index];
                    const isVisible = !this.hiddenColumns.includes(chordId);
                    console.log(`Extension ${index}: "${chordExt.name}" (ID: ${chordId}) - Visible: ${isVisible}`);
                    return isVisible;
                });
                
                console.log('?? Visible extensions:', visibleExtensions.length, 'chords:', visibleExtensions.map(c => c.name));
                
                // If no visible extensions, show empty interface (only locked chords should be loaded)
                if (visibleExtensions.length === 0) {
                    console.log('?? No visible extensions - showing empty interface');
                    // Show message for empty state
                    container.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; color: #8fb3d3; font-size: 16px; text-align: center; flex-direction: column;">
                            <div style="margin-bottom: 10px;">No chords loaded</div>
                            <div style="font-size: 12px; opacity: 0.7;">Lock chords to save them, or use the chord builder to create new ones</div>
                        </div>
                    `;
                    
                    // Still restore locked chord states if they exist
                    this.restoreLockedChordStates();
                    return;
                }
                
                // Layout: split into two rows if many columns
                const useTwoRows = visibleExtensions.length > 16;
                let rowTop, rowBottom;
                if (useTwoRows) {
                    container.style.flexDirection = 'column';
                    rowTop = document.createElement('div');
                    rowBottom = document.createElement('div');
                    Object.assign(rowTop.style, { display:'flex', gap:'0px', width:'100%', height:'50%' });
                    Object.assign(rowBottom.style, { display:'flex', gap:'0px', width:'100%', height:'50%' });
                    container.appendChild(rowTop);
                    container.appendChild(rowBottom);
                }

                // Always use simple layout - one column per chord type (no more variants)
                console.log('Creating modern chord layout - each chord gets its own column');
                visibleExtensions.forEach((chordExt, extensionIndex) => {
                    // Render section separator as a thin dummy column
                    if (chordExt.isSeparator || chordExt.name === '|') {
                        const sepCol = document.createElement('div');
                        sepCol.className = 'extension-separator';
                        sepCol.style.width = '30px';
                        sepCol.style.minWidth = '30px';
                        sepCol.style.maxWidth = '30px';
                        sepCol.style.height = '100%';
                        sepCol.style.flex = '0 0 30px';
                        sepCol.style.background = 'transparent';
                        sepCol.style.borderLeft = '2px solid rgba(255,255,255,0.15)';
                        sepCol.style.boxShadow = 'inset 0 0 12px rgba(255,255,255,0.08)';
                        if (useTwoRows) {
                            const half = Math.ceil(visibleExtensions.length / 2);
                            const targetRow = extensionIndex < half ? rowTop : rowBottom;
                            targetRow.appendChild(sepCol);
                        } else {
                            container.appendChild(sepCol);
                        }
                        return; // go to next item
                    }
                    const column = document.createElement('div');
                    column.className = 'extension-column';
                    column.dataset.chordType = chordIds[this.chordExtensions.indexOf(chordExt)];
                    // Persist absolute index to support precise mapping for delete/reorder without DOM recreation
                    try {
                        const absoluteIndex = (typeof chordExt.position === 'number') ? chordExt.position : (this.findChordIndex ? this.findChordIndex(chordExt) : this.chordExtensions.indexOf(chordExt));
                        column.dataset.originalPosition = String(absoluteIndex);
                        column.dataset.chordId = chordExt.id || column.dataset.chordType;
                        if (!column.dataset.instanceId) {
                            column.dataset.instanceId = `${column.dataset.chordId}__${Date.now()}_${Math.floor(Math.random()*1e6)}`;
                        }
                    } catch (_) { /* non-fatal */ }
                    column.style.flex = '1'; // Each column takes equal width
                    column.style.height = '100%';
                    column.style.border = 'none';
                    column.style.borderRadius = '0';
                    column.style.margin = '0';
                    column.style.padding = '0';
                    
                    // Create header with chord name and action buttons
                    const header = document.createElement('div');
                    header.className = 'extension-header';
                    
                    // Create chord name span
                    const chordName = document.createElement('span');
                    chordName.className = 'chord-name';
                    
                    // Check if this chord extension is locked and preserve its locked name
                    if (chordExt.isLocked && chordExt.lockedData) {
                        const lockedData = chordExt.lockedData;
                        const rootName = this.getNoteNames()[lockedData.lockedRoot] || lockedData.lockedRoot;
                        
                        // Use the locked name exactly as it was when locked
                        if (lockedData.chordName.match(/^[A-G][#b]?/)) {
                            chordName.textContent = lockedData.chordName;
                        } else {
                            chordName.textContent = `${rootName}${lockedData.chordName}`;
                        }
                        
                        chordName.style.color = '#4CAF50';
                        chordName.style.fontWeight = 'bold';
                        chordName.dataset.isLocked = 'true';
                        chordName.dataset.lockedName = chordName.textContent;
                        chordName.title = `🔒 LOCKED: ${rootName} root, ${lockedData.lockedTuning}TET, ${lockedData.lockedOsc1.type}/${lockedData.lockedOsc2.type} waves`;
                    } else {
                        // Regular unlocked chord - use current name
                        chordName.textContent = chordExt.name;
                    }
                    
                    // Create buttons container
                    const buttonsContainer = document.createElement('div');
                    buttonsContainer.className = 'header-buttons';
                    
                    // Create hide button (ALWAYS VISIBLE)
                    // Delete button removed — delete via upward drag
                    
                    // Duplicate removed per requirements

                    // Per-column transpose controls
                    const downBtn = document.createElement('button');
                    downBtn.className = 'chord-action-button transpose-down';
                    downBtn.title = 'Transpose this chord down one step';
                    downBtn.textContent = '▼';
                    const upBtn = document.createElement('button');
                    upBtn.className = 'chord-action-button transpose-up';
                    upBtn.title = 'Transpose this chord up one step';
                    upBtn.textContent = '▲';
                    // Prevent double-fire on touch; normalize modulo
                    let _pressGuard = false;
                    const norm = (v, m)=> ((v % m) + m) % m;
                    const applyLocalTranspose = (delta)=>{
                        if (_pressGuard) return; // collapse duplicate pointer sequences
                        _pressGuard = true;
                        const edoNow = (chordExt.lockedData?.lockedTuning) || this.currentTuning || 12;
                        chordExt.localTranspose = norm((chordExt.localTranspose||0) + delta, edoNow);
                        const prev = (+column.dataset.localTranspose || 0);
                        column.dataset.localTranspose = String(norm(prev + delta, edoNow));

                        const lockedData = chordExt.lockedData || this.lockedChords?.get(column);
                        if (lockedData && typeof lockedData.lockedRoot === 'number') {
                            const edo = lockedData.lockedTuning || edoNow;
                            const base = lockedData.lockedRoot;
                            const step = ((base + (chordExt.localTranspose||0)) % edo + edo) % edo;
                            const newRoot = this.getRootNameForStep(step, edo);
                            const rest = (lockedData.chordName || '').replace(/^[A-G][#b]?\s*/, '');
                            chordName.textContent = `${newRoot}${rest}`;
                            chordName.dataset.lockedName = chordName.textContent;
                            // Clear any exact snapshot so transpose can take effect
                            if (lockedData.exactFrequencies && lockedData.exactFrequencies.length) {
                                lockedData.exactFrequencies = [];
                            }
                            // Also clear the central map's snapshot if present (preset-derived locks)
                            try {
                                const mapLocked = this.lockedChords?.get(column);
                                if (mapLocked && Array.isArray(mapLocked.exactFrequencies) && mapLocked.exactFrequencies.length) {
                                    mapLocked.exactFrequencies = [];
                                }
                            } catch (_) {}
                            const oldContainer = column.querySelector('.strings-column');
                            if (oldContainer) oldContainer.remove();
                            this.generateStringsForColumnWithLockedSettings(column, chordExt.intervals || [0], lockedData);
                            // Ensure key lights follow the new effective tones
                            try { this.currentActiveColumnEl = column; this.highlightKeyboardForColumn(column); } catch {}
                            // Refresh header accent to match new effective root
                            try {
                                const hdr = column.querySelector('.extension-header');
                                const tuningSize = lockedData.lockedTuning || this.currentTuning || 12;
                                const semi = this.stepToSemitone(step, tuningSize);
                                const accent = this.getChromaticColorForSemitone(semi);
                                const text = this.pickTextColor(accent);
                                hdr.style.background = accent;
                                hdr.style.borderBottom = `2px solid ${accent}`;
                                hdr.style.boxShadow = `0 0 10px ${accent}55`;
                                hdr.style.color = text;
                            } catch {}
                        } else {
                            // Unlocked: compute from CURRENT displayed step + delta only (no cumulative add)
                            const label = (chordName.dataset.lockedName || chordName.textContent || '').trim();
                            const m = label.match(/^([A-G])([#b]?)([\^v]*)(.*)$/);
                            if (m) {
                                const rest = m[4]||'';
                                const rootSemi = this.rootToSemitone(m[1], m[2]||'');
                                const edo = this.getTuningStepsPerOctave();
                                const step0 = Math.round((rootSemi * edo)/12);
                                const ups = (m[3].match(/\^/g) || []).length;
                                const downs = (m[3].match(/v/g) || []).length;
                                const currentStep = ((step0 + ups - downs) % edo + edo) % edo;
                                const nextStep = ((currentStep + delta) % edo + edo) % edo;
                                const newRoot = this.getRootNameForStep(nextStep, edo);
                                chordName.textContent = `${newRoot}${rest}`;
                                // Persist the updated label so subsequent transposes build from the latest state
                                chordName.dataset.lockedName = chordName.textContent;
                            }
                            const oldContainer = column.querySelector('.strings-column');
                            if (oldContainer) oldContainer.remove();
                            this.generateStringsForColumn(column, chordExt.intervals || [0], chordExt.isCustom||false);
                            // Ensure key lights follow the new effective tones
                            try { this.currentActiveColumnEl = column; this.highlightKeyboardForColumn(column); } catch {}
                            // Refresh header accent to match new effective root
                            try {
                                const hdr = column.querySelector('.extension-header');
                                const nameEl = hdr?.querySelector('.chord-name');
                                const label = nameEl ? (nameEl.dataset.lockedName || nameEl.textContent || '').trim() : '';
                                const m = label.match(/^([A-G])([#b]?)([\^v]*)/);
                                if (m) {
                                    const semi = this.rootToSemitone(m[1], m[2]||'');
                                    const edo = this.getTuningStepsPerOctave();
                                    const step0 = Math.round((semi * edo)/12);
                                    const ups = (m[3].match(/\^/g) || []).length;
                                    const downs = (m[3].match(/v/g) || []).length;
                                    const stepEff = ((step0 + ups - downs) % edo + edo) % edo;
                                    const accent = this.getChromaticColorForSemitone(this.stepToSemitone(stepEff, edo));
                                    const text = this.pickTextColor(accent);
                                    hdr.style.background = accent;
                                    hdr.style.borderBottom = `2px solid ${accent}`;
                                    hdr.style.boxShadow = `0 0 10px ${accent}55`;
                                    hdr.style.color = text;
                                }
                            } catch {}
                        }
                        Promise.resolve().then(()=>{ _pressGuard = false; });
                    };
                    const onPointer = (delta)=> (e)=>{ e.preventDefault(); e.stopPropagation(); applyLocalTranspose(delta); };
                    upBtn.addEventListener('pointerdown', onPointer(+1));
                    downBtn.addEventListener('pointerdown', onPointer(-1));

                    // Ensure per-column local transpose is initialized
                    if (!column.dataset.localTranspose) column.dataset.localTranspose = '0';

                    // Revoice and full padlock removed per requirements
                    
                    // piano-lock button removed: instrument presets handle oscillator/envelope recall

                    // pointerdown covers mouse/touch/pen without double fires
                    
                    // Add buttons to container
                    // Keep only local transpose and piano lock
                    buttonsContainer.appendChild(downBtn);
                    buttonsContainer.appendChild(upBtn);
                    
                    header.appendChild(chordName);
                    header.appendChild(buttonsContainer);
                    
                    // Color coding by type
                    let qualityColor;
                    if (chordExt.name === 'Major') qualityColor = { bg: '#1e40af', border: '#3b82f6' };
                    else if (chordExt.name === 'Neutral') qualityColor = { bg: '#059669', border: '#10b981' };
                    else if (chordExt.name === 'Minor') qualityColor = { bg: '#dc2626', border: '#ef4444' };
                    else qualityColor = { bg: '#4a5568', border: '#718096' }; // Default for custom
                    
                    header.style.backgroundColor = qualityColor.bg;
                    header.style.borderColor = qualityColor.border;
                    header.style.color = 'white';
                    header.style.border = `1px solid ${qualityColor.border}`;
                    
                    // Add context menu handlers
                    header.addEventListener('click', (e) => {
                        // Don't interfere with header action buttons
                        if (
                            e.target.classList.contains('lock-button') ||
                            
                            e.target.classList.contains('chord-action-button') ||
                            e.target.tagName === 'BUTTON'
                        ) {
                            return; // Let the buttons handle their own clicks
                        }
                        
                        console.log('🎵 Chord header clicked:', chordExt.name);
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const columnData = {
                            name: chordExt.name,
                            extensions: chordExt.extensions || [],
                            quality: chordExt.name.toLowerCase(),
                            id: chordIds[this.chordExtensions.indexOf(chordExt)],
                            isCustom: false,
                            originalName: chordExt.name,
                            extensionIndex: this.chordExtensions.indexOf(chordExt),
                            intervals: chordExt.intervals
                        };
                        
                        this.currentEditingColumn = columnData;
                        this.showColumnContextMenu(e.clientX, e.clientY);
                    });
                    
                    column.appendChild(header);
                    
                    // Add elements to header
                    header.appendChild(chordName);
                    header.appendChild(buttonsContainer);
                    
                    // Header click handler (simplified)
                    header.addEventListener('click', (e) => {
                        // Don't interfere with header action buttons
                        if (
                            e.target.classList.contains('lock-button') ||
                            
                            e.target.classList.contains('chord-action-button') ||
                            e.target.tagName === 'BUTTON'
                        ) {
                            return; // Let the buttons handle their own clicks
                        }
                        
                        console.log('🎵 Chord header clicked:', chordExt.name);
                        e.preventDefault();
                        e.stopPropagation();
                    });
                    
                    column.appendChild(header);
                    
                    // Persist the last intervals and ensure a default voicing variant for revoice
                    try { column.dataset.lastIntervals = JSON.stringify(chordExt.intervals || []); } catch(_){}
                    if (!column.dataset.voicingVariant) { column.dataset.voicingVariant = '0'; }

                    // Generate strings for this chord; prefer locked snapshot
                    if (chordExt.isLocked && chordExt.lockedData) {
                        this.generateStringsForColumnWithLockedSettings(column, chordExt.intervals, chordExt.lockedData);
                    } else {
                        this.generateStringsForColumn(column, chordExt.intervals, chordExt.isCustom || false);
                    }
                    
                    // Enable long-press drag reordering
                    this.attachColumnDragHandlers(column);
                    if (useTwoRows) {
                        const half = Math.ceil(visibleExtensions.length / 2);
                        const targetRow = extensionIndex < half ? rowTop : rowBottom;
                        targetRow.appendChild(column);
                        const sc = column.querySelector('.strings-column');
                        if (sc) sc.style.height = 'calc(100% - 42px)';
                    } else {
                        container.appendChild(column);
                    }
                });
                
                // Add click handlers after rendering
                setTimeout(() => {
                    console.log('✅ generateExtensionColumns finished, adding click handlers...');
                    this.addSimpleClickHandlers();
                    this.restoreLockedChordStates(); // Restore locked chord states
                    this.restorePianoLockStates(); // Restore piano lock states
                    console.log('✅ Click handlers and all locked states restored!');
                }, 100);
            }
            
            // Restore piano lock button states after column regeneration
            restorePianoLockStates() {
                if (!this.pianoLockedChords) return;

                console.log('🎹 Restoring piano lock states for', this.pianoLockedChords.size, 'locked chords');

                // For robustness when piano-lock UI is removed, set backend flags on one owner column per locked shape
                const columns = Array.from(document.querySelectorAll('.extension-column'));
                // Clear previous visual markers
                columns.forEach(c => c.classList.remove('piano-locked-col'));

                for (const [lockKey, data] of this.pianoLockedChords.entries()) {
                    const targetSig = (data && data.intervalsSig) ? String(data.intervalsSig) : '';
                    // Find first matching column by intervals signature and mark it as owner
                    const match = columns.find(col => {
                        try {
                            const rel = this.getChordStepsForColumn(col) || [];
                            const sig = Array.isArray(rel) ? rel.slice().map(n=>Number(n)||0).sort((a,b)=>a-b).join('.') : '';
                            return sig === targetSig;
                        } catch(_) { return false; }
                    });
                    if (match) {
                        try {
                            // Persist minimal flags on the column's chord data for other routines to read
                            const header = match.querySelector('.extension-header');
                            const cd = this.getChordDataFromColumn(match, header);
                            if (cd) {
                                cd.isPianoLocked = true;
                                cd.pianoLockedData = data;
                                cd.pianoLockKey = lockKey;
                            }
                        } catch(_) {}
                        match.classList.add('piano-locked-col');
                    }
                }
            }

            // Helper: is the currently active column piano-locked (osc/effects)?
            isActiveChordPianoLocked() {
                try {
                    const col = this.currentActiveColumnEl;
                    if (!col || !document.body.contains(col)) return false;
                    let chordData = null;
                    try {
                        const header = col.querySelector('.extension-header .chord-name');
                        if (typeof this.getChordDataFromColumn === 'function') {
                            chordData = this.getChordDataFromColumn(col, header);
                        }
                    } catch (_) {}
                    if (!chordData) {
                        chordData = {
                            name: col.dataset.chordType,
                            quality: this.currentQuality,
                            extensions: col.dataset.extensions ? col.dataset.extensions.split(',') : [],
                            intervals: []
                        };
                    }
                    const data = (typeof this.findPianoLockData === 'function') ? this.findPianoLockData(chordData) : null;
                    return !!data;
                } catch (_) {
                    return false;
                }
            }

            // Brief visual nudge on the piano-lock button when edits are blocked
            flashPianoLockFeedback() {
                try {
                    // Visual nudge now targets the column element, not a removed button
                    const col = this.currentActiveColumnEl;
                    if (!col) return;
                    const prevShadow = col.style.boxShadow;
                    const prevTransform = col.style.transform;
                    col.style.boxShadow = '0 0 16px rgba(139, 92, 246, 0.6)';
                    col.style.transform = 'scale(1.01)';
                    setTimeout(() => { col.style.boxShadow = prevShadow; col.style.transform = prevTransform; }, 200);
                } catch (_) {}
            }
            
            getIntervalColor(interval) {
                // Neon color coding for musical intervals with microtonal gradient support
                const normalizedInterval = ((interval % 12) + 12) % 12;

                // Requested palette mapping (0-11):
                // 0 White, 1 Deep Violet, 2 Bright Orange, 3 Blue, 4 Red,
                // 5 Cyan, 6 Black, 7 Green, 8 Magenta, 9 Bright Yellow,
                // 10 Dark Blue, 11 Lime Green
                const chromaticColors = [
                    { interval: 0, color: '#EEEEEE', name: 'Root' },           // White
                    { interval: 1, color: '#5A0D5D', name: 'm2/♭9' },          // Deep Violet
                    { interval: 2, color: '#99A500', name: 'M2/9' },           // Bright Orange
                    { interval: 3, color: '#0000CC', name: 'm3' },             // Blue
                    { interval: 4, color: '#CC0000', name: 'M3' },             // Red
                    { interval: 5, color: '#00CCCC', name: 'P4/11' },          // Cyan
                    { interval: 6, color: '#C0C0C0', name: 'TT' },             // Silver (tritone)
                    { interval: 7, color: '#00CC00', name: 'P5' },             // Green
                    { interval: 8, color: '#CC00CC', name: 'm6/♯5' },          // Magenta
                    { interval: 9, color: '#EEEE00', name: 'M6/13' },          // Bright Yellow
                    { interval: 10, color: '#00008B', name: 'm7' },            // Dark Blue
                    { interval: 11, color: '#229D22', name: 'M7' },            // Lime Green
                ];

                // Exact chromatic matches
                for (let i = 0; i < chromaticColors.length; i++) {
                    const chromatic = chromaticColors[i];
                    if (Math.abs(normalizedInterval - chromatic.interval) < 0.05) {
                        return { color: chromatic.color, name: chromatic.name };
                    }
                }

                // Microtonal interpolation between adjacent chromatic steps
                for (let i = 0; i < chromaticColors.length; i++) {
                    const current = chromaticColors[i];
                    const next = chromaticColors[(i + 1) % chromaticColors.length];

                    let lowerBound = current.interval;
                    let upperBound = next.interval;
                    if (next.interval < current.interval) upperBound = next.interval + 12; // wrap

                    let testInterval = normalizedInterval;
                    if (upperBound > 12 && normalizedInterval < 6) testInterval = normalizedInterval + 12;

                    if (testInterval > lowerBound + 0.05 && testInterval < upperBound - 0.05) {
                        const position = (testInterval - lowerBound) / (upperBound - lowerBound);
                        const gradientColor = this.interpolateColors(current.color, next.color, position);
                        const cents = Math.round((normalizedInterval - Math.floor(normalizedInterval)) * 100);
                        const baseName = current.name.split('/')[0];
                        const gradientName = `${baseName}+${cents}¢`;
                        return { color: gradientColor, name: gradientName };
                    }
                }

                return { color: '#CCCCCC', name: 'Unknown' };
            }

            // Map an EDO step to nearest 12-TET semitone index (0..11)
            stepToSemitone(step, edo) {
                if (edo <= 0) return 0;
                const semi = Math.round((step * 12) / edo) % 12;
                return ((semi % 12) + 12) % 12;
            }
            // Map a 12-TET semitone (0..11) to the nearest step in a given EDO
            semitoneToStep(semi, edo) {
                if (!edo || edo <= 0) return 0;
                const s = Math.round(((semi % 12 + 12) % 12) * edo / 12);
                return ((s % edo) + edo) % edo;
            }
            
            // Root selection: leftmost (lowest) note unless a clear major/minor triad exists on another pitch;
            // slash only when bass is the (flat/neutral) seventh
            computeFullChordNameFromAbsoluteSteps(absSteps, edo = (this.currentTuning || 12), preferredBassAbs = null){
                if (!Array.isArray(absSteps) || absSteps.length < 2) return '';
                // Apply global transpose to reflect what you hear
                const t = (this.transposeDelta || 0) % edo;
                const norm = absSteps.map(s => (((s + t) % edo) + edo) % edo);
                const steps = Array.from(new Set(norm));
                if (steps.length < 2) return '';

                // Bass candidate: prefer provided; else lowest by 12-TET approximation (leftmost)
                const bassAbs = (preferredBassAbs != null)
                    ? (((preferredBassAbs + t) % edo) + edo) % edo
                    : steps.slice().sort((a,b)=> this.stepToSemitone(a, edo) - this.stepToSemitone(b, edo))[0];

                // Override rule: if any pitch in the set forms a clear maj/min triad with the others, use that as root
                let rootAbs = bassAbs;
                const triadFound = (()=>{
                    const targetMaj = new Set([0,4,7]);
                    const targetMin = new Set([0,3,7]);
                    const to12 = (step)=> this.stepToSemitone(step, edo);
                    for (const cand of steps) {
                        const rSemi = to12(cand);
                        const rel12 = [...new Set(steps.map(s=> ((to12(s) - rSemi + 12) % 12)))].sort((a,b)=>a-b);
                        const relSet = new Set(rel12);
                        const isMaj = [...targetMaj].every(x=> relSet.has(x));
                        const isMin = [...targetMin].every(x=> relSet.has(x));
                        if (isMaj || isMin) {
                            if (cand !== bassAbs) rootAbs = cand; // only override if different from bass
                            return true;
                        }
                    }
                    return false;
                })();
                const rels = steps.map(s => ((s - rootAbs) % edo + edo) % edo);
                const rootName = this.getRootNameForStep(rootAbs, edo);
                const symbol = this.getProperChordSymbol(rels);

                // Slash policy: only when bass is the seventh (flat or neutral 7), otherwise omit
                let slash = '';
                if (rootAbs !== bassAbs) {
                    const semiRoot = this.stepToSemitone(rootAbs, edo);
                    const semiBass = this.stepToSemitone(bassAbs, edo);
                    const d = ((semiBass - semiRoot) % 12 + 12) % 12;
                    const near = (x,y,tol=0.35)=> Math.abs(x-y) <= tol;
                    if (near(d, 10.0) || near(d, 10.5)) {
                        const bassName = this.getRootNameForStep(bassAbs, edo);
                        slash = `/${bassName}`;
                    }
                }
                return `${rootName}${symbol}${slash}`;
            }

            // Internal: choose the root within absSteps that yields the clearest 12-TET quality
            _chooseBestRootByQuality(absSteps, edo){
                const uniq = Array.from(new Set(absSteps.map(s => ((s % edo) + edo) % edo)));
                // Known quality targets in semitones (12-TET)
                const targets = [
                    {name:'maj', ints:[0,4,7], score:10},
                    {name:'min', ints:[0,3,7], score:10},
                    {name:'dim', ints:[0,3,6], score:8},
                    {name:'aug', ints:[0,4,8], score:8},
                    {name:'sus2',ints:[0,2,7], score:7},
                    {name:'sus4',ints:[0,5,7], score:7},
                ];
                let best = {root: uniq[0], score: -Infinity, rels12: null};
                // Precompute semitones for each abs step
                const semiMap = new Map();
                uniq.forEach(s => semiMap.set(s, this.stepToSemitone(s, edo)));
                uniq.forEach(root => {
                    const rootSemi = semiMap.get(root);
                    const rels12 = uniq.map(s => ((semiMap.get(s) - rootSemi + 12) % 12)).sort((a,b)=>a-b);
                    // Score against targets: exact subset/superset gets high score
                    let sMax = -1;
                    for (const t of targets) {
                        const tSet = new Set(t.ints);
                        const relSet = new Set(rels12);
                        const hitAll = t.ints.every(x => relSet.has(x));
                        if (hitAll) sMax = Math.max(sMax, t.score);
                    }
                    // Minor preference: if both maj/min ambiguous, keep the one whose lowest spelled triad is exact
                    if (sMax > best.score) best = {root, score: sMax, rels12};
                });
                // Fallback: pick by minimal semitone (previous behavior) if no quality matched
                if (best.score < 0) {
                    const r = uniq.slice().sort((a,b)=> this.stepToSemitone(a, edo) - this.stepToSemitone(b, edo))[0];
                    const rootSemi = this.stepToSemitone(r, edo);
                    const rels12 = uniq.map(s => ((this.stepToSemitone(s, edo) - rootSemi + 12) % 12)).sort((a,b)=>a-b);
                    return {root: r, score: 0, rels12};
                }
                return best;
            }

            // Fixed chromatic palette (0..11) → hex
            getChromaticColorForSemitone(semi) {
                const idx = ((semi % 12) + 12) % 12;
                const palette = ['#FFFFFF','#6A0DAD','#FFA500','#0000FF','#FF0000','#00FFFF','#C0C0C0','#00FF00','#FF00FF','#FFFF00','#00008B','#32CD32'];
                return palette[idx] || '#CCCCCC';
            }

            // Simple contrast helper for header text
            pickTextColor(bgHex, light = '#FFFFFF', dark = '#000000') {
                const h = (bgHex || '#000000').replace('#','');
                const r = parseInt(h.substring(0,2),16) || 0;
                const g = parseInt(h.substring(2,4),16) || 0;
                const b = parseInt(h.substring(4,6),16) || 0;
                const brightness = (r*299 + g*587 + b*114) / 1000;
                return brightness > 150 ? dark : light;
            }
            
            interpolateColors(color1, color2, factor) {
                // Convert hex colors to RGB, interpolate, and convert back
                const hex1 = color1.replace('#', '');
                const hex2 = color2.replace('#', '');
                
                const r1 = parseInt(hex1.substr(0, 2), 16);
                const g1 = parseInt(hex1.substr(2, 2), 16);
                const b1 = parseInt(hex1.substr(4, 2), 16);
                
                const r2 = parseInt(hex2.substr(0, 2), 16);
                const g2 = parseInt(hex2.substr(2, 2), 16);
                const b2 = parseInt(hex2.substr(4, 2), 16);
                
                const r = Math.round(r1 + (r2 - r1) * factor);
                const g = Math.round(g1 + (g2 - g1) * factor);
                const b = Math.round(b1 + (b2 - b1) * factor);
                
                return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
            }

            generateStringsForColumn(column, intervals, isCustomChord = false) {
                // If no tones yet, render an empty strings container and exit
                if (!intervals || !Array.isArray(intervals) || intervals.length === 0) {
                    const oldContainer = column.querySelector('.strings-column');
                    if (oldContainer) oldContainer.remove();
                    const stringsContainer = document.createElement('div');
                    stringsContainer.className = 'strings-column';
                    stringsContainer.style.cssText = `flex:1; overflow:hidden; padding:1px; height: calc(100% - 40px); display:flex; flex-direction:column; justify-content:center; align-items:center; color:#8fb3d3; font-size:12px; opacity:0.8;`;
                    const hint = document.createElement('div');
                    hint.textContent = 'Tap keys to add notes';
                    stringsContainer.appendChild(hint);
                    column.appendChild(stringsContainer);
                    return;
                }
                // Check if this column has locked settings
                const lockedChord = this.lockedChords?.get(column);
                // Resolve model index for per-chord fixed root, if any
                let model = null;
                try {
                    // Prefer stable ID mapping first
                    const id = column.dataset.chordId;
                    let idx = -1;
                    if (id) idx = (this.chordExtensions||[]).findIndex(c=> c && (String(c.id)===String(id)));
                    if (idx < 0 && column.dataset.originalPosition != null) {
                        const op = parseInt(column.dataset.originalPosition,10);
                        if (!isNaN(op) && op >= 0) idx = op;
                    }
                    if (idx >= 0) model = (this.chordExtensions||[])[idx];
                } catch(_) {}

                // If exact frequencies were captured for this column, render snapshot and exit
                // But skip snapshot if a local per-column transpose is active, so arrows take effect
                const hasLocalTranspose = ((+column.dataset.localTranspose || 0) !== 0);
                if (lockedChord && Array.isArray(lockedChord.exactFrequencies) && lockedChord.exactFrequencies.length > 0 && !this._transposing && !hasLocalTranspose) {
                    const oldContainer = column.querySelector('.strings-column');
                    if (oldContainer) oldContainer.remove();
                    this.generateStringsWithExactFrequencies(column, lockedChord);
                    return;
                }
                
                // Use locked settings if available, otherwise use current settings
                let currentRoot, currentTuning;
                if (lockedChord) {
                    const edo = lockedChord.lockedTuning || this.currentTuning || 12;
                    const globalDelta = (this.transposeDelta || 0) % edo;
                    const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                    // Locked chords preserve exact pitch by default; do not apply globalDelta here
                    currentRoot = ((lockedChord.lockedRoot ?? 0) + localDelta + edo) % edo;
                    currentTuning = lockedChord.lockedTuning;
                } else {
                    // Prefer per-chord fixed root if present; apply deltas so audio follows arrows and global transpose
                    if (model && typeof model.fixedRootStepAbs === 'number' && model.fixedRootTuning) {
                        currentTuning = model.fixedRootTuning;
                        const edo = currentTuning || this.getTuningStepsPerOctave();
                        const globalDelta = (this.transposeDelta || 0) % edo;
                        const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                        currentRoot = (((model.fixedRootStepAbs % edo) + globalDelta + localDelta) % edo + edo) % edo;
                    } else {
                        // Start from current global context; header label parsing below may override
                        currentRoot = this.currentRoot;
                        currentTuning = this.currentTuning;
                    }
                }
                
                
                
                const noteNames = this.getNoteNames();
                const tuningSize = currentTuning || this.getTuningStepsPerOctave();

                // For unlocked, non-fixed-root chords: derive pitch from base currentRoot plus global/local transpose deltas
                // This guarantees audio shifts by exact EDO steps on global transpose, independent of header text parsing.
                if (!lockedChord && !(model && typeof model.fixedRootStepAbs === 'number')) {
                    const edo = tuningSize;
                    const globalDelta = (this.transposeDelta || 0) % edo;
                    const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                    currentRoot = (((currentRoot ?? 0) + globalDelta + localDelta) % edo + edo) % edo;
                }

                // Ascending, octave-consistent voicing:
                // 1) Map intervals to EDO steps (or use directly for custom chords)
                // 2) Sort degrees within an octave by pitch (root -> third -> fifth -> ...)
                // 3) Repeat this ordered set across consecutive octaves to fill the column
                const degreeSteps = intervals.map(iv => isCustomChord ? ((iv % tuningSize)+tuningSize)%tuningSize : this.mapIntervalToEDO(iv, currentTuning));
                // Unique and sort by 12-TET semitone equivalence for consistent ordering
                const uniqueSteps = Array.from(new Set(degreeSteps));
                uniqueSteps.sort((a, b) => {
                    const sa = this.stepToSemitone(a, tuningSize);
                    const sb = this.stepToSemitone(b, tuningSize);
                    return sa - sb;
                });

                // Choose a mid register for clarity
                const baseOctave = 1; // C1 as lowest default anchor
                const stringFreqs = [];

                // Detect slash-chord bass to place as the very bottom voice (one octave below base)
                let slashBassStep = null;
                try {
                    const headerNameEl = column.querySelector('.extension-header .chord-name');
                    const headerName = headerNameEl ? headerNameEl.textContent.trim() : '';
                    const m = headerName.match(/^([A-G])([#b]?)[\^v]*.*\/(?:\s*)?([A-G])([#b]?)/);
                    if (m) {
                        const rootSemi = this.rootToSemitone(m[1], m[2]||'');
                        const bassSemi = this.rootToSemitone(m[3], m[4]||'');
                        const diffSemi = ((bassSemi - rootSemi) % 12 + 12) % 12;
                        slashBassStep = Math.round((diffSemi * tuningSize) / 12);
                    }
                } catch { /* ignore */ }

                // Prepare ordered steps (semitone ascending within octave)
                // We'll compute a special order for the FIRST group only so core tones
                // (root/3rd/5th/7th or their altered equivalents) appear before lifted extensions (≥9).
                const orderedSteps = uniqueSteps.slice();

                // If enabled, split extended chords (≥9) across two octaves in the first group
                // Strategy: keep root/3rd/5th/7th in baseOctave; push 9/11/13 (+alterations) up one octave
                let firstGroupOctaveOffsetMap = new Map();
                // Build mapping from EDO step -> original interval value (in semitones above root),
                // so we can classify core (<12) vs extensions (>=12). For custom chords, keep order as-is.
                let firstGroupOrderSteps = orderedSteps;
                if (this.splitExtendedChordsAcrossOctaves && !isCustomChord) {
                    const mapIvToStep = (iv) => this.mapIntervalToEDO(iv, currentTuning);
                    const stepInfoList = orderedSteps.map(edoStep => {
                        // find a representative original interval that maps to this step
                        let origin = intervals.find(iv => mapIvToStep(iv) === edoStep);
                        if (origin == null) {
                            // Fallback: estimate extended by semitone class (rare path)
                            const semi = this.stepToSemitone(edoStep, tuningSize);
                            origin = [1,2,3,5,6,8,9].includes(semi) ? 14 : 0; // treat as 9 or root-ish
                        }
                        // Treat #13 (22) specially: it collides with b7 in 12-TET; don't lift it.
                        const isExtended = (origin >= 12) && origin !== 22;
                        return { step: edoStep, semi: this.stepToSemitone(edoStep, tuningSize), origin, isExtended };
                    });

                    // Build first-group order: slash bass (if any) → core → extended
                    const coreList = stepInfoList
                        .filter(si => !si.isExtended && (slashBassStep == null || si.step !== slashBassStep))
                        .sort((a,b)=> a.semi - b.semi);
                    const extList = stepInfoList
                        .filter(si => si.isExtended && (slashBassStep == null || si.step !== slashBassStep))
                        .sort((a,b)=> a.semi - b.semi);
                    firstGroupOrderSteps = (slashBassStep != null ? [slashBassStep] : [])
                        .concat(coreList.map(si=>si.step))
                        .concat(extList.map(si=>si.step));

                    // Mark only the extended tones for the +1 octave lift in the first group
                    stepInfoList.forEach(si => { if (si.isExtended) firstGroupOctaveOffsetMap.set(si.step, 1); });
                }

                // Replicate the voicing across octaves C1..C8
                const replicateStride = this.splitExtendedChordsAcrossOctaves ? 2 : 1; // 2-oct stride for split voicing
                const totalReplicas = Math.floor(8 / replicateStride); // 8 octaves total span
                for (let r = 0; r < totalReplicas; r++) {
                    const replicateBaseOct = baseOctave + r * replicateStride;
                    let emittedRootCount = 0; // per-replica
                    const seq = firstGroupOrderSteps; // always apply core→extensions ordering per replica
                    for (let i = 0; i < seq.length; i++) {
                        const edoStep = seq[i];
                        // Normalize degree within an octave and track extra octaves for large extensions (e.g., 9/11/13)
                        const normStep = ((edoStep % tuningSize) + tuningSize) % tuningSize;
                        const extraFromDegree = Math.floor((edoStep - normStep) / tuningSize);

                        // Compute wrap relative to the column root
                        const total = currentRoot + normStep;
                        const wrapOctaves = Math.floor(total / tuningSize);
                        const step = ((total % tuningSize) + tuningSize) % tuningSize;

                        // For the first degree in this replica, if it's a slash bass, drop it one octave
                        const firstGroupBass = (slashBassStep != null && i === 0);
                        let octave = replicateBaseOct + extraFromDegree + wrapOctaves - (firstGroupBass ? 1 : 0);
                        // Apply split lift per replica for extensions (≥9)
                        if (this.splitExtendedChordsAcrossOctaves && firstGroupOctaveOffsetMap.has(edoStep)) {
                            octave += firstGroupOctaveOffsetMap.get(edoStep) || 0;
                        }
                        // In compact-one mode, keep tones within a single-octave span around replicate base
                        if (!this.splitExtendedChordsAcrossOctaves) {
                            const maxOct = replicateBaseOct + 1; // slight upward spill for upper degrees
                            const minOct = replicateBaseOct;      // keep base as lower bound
                            octave = Math.min(maxOct, Math.max(minOct, octave));
                        }
                        // Skip repeated roots in groups beyond the first (avoid C1,C3,C5,...) unless it's the slash bass
                        // Keep only one root per replica (unless slash-bass)
                        if (step === currentRoot && !firstGroupBass && emittedRootCount > 0) continue;
                        if (step === currentRoot && !firstGroupBass) emittedRootCount++;

                        const freq = this.getFrequency(step, octave, currentTuning);
                        // Map back to an interval tag for display/coloring; fallback to semitone-derived
                        const intervalTag = intervals.find(iv => (isCustomChord ? iv : this.mapIntervalToEDO(iv, currentTuning)) === edoStep) ?? intervals[i % intervals.length];
                        stringFreqs.push({ freq, step, octave, interval: intervalTag });
                    }
                }
                
                // Sort final strings by frequency ascending to guarantee low→high order
                stringFreqs.sort((a,b)=> a.freq - b.freq);

                // Calculate string sizing to fill full height of column
                const availableHeight = column.offsetHeight || 500; // Default height if not available
                const headerHeight = 40;
                const stringsHeight = availableHeight - headerHeight - 2; // Minimal padding
                const numStrings = stringFreqs.length;
                const stringHeight = Math.max(1, Math.floor(stringsHeight / numStrings) - 0.5); // Ensure strings are visible
                const stringMargin = 0.2; // Minimal margin
                
                // Create strings container that fills remaining space
                const stringsContainer = document.createElement('div');
                stringsContainer.className = 'strings-column';
                stringsContainer.style.cssText = `
                    flex: 1;
                    overflow: hidden;
                    padding: 1px;
                    height: calc(100% - ${headerHeight}px);
                    display: flex;
                    flex-direction: column;
                    justify-content: space-evenly;
                `;
                // Subtle root tint based on current root note color (very dark)
                try {
                    const semi = this.stepToSemitone(currentRoot, tuningSize);
                    const accent = this.getChromaticColorForSemitone(semi) || '#000000';
                    const tint = (hex => {
                        const m = /^#?([0-9a-f]{6})$/i.exec(hex || '');
                        if (!m) return 'rgba(0,0,0,0)';
                        const n = parseInt(m[1], 16);
                        let r = (n >> 16) & 0xff, g = (n >> 8) & 0xff, b = n & 0xff;
                        // heavy darken: keep only ~6-12 of 255
                        r = Math.max(6, Math.floor(r * 0.08));
                        g = Math.max(6, Math.floor(g * 0.08));
                        b = Math.max(6, Math.floor(b * 0.08));
                        return `linear-gradient(to bottom, rgba(${r},${g},${b},0.12), rgba(${r},${g},${b},0.08))`;
                    })(accent);
                    stringsContainer.style.setProperty('--root-tint-gradient', tint);
                    const headerEl = column.querySelector('.extension-header');
                    if (headerEl) headerEl.style.setProperty('--root-tint-gradient', tint);
                } catch (_) {}
                
                stringFreqs.forEach((stringData, stringIndex) => {
                    const row = document.createElement('div');
                    row.className = 'string';
                    row.dataset.index = stringIndex;
                    row.dataset.column = column.dataset.chordType || 'unknown';
                    row.dataset.frequency = stringData.freq;
                    row.dataset.noteIndex = stringData.step;
                    // Persist the interval for later recalculation (e.g., during auto-lock recompute)
                    row.dataset.interval = stringData.interval;
                    // Also persist octave and relative EDO step (interval mapped in current tuning)
                    // EDO step is the interval in current tuning independent of the current root
                    try {
                        const tuningSize = currentTuning || this.getTuningStepsPerOctave();
                        const rootForCalc = currentRoot ?? this.currentRoot ?? 0;
                        const relStep = ((stringData.step - rootForCalc) % tuningSize + tuningSize) % tuningSize;
                        row.dataset.edoStep = String(relStep);
                    } catch (_) {
                        // Fallback: omit if cannot compute
                    }
                    row.dataset.octave = String(stringData.octave);

                    // Colors
                    const intervalColor = this.getIntervalColor(stringData.interval);
                    const baseColor = intervalColor.color;
                    const glowColor = (baseColor && baseColor.toLowerCase() === '#000000') ? '#555555' : baseColor;
                    row.dataset.glowColor = glowColor;

                    // Visible core
                    const core = document.createElement('div');
                    core.className = 'string-core';
                    core.style.background = baseColor;
                    core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;

                    row.title = `${intervalColor.name} - ${noteNames[stringData.step] || `Note ${stringData.step}`} - Oct${stringData.octave} - ${stringData.freq.toFixed(1)}Hz`;

                    // Hover effects on core
                    row.addEventListener('mouseenter', () => {
                        core.style.transform = 'scaleY(1.25)';
                        core.style.boxShadow = `0 0 6px ${glowColor}, 0 0 14px ${glowColor}CC, 0 0 28px ${glowColor}88`;
                    });
                    row.addEventListener('mouseleave', () => {
                        core.style.transform = 'scaleY(1)';
                        core.style.boxShadow = `0 0 4px ${glowColor}, 0 0 10px ${glowColor}AA, 0 0 18px ${glowColor}66`;
                    });

                    // Attach core
                    row.appendChild(core);
                    stringsContainer.appendChild(row);

                    // Precompute vibration period and store on core
                    const period = this.computeVibrationPeriod(stringData.freq, stringData.step);
                    core.style.setProperty('--vib-period', period + 'ms');
                });
                // Post-fit adjustment to guarantee no hidden octaves
                this.ensureStringsFullyVisible(stringsContainer);
                
                column.appendChild(stringsContainer);
            }

            // Shrink string heights uniformly if overflow would hide octaves
            ensureStringsFullyVisible(parent){
                if(!parent) return;
                const strings = Array.from(parent.querySelectorAll('.string'));
                if(!strings.length) return;
                // small timeout ensures layout values are settled if heights were zero initially
                const adjust = ()=>{
                    const visibleH = parent.clientHeight;
                    if(visibleH<=0) return;
                    const total = strings.reduce((sum,s)=> sum + s.offsetHeight, 0);
                    if(total <= visibleH) return; // fits already
                    const target = Math.max(1, Math.floor((visibleH - (strings.length*0.4)) / strings.length));
                    strings.forEach(s=>{ s.style.height = target + 'px'; });
                };
                // Run twice (immediate + next frame) to catch late layout
                adjust();
                requestAnimationFrame(adjust);
            }
            
            adjustColorBrightness(hexColor, percent) {
                // Utility function to adjust color brightness
                const num = parseInt(hexColor.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
            
            hexToRgb(hex) {
                // Convert hex color to RGB values
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }
            
            mapIntervalToEDO(interval, tuning = null) {
                // Map 12-TET intervals to the nearest equivalent in the current EDO
                // This preserves diatonic relationships properly
                const tuningSize = tuning || this.getTuningStepsPerOctave();
                const currentTuning = tuning || this.currentTuning;
                
                if (currentTuning === 12) {
                    // For 12-TET, return the interval as-is
                    return Math.round(interval);
                }
                
                // For other EDOs, map to the nearest step that preserves musical relationships
                const exactStep = (interval * tuningSize) / 12;
                return Math.round(exactStep);
            }
            
            getBaseTriadForQuality(quality) {
                // Return standard diatonic intervals in semitones
                // These will be properly mapped to EDO steps by mapIntervalToEDO
                let intervals = [0]; // Root
                
                switch (quality) {
                    case 'major':
                        intervals.push(4); // Major third (4 semitones)
                        intervals.push(7); // Perfect fifth (7 semitones)
                        break;
                    case 'minor':
                        intervals.push(3); // Minor third (3 semitones)
                        intervals.push(7); // Perfect fifth (7 semitones)
                        break;
                    case 'neutral':
                        intervals.push(3.5); // Neutral third (3.5 semitones)
                        intervals.push(7); // Perfect fifth (7 semitones)
                        break;
                    case 'diminished':
                        intervals.push(3); // Minor third
                        intervals.push(6); // Diminished fifth
                        break;
                    case 'augmented':
                        intervals.push(4); // Major third
                        intervals.push(8); // Augmented fifth
                        break;
                    case 'sus2':
                        intervals.push(2); // Major second
                        intervals.push(7); // Perfect fifth
                        break;
                    case 'sus4':
                        intervals.push(5); // Perfect fourth
                        intervals.push(7); // Perfect fifth
                        break;
                    default:
                        intervals.push(4); // Default to major third
                        intervals.push(7); // Perfect fifth
                        break;
                }
                
                return intervals;
            }
            
            convertExtensionsToIntervals(extensions) {
                // Return extensions as semitone intervals that will be mapped by mapIntervalToEDO
                const intervals = [];
                
                extensions.forEach(ext => {
                    switch (ext) {
                        case '6':
                            intervals.push(9); // Major 6th (9 semitones)
                            break;
                        case '7':
                            intervals.push(10); // Minor 7th (10 semitones)
                            break;
                        case 'maj7':
                            intervals.push(11); // Major 7th (11 semitones)
                            break;
                        case '9':
                            intervals.push(10); // 7th (required for 9th chords)
                            intervals.push(14); // 9th (2 semitones up an octave = 14)
                            break;
                        case '11':
                            intervals.push(10); // 7th (required for 11th chords)
                            intervals.push(14); // 9th (often included in 11th chords)
                            intervals.push(17); // 11th (5 semitones up an octave = 17)
                            break;
                        case 's11':
                        case '#11':
                            intervals.push(10); // 7th
                            intervals.push(14); // 9th
                            intervals.push(18); // #11th (6 semitones up an octave = 18)
                            break;
                        case '13':
                            intervals.push(10); // 7th (required for 13th chords)
                            intervals.push(14); // 9th (usually included)
                            intervals.push(17); // 11th (usually included)
                            intervals.push(21); // 13th (9 semitones up an octave = 21)
                            break;
                        case 's13':
                        case '#13':
                            intervals.push(10); // 7th
                            intervals.push(14); // 9th
                            intervals.push(17); // 11th
                            intervals.push(22); // #13th (10 semitones up an octave = 22)
                            break;
                        case 'sus2':
                            intervals.push(2); // Major 2nd
                            break;
                        case 'sus4':
                            intervals.push(5); // Perfect 4th
                            break;
                        case 'add9':
                            intervals.push(14); // 9th (2 semitones up an octave, no 7th)
                            break;
                        case 'neutral7':
                            intervals.push(10); // Still minor 7th, but will be applied to neutral triads
                            break;
                        case 'neutral11':
                            intervals.push(10); // 7th
                            intervals.push(14); // 9th
                            intervals.push(17); // 11th
                            break;
                    }
                });
                
                return intervals;
            }

            // Attach long-press drag and dwell-to-swap on a column (initiation on header or free space only)
            attachColumnDragHandlers(column) {
                try {
                    const container = document.getElementById('extensionColumns');
                    if (!container || !column) return;
                    const header = column.querySelector('.extension-header');
                    if (!header) return;

                    const LONG_PRESS_MS = 200;
                    const DWELL_MS = 200;
                    const JITTER_PX = 6;
                    const DELETE_THRESHOLD_PX = 5; // delete only if dragged to top of the viewport

                    let pressTimer = null;
                    let isDragging = false;
                    let startX = 0, startY = 0;
                    let grabOffsetX = 0, grabOffsetY = 0;
                    let placeholder = null;
                    let dwellTimer = null;
                    let deleteIntent = false;
                    let originalAbsIndex = null;
                    let lastSwapTarget = null;
                    let lastSwapTargetAbsIndex = null;

                    const getPointer = (e) => (e.touches && e.touches[0]) || e;
                    const canStartFrom = (target) => {
                        // allow from header or empty space inside column; block buttons
                        if (!target) return false;
                        if (target.closest('.chord-action-button') || target.closest('.lock-button')) return false;
                        return target.closest('.extension-header') || target.closest('.extension-column');
                    };

                    const swapNodes = (a, b) => {
                        if (!a || !b || a === b) return;
                        const aMarker = document.createElement('div');
                        const bMarker = document.createElement('div');
                        const parent = a.parentNode;
                        if (!parent || !b.parentNode) return;
                        parent.insertBefore(aMarker, a);
                        parent.insertBefore(bMarker, b);
                        parent.replaceChild(b, aMarker);
                        parent.replaceChild(a, bMarker);
                    };

                    const onPressStart = (e) => {
                        if (!canStartFrom(e.target)) return;
                        const p = getPointer(e);
                        startX = p.clientX; startY = p.clientY;
                        pressTimer = setTimeout(() => beginDrag(p), LONG_PRESS_MS);
                    };

                    const cancelPress = () => { if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; } };

                    const maybeCancelOnMove = (e) => {
                        if (!pressTimer) return;
                        const p = getPointer(e);
                        if (Math.abs(p.clientX - startX) > JITTER_PX || Math.abs(p.clientY - startY) > JITTER_PX) cancelPress();
                    };

                    const beginDrag = (p) => {
                        isDragging = true;
                        column.classList.add('dragging');
                        const rect = column.getBoundingClientRect();
                        grabOffsetX = p.clientX - rect.left;
                        grabOffsetY = p.clientY - rect.top;
                        column.style.width = rect.width + 'px';
                        column.style.height = rect.height + 'px';
                        column.style.position = 'fixed';
                        column.style.zIndex = 9999;
                        column.style.pointerEvents = 'none';
                        column.style.transform = 'scale(1.03)';
                        column.style.boxShadow = '0 12px 22px rgba(0,0,0,0.35)';

                        // placeholder
                        placeholder = document.createElement('div');
                        placeholder.className = 'extension-column placeholder';
                        placeholder.style.width = rect.width + 'px';
                        placeholder.style.height = rect.height + 'px';
                        placeholder.style.flex = '1';
                        placeholder.style.border = '2px dashed rgba(255,255,255,0.3)';
                        column.parentNode.insertBefore(placeholder, column);

                        // Capture the absolute index for the dragged column (for data swap)
                        try {
                            if (this.getIndexFromColumn) {
                                originalAbsIndex = this.getIndexFromColumn(column);
                            } else if (column.dataset && column.dataset.originalPosition) {
                                originalAbsIndex = parseInt(column.dataset.originalPosition, 10);
                            } else {
                                originalAbsIndex = Array.from(container.querySelectorAll('.extension-column')).indexOf(column);
                            }
                        } catch (_) { originalAbsIndex = null; }
                        lastSwapTarget = null;
                        lastSwapTargetAbsIndex = null;

                        moveDrag(p);
                        window.addEventListener('mousemove', onMove, { passive: false });
                        window.addEventListener('touchmove', onMove, { passive: false });
                        window.addEventListener('mouseup', onEnd);
                        window.addEventListener('touchend', onEnd);
                    };

                    const moveDrag = (p) => {
                        const x = p.clientX - grabOffsetX;
                        const y = p.clientY - grabOffsetY;
                        column.style.left = x + 'px';
                        column.style.top = y + 'px';

                        // delete intent near top
                        // Only flag delete when pointer is near the very top of the viewport
                        const shouldDelete = (p.clientY <= DELETE_THRESHOLD_PX);
                        if (shouldDelete !== deleteIntent) {
                            deleteIntent = shouldDelete;
                            column.classList.toggle('delete-intent', deleteIntent);
                        }

                        // dwell swap logic: swap ONLY the dragged column's placeholder with the hovered column
                        const siblings = Array.from(container.querySelectorAll('.extension-column'))
                            .filter(el => el !== column && !el.classList.contains('placeholder'));
                        let over = siblings.find(el => {
                            const r = el.getBoundingClientRect();
                            return p.clientX > r.left && p.clientX < r.right && p.clientY > r.top && p.clientY < r.bottom;
                        });

                        // Fallback using elementFromPoint for reliability across browsers
                        if (!over) {
                            const hit = document.elementFromPoint(p.clientX, p.clientY);
                            const hitCol = hit && hit.closest ? hit.closest('.extension-column') : null;
                            if (hitCol && hitCol !== column && !hitCol.classList.contains('placeholder')) {
                                over = hitCol;
                            }
                        }

                        if (over) {
                            if (!dwellTimer) {
                dwellTimer = setTimeout(() => {
                                    if (!placeholder || !over.parentNode) return;
                                    if (over !== lastSwapTarget) {
                                        // Swap placeholder and the hovered column to reflect a simple two-box swap
                                        swapNodes(placeholder, over);
                                        lastSwapTarget = over;
                                        try {
                                            lastSwapTargetAbsIndex = this.getIndexFromColumn ? this.getIndexFromColumn(over) : (over.dataset && over.dataset.originalPosition ? parseInt(over.dataset.originalPosition, 10) : null);
                                        } catch(_) { lastSwapTargetAbsIndex = null; }
                    // Allow subsequent swaps by resetting the dwell timer state
                    clearTimeout(dwellTimer);
                    dwellTimer = null;
                                    }
                                }, DWELL_MS);
                            }
                        } else if (dwellTimer) {
                            clearTimeout(dwellTimer); dwellTimer = null;
                        }
                    };

                    const onMove = (e) => { if (!isDragging && pressTimer) { maybeCancelOnMove(e); return; } if (!isDragging) return; const p = getPointer(e); moveDrag(p); e.preventDefault(); };

                    const onEnd = () => {
                        cancelPress();
                        window.removeEventListener('mousemove', onMove);
                        window.removeEventListener('touchmove', onMove);
                        window.removeEventListener('mouseup', onEnd);
                        window.removeEventListener('touchend', onEnd);
                        if (dwellTimer) { clearTimeout(dwellTimer); dwellTimer = null; }

                        column.classList.remove('dragging');
                        column.style.position = '';
                        column.style.left = '';
                        column.style.top = '';
                        column.style.zIndex = '';
                        column.style.pointerEvents = '';
                        column.style.transform = '';
                        column.style.boxShadow = '';
                        column.style.width = '';
                        column.style.height = '';

                        if (deleteIntent) {
                            deleteIntent = false;
                            // remove column and update data (do not recreate nodes for others)
                            const idx = this.getIndexFromColumn ? this.getIndexFromColumn(column) : Array.from(container.children).indexOf(column);
                            if (idx > -1) {
                                this.chordExtensions.splice(idx, 1);
                                column.remove();
                                this.normalizeChordPositions?.();
                                this.saveChordConfiguration?.();
                            }
                            if (placeholder) placeholder.remove();
                            return;
                        }

                        if (placeholder && placeholder.parentNode) {
                            placeholder.parentNode.insertBefore(column, placeholder);
                            placeholder.remove();
                        }

                        // Rebuild data order from DOM to reflect the final visual order (works for single swap or cascades)
                        const orderedEls = Array.from(container.querySelectorAll('.extension-column'));
                        if (Array.isArray(this.chordExtensions) && orderedEls.length) {
                            const newArray = [];
                            for (let i = 0; i < orderedEls.length; i++) {
                                const el = orderedEls[i];
                                const oldIdx = el.dataset && el.dataset.originalPosition ? parseInt(el.dataset.originalPosition, 10) : i;
                                const model = this.chordExtensions[oldIdx] ?? this.chordExtensions[i];
                                if (model) {
                                    model.position = i;
                                    newArray.push(model);
                                    // Update dataset to new index for consistent future operations
                                    try { el.dataset.originalPosition = String(i); } catch(_) {}
                                }
                            }
                            if (newArray.length === this.chordExtensions.length) {
                                this.chordExtensions = newArray;
                                this.normalizeChordPositions?.();
                                this.saveChordConfiguration?.();
                                // Ensure the visible header names/lock states match the new underlying model order
                                if (typeof this.syncColumnHeaderToModel === 'function') {
                                    for (let i = 0; i < orderedEls.length; i++) {
                                        try { this.syncColumnHeaderToModel(orderedEls[i], this.chordExtensions[i]); } catch(_) {}
                                    }
                                }
                            }
                        }
                    };

                    // Initiation only from header or free space
                    header.addEventListener('mousedown', (e) => { if (e.button !== 0) return; onPressStart(e); });
                    header.addEventListener('touchstart', (e) => { onPressStart(e); }, { passive: true });

                } catch (err) { console.error('attachColumnDragHandlers error:', err); }
            }
            
            getTuningStepsPerOctave() {
                // Handle custom tuning objects
                if (typeof this.currentTuning === 'object' && this.currentTuning.type === 'custom') {
                    // For non-octave tunings, we need to calculate how many steps make an octave
                    const [num, den] = this.currentTuning.ratio;
                    const ratioInOctaves = Math.log2(num / den);
                    return this.currentTuning.divisions / ratioInOctaves;
                }
                
                if (typeof this.currentTuning === 'string') {
                    switch(this.currentTuning) {
                        case 'carlos-alpha': return 78.0;
                        case 'carlos-beta': return 18.8;
                        case 'carlos-gamma': return 34.1895;
                        case 'carlos-delta': return 10.024;
                        case 'lucy': return 6.283; // approximately 2p
                        case 'pythagorean':
                        case 'just':
                        case 'meantone':
                            return 12;
                        case 'arabic': return 24;
                        case 'gamelan-pelog': return 7;
                        case 'gamelan-slendro': return 5;
                        default: return 12;
                    }
                }
                return this.currentTuning;
            }

            // Synchronize a column's header text and lock UI to the provided chord model
            syncColumnHeaderToModel(column, chordModel) {
                if (!column || !chordModel) return;
                const chordNameEl = column.querySelector('.chord-name');
                const lockBtn = column.querySelector('.lock-button');
                if (!chordNameEl) return;

                if (chordModel.isLocked && chordModel.lockedData) {
                    const locked = chordModel.lockedData;
                    const rootName = (this.getNoteNames()[locked.lockedRoot] || locked.lockedRoot);
                    if (locked.chordName && /^[A-G][#b]?/.test(locked.chordName)) {
                        chordNameEl.textContent = locked.chordName;
                    } else if (locked.chordName) {
                        chordNameEl.textContent = `${rootName}${locked.chordName}`;
                    } else {
                        chordNameEl.textContent = `${rootName}${chordModel.name || ''}`;
                    }
                    chordNameEl.style.color = '#4CAF50';
                    chordNameEl.style.fontWeight = 'bold';
                    chordNameEl.dataset.isLocked = 'true';
                    chordNameEl.dataset.lockedName = chordNameEl.textContent;
                    if (lockBtn) {
                        lockBtn.innerHTML = '🔒';
                        lockBtn.classList.add('locked');
                        lockBtn.title = `LOCKED to ${rootName} root with all settings`;
                    }
                } else {
                    chordNameEl.textContent = chordModel.name || '';
                    chordNameEl.style.color = '';
                    chordNameEl.style.fontWeight = '';
                    chordNameEl.dataset.isLocked = '';
                    chordNameEl.dataset.lockedName = '';
                    if (lockBtn) {
                        lockBtn.innerHTML = '🔓';
                        lockBtn.classList.remove('locked');
                        lockBtn.title = 'Lock complete sonic snapshot';
                    }
                }
            }

            addSimpleClickHandlers() {
                console.log('?? Adding simple click handlers to all extension headers');
                
                // Handle extension column headers - PRIORITY handlers for chord name context menu
                const headers = document.querySelectorAll('.extension-header');
                console.log('?? Found', headers.length, 'extension headers');
                
                headers.forEach(header => {
                    // Remove any existing simple click handler to avoid duplicates
                    if (header.simpleClickAdded) return;
                    header.simpleClickAdded = true;
                    
                    console.log('?? Adding chord name context menu handler to header:', header.textContent);
                    
                    // Add immediate click handler with high priority
                    header.addEventListener('click', (e) => {
                        // Don't interfere with header action buttons
                        if (
                            e.target.classList.contains('lock-button') ||
                            
                            e.target.classList.contains('chord-action-button') ||
                            e.target.tagName === 'BUTTON'
                        ) {
                            console.log('?? Header action button clicked, allowing event to proceed');
                            return; // Let the buttons handle their own clicks
                        }
                        
                        console.log('?? IMMEDIATE CLICK on header:', header.textContent);
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        
                        const column = header.closest('.extension-column');
                        if (!column) return;
                        
                        const chordData = this.getChordDataFromColumn(column, header);
                        if (chordData) {
                            // Trigger a quick full-column strum instead of a context menu
                            const rect = column.getBoundingClientRect();
                            const startY = rect.top + Math.max(4, rect.height * 0.08);
                            const endY = rect.bottom - Math.max(4, rect.height * 0.08);
                            this.playChordStrum(column, chordData, startY, endY);
                        }
                    }, true); // Use capture phase for highest priority
                    
                    // Also add a pointerdown event for better mobile support
                    header.addEventListener('pointerdown', (e) => {
                        // Let header action buttons receive pointerdown
                        if (
                            e.target.classList.contains('lock-button') ||
                            e.target.classList.contains('piano-lock-button') ||
                            e.target.classList.contains('chord-action-button') ||
                            e.target.tagName === 'BUTTON'
                        ) {
                            return;
                        }
                        console.log('?? POINTERDOWN on header:', header.textContent);
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const column = header.closest('.extension-column');
                        if (!column) return;
                        
                        const chordData = this.getChordDataFromColumn(column, header);
                        if (chordData) {
                            console.log('?? Showing CHORD NAME context menu for pointerdown:', chordData);
                            // Context menu removed - no action taken
                        }
                    }, true); // Use capture phase for highest priority
                    
                    header.addEventListener('mousedown', (e) => {
                        // Let header action buttons receive mousedown
                        if (
                            e.target.classList.contains('lock-button') ||
                            e.target.classList.contains('piano-lock-button') ||
                            e.target.classList.contains('chord-action-button') ||
                            e.target.tagName === 'BUTTON'
                        ) {
                            return;
                        }
                        console.log('?? MOUSEDOWN on header:', header.textContent);
                        // Only handle left mouse button
                        if (e.button !== 0) return;
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const column = header.closest('.extension-column');
                        if (!column) return;
                        
                        // Do not also strum here to avoid double-trigger with click; click handler handles it.
                    }, true); // Use capture phase for highest priority
                    
                    // Add right-click context menu for easier access
                    header.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        console.log('Right-click on extension header, showing chord name context menu');
                        
                        const column = header.closest('.extension-column');
                        if (column) {
                            const chordData = this.getChordDataFromColumn(column, header);
                            if (chordData) {
                                // Context menu removed - no action taken
                            }
                        }
                    });
                    
                    // Also add touchstart for mobile
                    header.addEventListener('touchstart', (e) => {
                        // Don't interfere with button clicks - let them bubble up
                        if (e.target.classList.contains('lock-button') || 
                            e.target.classList.contains('piano-lock-button') ||
                            e.target.classList.contains('chord-action-button') ||
                            e.target.tagName === 'BUTTON') {
                            console.log('Touch on button, allowing default behavior');
                            return;
                        }
                        console.log('TOUCHSTART on header:', header.textContent);
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const column = header.closest('.extension-column');
                        if (!column) return;
                        
                        const chordData = this.getChordDataFromColumn(column, header);
                        if (chordData) {
                            // Trigger strum immediately on touch
                            const rect = column.getBoundingClientRect();
                            const startY = rect.top + Math.max(4, rect.height * 0.08);
                            const endY = rect.bottom - Math.max(4, rect.height * 0.08);
                            this.playChordStrum(column, chordData, startY, endY);
                        }
                    }, { passive: false });
                });
                
                // Handle palette chord headers
                document.querySelectorAll('.palette-chord .extension-header').forEach(header => {
                    if (header.simplePaletteClickAdded) return;
                    header.simplePaletteClickAdded = true;
                    
                    header.addEventListener('mousedown', (e) => {
                        if (e.button !== 0) return;
                        
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const paletteChord = header.closest('.palette-chord');
                        if (paletteChord) {
                            const chordIndex = parseInt(paletteChord.dataset.chordIndex);
                            const chordData = this.paletteChords[chordIndex];
                            if (chordData) {
                                console.log('Showing palette context menu for mousedown:', chordData);
                                this.showPaletteContextMenu(e.clientX, e.clientY, chordData);
                            }
                        }
                    });
                    
                    header.addEventListener('touchstart', (e) => {
                        // Don't interfere with button clicks - let them bubble up
                        if (e.target.classList.contains('lock-button') || 
                            e.target.classList.contains('piano-lock-button') ||
                            e.target.tagName === 'BUTTON') {
                            console.log('Touch on button, allowing default behavior');
                            return;
                        }
                        
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const paletteChord = header.closest('.palette-chord');
                        if (paletteChord) {
                            const chordIndex = parseInt(paletteChord.dataset.chordIndex);
                            const chordData = this.paletteChords[chordIndex];
                            if (chordData) {
                                const touch = e.touches[0];
                                this.showPaletteContextMenu(touch.clientX, touch.clientY, chordData);
                            }
                        }
                    }, { passive: false });
                });
            }

            stopAllActiveNotes() {
                // Use the unified stop logic that matches osc1/osc2 structure
                try {
                    this.stopAllStrings();
                } catch (_) {
                    // Fallback: manual release for any remaining entries
                    const now = this.audioContext ? this.audioContext.currentTime : 0;
                    for (const [id, info] of this.activeOscillators) {
                        try {
                            if (info.osc1Envelope) {
                                info.osc1Envelope.gain.cancelScheduledValues(now);
                                info.osc1Envelope.gain.setValueAtTime(info.osc1Envelope.gain.value, now);
                                info.osc1Envelope.gain.linearRampToValueAtTime(0, now + (this.envelope?.release || 0.2));
                            }
                            if (info.osc2Envelope) {
                                info.osc2Envelope.gain.cancelScheduledValues(now);
                                info.osc2Envelope.gain.setValueAtTime(info.osc2Envelope.gain.value, now);
                                info.osc2Envelope.gain.linearRampToValueAtTime(0, now + (this.osc2Envelope?.release || 0.2));
                            }
                            const maxRel = Math.max(this.envelope?.release || 0.2, this.osc2Envelope?.release || 0.2);
                            if (info.osc1) info.osc1.stop(now + maxRel);
                            if (info.osc2) info.osc2.stop(now + maxRel);
                        } catch {}
                        this.activeOscillators.delete(id);
                    }
                }
            }

            handleStringTrigger(event, touchId = null) {
                // Ensure AudioContext is running on every swipe sample for reliability
                try {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume().catch(()=>{});
                    }
                } catch(_) {}
                const elements = document.elementsFromPoint(event.clientX, event.clientY);
                const stringElement = elements.find(el => el.classList.contains('string'));
                
                if (stringElement) {
                    // If a blank chord is pending and user is strumming another column, inherit immediately
                    try {
                        if (this.pendingBlankChordId) {
                            const srcCol = stringElement.closest && stringElement.closest('.extension-column');
                            const pendingCol = document.querySelector(`.extension-column[data-chord-id='${this.pendingBlankChordId}']`);
                            const isSame = pendingCol && srcCol && pendingCol === srcCol;
                            if (srcCol && pendingCol && !isSame) {
                                const headerName = srcCol.querySelector('.extension-header .chord-name')?.textContent?.trim() || '';
                                if (headerName !== '|') {
                                    const relSteps = this.getChordStepsForColumn(srcCol);
                                    const edo = this.currentTuning || 12;
                                    const absSteps = relSteps.map(s=> ((s % edo)+edo)%edo);
                                    const best = this._chooseBestRootByQuality(absSteps, edo);
                                    const rootAbs = best.root;
                                    const normalized = absSteps.map(s=> ((s - rootAbs)%edo+edo)%edo).sort((a,b)=> this.stepToSemitone(a,edo)-this.stepToSemitone(b,edo));
                                    const idx = (this.chordExtensions||[]).findIndex(c=> String(c.id)===String(this.pendingBlankChordId));
                                    if (idx >= 0) {
                                        const model = this.chordExtensions[idx];
                                        model.intervals = normalized;
                                        model.fixedRootStepAbs = rootAbs;
                                        model.fixedRootTuning = edo;
                                        const newName = this.computeFullChordNameFromAbsoluteSteps([rootAbs, ...normalized.map(x=> (rootAbs + x)%edo)], edo);
                                        model.name = newName;
                                        try {
                                            const nameEl = pendingCol.querySelector('.extension-header .chord-name');
                                            if (nameEl) { nameEl.textContent = newName; nameEl.dataset.lockedName = newName; }
                                            const old = pendingCol.querySelector('.strings-column');
                                            if (old) old.remove();
                                            this.generateStringsForColumn(pendingCol, model.intervals, true);
                                            this.highlightKeyboardForColumn(pendingCol);
                                            this.currentActiveColumnEl = pendingCol;
                                        } catch(_) {}
                                        this.pendingBlankChordId = null;
                                        try { this.saveChordConfiguration(); } catch(_) {}
                                    }
                                }
                            }
                        }
                    } catch(_) {}
                    const stringIndex = stringElement.dataset.index;
                    const column = parseInt(stringElement.dataset.column) || stringElement.dataset.column;
                    const trackingSet = touchId !== null ? 
                        this.activeTouches.get(touchId)?.triggeredStrings : 
                        this.triggeredStrings;
                    
                    // Throttle triggering per string to avoid audio spam but maintain responsiveness
                    const now = performance.now();
                    const lastTrigger = stringElement.lastTriggerTime || 0;
                    const minInterval = 125; // 125ms minimum between triggers per string (≤8/s)
                    
                    if (now - lastTrigger > minInterval) {
                        this.currentPlayingColumn = column;
                        // Try to cache actual column element and light keyboard
                        try {
                            let columnEl = stringElement.closest('.extension-column');
                            if (!columnEl && typeof column === 'string') {
                                columnEl = document.querySelector(`.extension-column[data-chord-type='${column}']`);
                            }
                            if (columnEl) {
                                this.currentActiveColumnEl = columnEl;
                                this.highlightKeyboardForColumn(columnEl);
                            }
                        } catch(_) {}
                        const frequency = parseFloat(stringElement.dataset.frequency);
                        this.playFrequency(frequency, stringElement);
                        this.updateCurrentChord(column);
                        
                        stringElement.lastTriggerTime = now;
                        
                        // Add to tracking for cleanup
                        if (trackingSet) {
                            trackingSet.add(stringIndex);
                            // Quick removal to allow retriggering
                            setTimeout(() => {
                                trackingSet.delete(stringIndex);
                            }, 20);
                        }
                    }
                }
            }

            handlePaletteStringTrigger(event) {
                console.log('handlePaletteStringTrigger called at', event.clientX, event.clientY);
                const elements = document.elementsFromPoint(event.clientX, event.clientY);
                const stringElement = elements.find(el => el.classList.contains('string') && el.dataset.paletteIndex !== undefined);
                console.log('Found string element:', stringElement, 'frequency:', stringElement?.dataset?.frequency);
                
                if (stringElement) {
                    const stringIndex = stringElement.dataset.index;
                    const paletteIndex = stringElement.dataset.paletteIndex;
                    const rawFrequency = stringElement.dataset.frequency;
                    console.log('Raw frequency data:', rawFrequency, 'type:', typeof rawFrequency);
                    
                    // Throttle triggering per string to avoid audio spam but maintain responsiveness
                    const now = performance.now();
                    const lastTrigger = stringElement.lastTriggerTime || 0;
                    const minInterval = 125; // 125ms minimum between triggers per string (≤8/s)
                    
                    if (now - lastTrigger > minInterval && !this.paletteTriggeredStrings.has(stringIndex)) {
                        const frequency = parseFloat(rawFrequency);
                        console.log('Parsed frequency:', frequency, 'isValid:', !isNaN(frequency) && isFinite(frequency));
                        
                        if (!isNaN(frequency) && isFinite(frequency)) {
                            this.playFrequency(frequency, stringElement);
                            
                            stringElement.lastTriggerTime = now;
                            this.paletteTriggeredStrings.add(stringIndex);
                            
                            // Quick removal to allow retriggering
                            setTimeout(() => {
                                this.paletteTriggeredStrings.delete(stringIndex);
                            }, 20);
                            
                            console.log('Palette string triggered:', frequency, 'Hz from palette chord', paletteIndex);
                        } else {
                            console.error('Invalid frequency for palette string:', rawFrequency, 'parsed as:', frequency);
                        }
                    }
                }
            }

            updateCurrentChord(column) {
                // Resolve the column element from dataset.column (chordType) or fallback to closest
                let columnElement = document.querySelector(`[data-chord-type="${column}"]`) || document.querySelector(`[data-column="${column}"]`);
                if (!columnElement) {
                    try { columnElement = document.querySelector(`.extension-column[data-chord-type='${column}']`); } catch(_){}
                }
                // If user was creating a new chord, auto-save it before switching context
                if (this.chordCreationMode && this.selectedIntervals && this.selectedIntervals.length > 1) {
                    try {
                        const edo = this.currentTuning || 12;
                        const absSteps = this.selectedIntervals.map(iv => ((iv % edo) + edo) % edo);
                        const pendingName = this.computeFullChordNameFromAbsoluteSteps(absSteps, edo);
                        this.finalizePreviewChord(pendingName);
                        this.chordCreationMode = false;
                    } catch(e) { /* ignore */ }
                }
                // Apply piano-locked preset if one exists for this chord's structure
                if (columnElement && this.pianoLockedChords && this.pianoLockedChords.size > 0) {
                    try {
                        const headerElement = columnElement.querySelector('.extension-header');
                        const chordData = this.getChordDataFromColumn(columnElement, headerElement);
                        if (chordData) {
                            const lock = this.findPianoLockData(chordData);
                            if (lock) {
                                this.applyPianoLockedSettings(lock);
                                // Preload/warm this chord for instant play
                                try { this.preloadPianoLockedChord(columnElement); } catch(_) {}
                            }
                        }
                    } catch(_) {}
                }
                // Mark active column for keyboard interactions
                this.currentPlayingColumn = column;
                // Cache the active column element for keyboard-driven live edits
                this.currentActiveColumnEl = columnElement || this.currentActiveColumnEl;
                // Light keyboard notes for the active chord if possible
                try { if (columnElement) this.highlightKeyboardForColumn(columnElement); } catch(_) {}
            }

            playChordStrum(columnElement, chordData, startY, endY) {
                // Ensure audio is ready once for this strum
                if (typeof this.ensureAudioContext === 'function') {
                    // Fire and forget; individual notes also guard, but this minimizes per-note overhead
                    this.ensureAudioContext().catch(()=>{});
                }
                // If there's a newly created blank chord pending, and the user strums another chord first,
                // inherit that strummed chord's tones into the pending blank chord.
                try {
                    if (this.pendingBlankChordId && columnElement) {
                        const pendingId = this.pendingBlankChordId;
                        // Locate the pending column/model
                        const pendingCol = document.querySelector(`.extension-column[data-chord-id='${pendingId}']`);
                        const pendingIdx = (this.chordExtensions||[]).findIndex(c=> String(c.id)===String(pendingId));
                        const isPendingBlank = pendingIdx >= 0 && Array.isArray(this.chordExtensions[pendingIdx].intervals) && this.chordExtensions[pendingIdx].intervals.length === 0;
                        // Ensure we're not strumming the pending column itself
                        const isSameCol = pendingCol && pendingCol === columnElement;
                        // Avoid copying from separators
                        const headerName = columnElement.querySelector('.extension-header .chord-name')?.textContent?.trim() || '';
                        const isSeparator = headerName === '|';
                        if (isPendingBlank && !isSameCol && !isSeparator) {
                            const relSteps = this.getChordStepsForColumn(columnElement);
                            const edo = this.currentTuning || 12;
                            // Choose lowest by 12TET quality and normalize
                            const absSteps = relSteps.map(s=> ((s % edo)+edo)%edo);
                            const best = this._chooseBestRootByQuality(absSteps, edo);
                            const rootAbs = best.root;
                            const normalized = absSteps.map(s=> ((s - rootAbs)%edo+edo)%edo).sort((a,b)=> this.stepToSemitone(a,edo)-this.stepToSemitone(b,edo));
                            // Write into pending model
                            const model = this.chordExtensions[pendingIdx];
                            model.intervals = normalized;
                            model.fixedRootStepAbs = rootAbs;
                            model.fixedRootTuning = edo;
                            const newName = this.computeFullChordNameFromAbsoluteSteps([rootAbs, ...normalized.map(x=> (rootAbs + x)%edo)], edo);
                            model.name = newName;
                            // Update pending column UI
                            if (pendingCol) {
                                try {
                                    const nameEl = pendingCol.querySelector('.extension-header .chord-name');
                                    if (nameEl) { nameEl.textContent = newName; nameEl.dataset.lockedName = newName; }
                                    const old = pendingCol.querySelector('.strings-column');
                                    if (old) old.remove();
                                    this.generateStringsForColumn(pendingCol, model.intervals, true);
                                    this.highlightKeyboardForColumn(pendingCol);
                                    this.currentActiveColumnEl = pendingCol;
                                } catch(_) {}
                            }
                            // Clear pending flag to avoid further copies
                            this.pendingBlankChordId = null;
                            // Persist
                            try { this.saveChordConfiguration(); } catch(_) {}
                        }
                    }
                } catch(_) {}
                // Check if this chord is locked
                let originalSettings = null;
                const lockedChord = this.lockedChords?.get(columnElement);
                
                // Resolve piano-locked settings for this chord (keyed by chord SHAPE)
                let pianoLockedData = null;
                try {
                    // Prefer direct intervals from rendered strings to build a stable shape
                    const relSteps = this.getChordStepsForColumn(columnElement);
                    const chordForLock = {
                        name: (columnElement.querySelector('.extension-header .chord-name')?.textContent||'').trim(),
                        quality: this.currentQuality,
                        intervals: Array.isArray(relSteps) ? relSteps : []
                    };
                    pianoLockedData = this.findPianoLockData(chordForLock);
                } catch(_) {}
                
                if (lockedChord) {
                    console.log('?? Playing locked chord:', lockedChord.chordName, 'locked to root:', lockedChord.lockedRoot);
                    // Store current settings
                    originalSettings = this.captureCurrentSettings();
                    // Apply locked settings
                    this.applyLockedChordSettings(lockedChord);
                    
                    // Always make sure we're using the locked root for playback
                    if (this.currentRoot !== lockedChord.lockedRoot) {
                        console.log('?? Overriding current root', this.currentRoot, 'with locked root:', lockedChord.lockedRoot, 'for playback');
                        this.currentRoot = lockedChord.lockedRoot;
                    }
                } else if (pianoLockedData) {
                    // Apply piano-locked settings (oscillator & effects only)
                    console.log('🎹 Playing chord with piano-locked settings:', pianoLockedData.chordName);
                    this.applyPianoLockedSettings(pianoLockedData);
                }
                
                // Get all strings in the column
                const strings = Array.from(columnElement.querySelectorAll('.string'));
                if (strings.length === 0) return;
                
                // Calculate which strings to play based on start and end positions
                const columnRect = columnElement.getBoundingClientRect();
                const relativeStartY = startY - columnRect.top;
                const relativeEndY = endY - columnRect.top;
                
                // Determine strum direction and range
                const strumDown = relativeEndY > relativeStartY;
                const minY = Math.min(relativeStartY, relativeEndY);
                const maxY = Math.max(relativeStartY, relativeEndY);
                
                // Filter strings that fall within the strum range
                let stringsToPlay = strings.filter(string => {
                    const stringRect = string.getBoundingClientRect();
                    const stringY = stringRect.top + stringRect.height / 2 - columnRect.top;
                    return stringY >= minY && stringY <= maxY;
                });
                // Fallback: if the gesture window captured no strings (e.g., tiny swipe), play them all
                if (stringsToPlay.length === 0) stringsToPlay = strings;
                
                // Sort strings by position for directional strumming
                stringsToPlay.sort((a, b) => {
                    const aY = a.getBoundingClientRect().top;
                    const bY = b.getBoundingClientRect().top;
                    return strumDown ? aY - bY : bY - aY;
                });
                
                // Much faster strum for high-speed playing - 8ms between strings
                const strumDelay = 8; 
                
                stringsToPlay.forEach((string, index) => {
                    setTimeout(() => {
                        let frequency = parseFloat(string.dataset.frequency);
                        if (!frequency || isNaN(frequency) || !isFinite(frequency) || frequency <= 0) {
                            // Compute a safe fallback from stored step/octave
                            try {
                                const step = parseInt(string.dataset.noteIndex, 10);
                                const oct = parseInt(string.dataset.octave, 10);
                                const tuning = (lockedChord?.lockedTuning) || this.currentTuning || 12;
                                if (Number.isFinite(step)) {
                                    frequency = this.getFrequency(((step % tuning) + tuning) % tuning, Number.isFinite(oct) ? oct : 4, tuning);
                                }
                            } catch(_) {}
                        }
                        if (frequency && !isNaN(frequency) && isFinite(frequency) && frequency > 0) {
                            this.playFrequency(frequency, string);
                            
                            // Minimal visual feedback for speed on core only
                            const core = string.querySelector('.string-core');
                            if (core) {
                                core.style.transform = 'scaleY(1.15)';
                                core.style.filter = 'brightness(1.12)';
                                setTimeout(() => {
                                    core.style.transform = 'scaleY(1)';
                                    core.style.filter = 'brightness(1)';
                                }, 90);
                            }
                        }
                    }, index * strumDelay);
                });

                // Let the per-note auto-release handle note lengths so attacks have time to be heard
                // (Previously we forced an early stop at ~200ms which could mute long attacks.)

                // Update keyboard highlighting for current chord tones and keep until next chord
                try { this.highlightKeyboardForColumn(columnElement); this.currentActiveColumnEl = columnElement; } catch(_) {}
                
                // Restore original settings if this was a locked chord
                if (originalSettings) {
                    // Defer restoration until after the strum completes and notes pass their attack/decay
                    const strumSpanMs = Math.max(0, (stringsToPlay.length - 1) * strumDelay);
                    const noteADMs = Math.max(
                        (this.envelope.attack + this.envelope.decay) * 1000,
                        (this.osc2Envelope.attack + this.osc2Envelope.decay) * 1000
                    );
                    const restoreDelay = Math.max(250, strumSpanMs + noteADMs + 50);
                    setTimeout(() => {
                        this.restoreSettings(originalSettings);
                        console.log('?? Restored original settings after locked chord playback');
                    }, restoreDelay);
                }
            }

            // Compute the set of current chord tones (relative steps) for a column
            getChordStepsForColumn(column){
                if (!column) return [];
                const lockedChord = this.lockedChords?.get(column);
                let tuningSize = (lockedChord?.lockedTuning) || this.currentTuning || 12;
                // Gather distinct relative steps from rendered strings
                const strings = Array.from(column.querySelectorAll('.strings-column .string'));
                const relSteps = new Set();
                strings.forEach(row => {
                    const stepStr = row.dataset.edoStep;
                    if (stepStr != null) {
                        const s = ((parseInt(stepStr,10) % tuningSize)+tuningSize)%tuningSize;
                        relSteps.add(s);
                    } else {
                        // Fallback: compute from noteIndex and current root
                        const noteIdx = parseInt(row.dataset.noteIndex,10);
                        const root = this.currentRoot || 0;
                        const s = ((noteIdx - root) % tuningSize + tuningSize) % tuningSize;
                        relSteps.add(s);
                    }
                });
                return Array.from(relSteps.values());
            }

            // Light the keyboard keys/dots that match the current chord tones
            highlightKeyboardForColumn(column){
                const kb = document.querySelector('#rootGrid .piano-keyboard');
                if (!kb || !column) return;
                // Determine effective tuning and base root for this column (mirrors string rendering)
                const lockedChord = this.lockedChords?.get(column) || null;
                let tuningSize = (lockedChord?.lockedTuning) || this.currentTuning || 12;
                // Compute base root exactly like audio rendering:
                // - Locked chords: ignore global transpose; apply local only
                // - Unlocked with fixed root: apply global + local
                // - Unlocked without fixed root: start from currentRoot and apply global + local
                let baseRoot = 0;
                if (lockedChord) {
                    const edo = lockedChord.lockedTuning || tuningSize;
                    const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                    baseRoot = ((lockedChord.lockedRoot ?? 0) + localDelta) % edo;
                    tuningSize = edo;
                } else {
                    try {
                        const id = column.dataset.chordId;
                        let idx = -1;
                        if (id) idx = (this.chordExtensions || []).findIndex(c => (String(c.id)===String(id)));
                        if (idx < 0 && column.dataset.originalPosition != null) {
                            const op = parseInt(column.dataset.originalPosition,10);
                            if (!isNaN(op) && op >= 0) idx = op;
                        }
                        const model = (idx>=0)? this.chordExtensions[idx] : null;
                        if (model && typeof model.fixedRootStepAbs === 'number' && model.fixedRootTuning) {
                            tuningSize = model.fixedRootTuning;
                            const edo = tuningSize;
                            const g = ((this.transposeDelta || 0) % edo + edo) % edo;
                            const l = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                            baseRoot = (((model.fixedRootStepAbs % edo) + g + l) % edo + edo) % edo;
                        } else {
                            const edo = tuningSize;
                            const g = ((this.transposeDelta || 0) % edo + edo) % edo;
                            const l = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                            const start = (this.currentRoot ?? 0) % edo;
                            baseRoot = (((start + g + l) % edo) + edo) % edo;
                        }
                    } catch {}
                }
                const steps = this.getChordStepsForColumn(column);
                // Clear previous chord-tone marks and any inline glow
                kb.querySelectorAll('[data-step]').forEach(el=>{
                    el.classList.remove('chord-tone');
                    try { el.style.boxShadow = ''; el.style.outlineColor = ''; } catch(_){}
                });
                // Apply colored glow per chord tone (by pitch class/semitone color)
                const kbEdo = this.currentTuning || 12;
                steps.forEach(rel =>{
                    // Compute absolute step in the chord's tuning
                    const absInModel = ((baseRoot + rel) % tuningSize + tuningSize) % tuningSize;
                    // Map that absolute step to the keyboard's EDO via cents
                    let abs;
                    if (tuningSize === kbEdo) {
                        abs = absInModel;
                    } else {
                        const cents = (absInModel * 1200) / tuningSize;
                        abs = Math.round((cents * kbEdo) / 1200);
                        abs = ((abs % kbEdo) + kbEdo) % kbEdo;
                    }
                    const semi = this.stepToSemitone(abs, kbEdo);
                    const color = this.getChromaticColorForSemitone(semi);
                    if (kbEdo === 12) {
                        // Match any element whose data-step % 12 equals abs % 12
                        kb.querySelectorAll('[data-step]').forEach(el=>{
                            const ds = parseInt(el.dataset.step,10);
                            if ((ds % 12) === (abs % 12)) {
                                el.classList.add('chord-tone');
                                try {
                                    el.style.boxShadow = `0 0 10px 3px ${color}99, 0 0 18px 6px ${color}55`;
                                    el.style.outlineColor = color;
                                } catch(_){ }
                            }
                        });
                    } else {
                        kb.querySelectorAll(`[data-step='${abs}']`).forEach(el=>{
                        el.classList.add('chord-tone');
                        try {
                            el.style.boxShadow = `0 0 10px 3px ${color}99, 0 0 18px 6px ${color}55`;
                            el.style.outlineColor = color;
                        } catch(_){ }
                    });
                    }
                });
            }

            // Resolve the active column element to mutate when editing via keyboard
            getActiveColumnElement(){
                if (this.currentActiveColumnEl && document.body.contains(this.currentActiveColumnEl)) return this.currentActiveColumnEl;
                // Fallback: use currentPlayingColumn id
                if (this.currentPlayingColumn != null) {
                    const el = document.querySelector(`[data-column="${this.currentPlayingColumn}"]`);
                    if (el) return el;
                }
                // No active column
                return null;
            }

            // Lookup a chord column DOM element by its stable id
            getColumnByChordId(id){
                if (!id) return null;
                try { return document.querySelector(`.extension-column[data-chord-id='${id}']`); } catch(_) { return null; }
            }

            // Toggle an absolute keyboard step in the currently active chord
            toggleNoteInActiveChord(absStep){
                // Re-entrancy guard
                if (this._toggling) return; this._toggling = true; setTimeout(()=>{ this._toggling = false; }, 0);
                const column = this.getActiveColumnElement();
                if (!column) return;
                // Allow editing even if previously locked (universal editor model)
                // Determine tuning and base root for this column
                const lockedChord = this.lockedChords?.get(column) || null;
                let tuningSize = (lockedChord?.lockedTuning) || this.currentTuning || 12;
                // Compute base root exactly like highlight/audio, in EFFECTIVE space (includes transpose as applicable)
                let baseRoot = 0;
                try {
                    // Resolve chord model if present
                    let idxModel = column.dataset.originalPosition != null ? parseInt(column.dataset.originalPosition,10) : -1;
                    if (isNaN(idxModel) || idxModel < 0) {
                        const id = column.dataset.chordId;
                        idxModel = (this.chordExtensions || []).findIndex(c => (c.id===id));
                    }
                    const chordModel = (idxModel>=0)? this.chordExtensions[idxModel] : null;
                    if (lockedChord) {
                        const edo = lockedChord.lockedTuning || tuningSize;
                        const localDelta = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                        baseRoot = ((lockedChord.lockedRoot ?? 0) + localDelta) % edo;
                        tuningSize = edo;
                    } else if (chordModel && typeof chordModel.fixedRootStepAbs === 'number' && chordModel.fixedRootTuning) {
                        tuningSize = chordModel.fixedRootTuning;
                        const edo = tuningSize;
                        const g = ((this.transposeDelta || 0) % edo + edo) % edo;
                        const l = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                        baseRoot = (((chordModel.fixedRootStepAbs % edo) + g + l) % edo + edo) % edo;
                    } else {
                        const edo = tuningSize;
                        const g = ((this.transposeDelta || 0) % edo + edo) % edo;
                        const l = ((+column.dataset.localTranspose || 0) % edo + edo) % edo;
                        const start = (this.currentRoot ?? 0) % edo;
                        baseRoot = (((start + g + l) % edo) + edo) % edo;
                    }
                } catch {}

                // If the keyboard EDO differs from the chord's EDO, map the clicked step via cents
                const kbEdo = this.currentTuning || 12;
                // If the chord's model EDO differs from the keyboard, migrate the chord model to the keyboard EDO first
                // so that adding micro-steps never snaps back to the old EDO grid.
                if (!lockedChord && kbEdo !== tuningSize) {
                    try {
                        let idx = column.dataset.originalPosition != null ? parseInt(column.dataset.originalPosition,10) : this.findChordPosition?.(column) ?? -1;
                        if (isNaN(idx) || idx < 0) {
                            const id = column.dataset.chordId;
                            idx = (this.chordExtensions || []).findIndex(c => (c.id===id));
                        }
                        if (idx >= 0) {
                            const chordModel = this.chordExtensions[idx];
                            const mapStep = (s, fromEdo, toEdo) => {
                                const cents = (s * 1200) / fromEdo;
                                return ((Math.round((cents * toEdo) / 1200) % toEdo) + toEdo) % toEdo;
                            };
                            // Migrate relative intervals
                            if (Array.isArray(chordModel.intervals)) {
                                chordModel.intervals = chordModel.intervals.map(v => mapStep(((v % tuningSize)+tuningSize)%tuningSize, tuningSize, kbEdo));
                            }
                            // Migrate fixed root if present; otherwise map baseRoot
                            if (typeof chordModel.fixedRootStepAbs === 'number' && chordModel.fixedRootTuning) {
                                chordModel.fixedRootStepAbs = mapStep(((chordModel.fixedRootStepAbs % tuningSize)+tuningSize)%tuningSize, tuningSize, kbEdo);
                                chordModel.fixedRootTuning = kbEdo;
                            } else {
                                baseRoot = mapStep(baseRoot, tuningSize, kbEdo);
                            }
                            chordModel.isCustom = true;
                            // Adopt new tuning size for subsequent calculations
                            tuningSize = kbEdo;
                        }
                    } catch(_) {}
                }
                let absInTarget = ((absStep % tuningSize)+tuningSize)%tuningSize;
                // Compute relative step to toggle
                const rel = ((absInTarget - baseRoot) % tuningSize + tuningSize) % tuningSize;
                // Get the chord model behind this column
                let idx = column.dataset.originalPosition != null ? parseInt(column.dataset.originalPosition,10) : this.findChordPosition?.(column) ?? -1;
                if (isNaN(idx) || idx < 0 || idx >= (this.chordExtensions?.length||0)) {
                    // Attempt alternative: match by dataset.chordId
                    const id = column.dataset.chordId;
                    idx = (this.chordExtensions || []).findIndex(c => (c.id===id));
                }
                if (idx < 0) return;
                const chordModel2 = this.chordExtensions[idx];
                if (!chordModel2) return;
                // Work on a set of intervals in this tuning; intervals are already EDO steps for customs
                const set = new Set((chordModel2.intervals || []).map(v => ((v % tuningSize)+tuningSize)%tuningSize));
                // Toggle presence including the current root; allow removing it to enable re-rooting by lowest note
                if (set.has(rel)) set.delete(rel); else set.add(rel);
                // Allow empty set temporarily (blank chord) until user adds notes
                const relSorted = Array.from(set.values()).sort((a,b)=>{
                    const sa = this.stepToSemitone(a, tuningSize);
                    const sb = this.stepToSemitone(b, tuningSize);
                    return sa - sb;
                });
                if (relSorted.length === 0) {
                    // Blank chord: clear intervals and strings, reset name to placeholder
                    chordModel2.intervals = [];
                    delete chordModel2.fixedRootStepAbs;
                    delete chordModel2.fixedRootTuning;
                    const oldContainer = column.querySelector('.strings-column');
                    if (oldContainer) oldContainer.remove();
                    this.generateStringsForColumn(column, [], true);
                    try {
                        const nameEl = column.querySelector('.extension-header .chord-name');
                        nameEl.textContent = 'New';
                        nameEl.dataset.lockedName = nameEl.textContent;
                    } catch {}
                    try { this.highlightKeyboardForColumn(column); } catch {}
                    // If this emptied chord is the latest created, mark it pending again for inheritance
                    try {
                        const thisId = column.dataset.chordId;
                        if (thisId) this.pendingBlankChordId = thisId;
                    } catch(_) {}
                    this._scheduleEditSave(column);
                    return;
                }
                // Choose a musical root by best quality in 12-TET space, then normalize
                const absSet = relSorted.map(v => ((baseRoot + v) % tuningSize + tuningSize) % tuningSize);
                // User expects naming from the true lowest note; do not re-root by 12-TET quality
                const lowestAbs = absSet.reduce((m,v)=> v < m ? v : m, absSet[0]);
                const normalized = absSet.map(s => ((s - lowestAbs) % tuningSize + tuningSize) % tuningSize).sort((a,b)=>{
                    const sa = this.stepToSemitone(a, tuningSize);
                    const sb = this.stepToSemitone(b, tuningSize);
                    return sa - sb;
                });
                chordModel2.intervals = normalized;
                chordModel2.fixedRootStepAbs = lowestAbs;
                chordModel2.fixedRootTuning = tuningSize;
                // Treat any chord that has been edited from the keyboard as a custom chord in EDO steps
                chordModel2.isCustom = true;
                // Build absolute steps for naming in MODEL space (remove current global transpose to avoid double-application)
                const t = ((this.transposeDelta || 0) % tuningSize + tuningSize) % tuningSize;
                const absForName = [lowestAbs, ...normalized.map(x=> (lowestAbs + x)%tuningSize)];
                const deTransposed = absForName.map(s => ((s - t) % tuningSize + tuningSize) % tuningSize);
                const newName = this.computeFullChordNameFromAbsoluteSteps(deTransposed, tuningSize);
                // Update header text to always include computed root (from lowest note)
                try {
                    const nameEl = column.querySelector('.extension-header .chord-name');
                    nameEl.textContent = newName;
                    nameEl.dataset.lockedName = nameEl.textContent;
                } catch {}
                // Persist the new name on the chord model so future regenerations keep it
                try { chordModel2.name = newName; } catch {}
                // First time we add notes to the pending blank chord, clear the pending flag
                try {
                    if (this.pendingBlankChordId && String(column.dataset.chordId) === String(this.pendingBlankChordId)) {
                        this.pendingBlankChordId = null;
                    }
                } catch(_) {}
                // Regenerate strings for this column only; drop exact snapshot so changes apply
                if (lockedChord && lockedChord.exactFrequencies) lockedChord.exactFrequencies = [];
                const oldContainer = column.querySelector('.strings-column');
                if (oldContainer) oldContainer.remove();
                if (lockedChord) this.generateStringsForColumnWithLockedSettings(column, chordModel2.intervals, lockedChord);
                else this.generateStringsForColumn(column, chordModel2.intervals, chordModel2.isCustom||false);
                // Refresh keyboard highlight
                try { this.highlightKeyboardForColumn(column); } catch {}
                this._scheduleEditSave(column);
                // Lightly preview the updated chord
                try {
                    const rows = Array.from(column.querySelectorAll('.strings-column .string'));
                    rows.slice(0, Math.min(rows.length, 6)).forEach((row, i)=>{
                        const f = parseFloat(row.dataset.frequency);
                        if (!isNaN(f)) setTimeout(()=> this.playFrequency(f, row), i*10);
                    });
                } catch {}
            }

            async playFrequency(frequency, element) {
                console.log('playFrequency called with:', frequency, 'Hz', element ? 'element present' : 'no element');
                
                // Validate frequency before processing
                if (!frequency || isNaN(frequency) || !isFinite(frequency) || frequency <= 0) {
                    console.error('Invalid frequency passed to playFrequency:', frequency);
                    return;
                }

                // Ensure AudioContext is ready
                const audioReady = await this.ensureAudioContext();
                if (!audioReady) {
                    console.warn('AudioContext not ready, skipping playback');
                    return;
                }
                
                // Check if this string belongs to a piano-locked chord and apply those settings
                const isDomEl = element && typeof element === 'object' && (element.closest || element.classList || element.querySelector);
                const safeElement = isDomEl ? element : null;
                const columnElement = safeElement && safeElement.closest ? safeElement.closest('.extension-column') : null;
                let pianoLockedData = null;
                let originalSettings = null;
                
                if (columnElement) {
                    try {
                        const relSteps = this.getChordStepsForColumn(columnElement);
                        const chordData = {
                            name: (columnElement.querySelector('.extension-header .chord-name')?.textContent||'').trim(),
                            quality: this.currentQuality,
                            intervals: Array.isArray(relSteps) ? relSteps : []
                        };
                        pianoLockedData = this.findPianoLockData(chordData);
                    } catch(_) {}
                }
                
                if (pianoLockedData) {
                    console.log('🎹 Applying piano-locked settings for playback:', pianoLockedData.chordName);
                    
                    // Store current settings for immediate restoration
                    originalSettings = {
                        osc1: { ...this.oscillators.osc1 },
                        osc2: { ...this.oscillators.osc2 },
                        envelope: { ...this.envelope },
                        osc2Envelope: { ...this.osc2Envelope },
                        reverb: { ...this.reverb },
                        panning: { ...this.panning },
                        volume: this.volume,
                        masterVolume: this.masterVolume
                    };
                    
                    // Apply piano-locked settings temporarily (UI DOES NOT CHANGE)
                    this.applyPianoLockedSettings(pianoLockedData);
                }
                
                // If oscillator already exists, stop it first to prevent overlap
                if (this.activeOscillators.has(frequency)) {
                    this.stopFrequency(frequency, safeElement);
                }
                
                if (!this.audioContext) return;
                
                // Create dual oscillators (or noise sources) with separate envelopes
                let osc1, osc2;
                const osc1Envelope = this.audioContext.createGain();
                const osc2Envelope = this.audioContext.createGain();
                const osc1Gain = this.audioContext.createGain();
                const osc2Gain = this.audioContext.createGain();
                const finalMixer = this.audioContext.createGain();
                
                // Create oscillator 1 (or noise)
                if (this.oscillators.osc1.type === 'noise') {
                    osc1 = this.createNoiseSource();
                } else {
                    osc1 = this.audioContext.createOscillator();
                    const t1 = this.oscillators.osc1.type;
                    if (['pulse','fullrect','halfrect','trapezoid','parabolic','stair'].includes(t1)) {
                        osc1.setPeriodicWave(this.getCustomPeriodicWave(t1, this.oscillators.osc1.pulseWidth));
                    } else {
                        osc1.type = t1;
                    }
                    const totalDetune1 = this.oscillators.osc1.detune + (this.oscillators.osc1.coarse * (1200 / this.currentTuning));
                    const freq1 = frequency * Math.pow(2, this.oscillators.osc1.octave + (totalDetune1 / 1200));
                    osc1.frequency.setValueAtTime(freq1, this.audioContext.currentTime);
                }
                
                // Create oscillator 2 (or noise)
                if (this.oscillators.osc2.type === 'noise') {
                    osc2 = this.createNoiseSource();
                } else {
                    osc2 = this.audioContext.createOscillator();
                    const t2 = this.oscillators.osc2.type;
                    if (['pulse','fullrect','halfrect','trapezoid','parabolic','stair'].includes(t2)) {
                        osc2.setPeriodicWave(this.getCustomPeriodicWave(t2, this.oscillators.osc2.pulseWidth));
                    } else {
                        osc2.type = t2;
                    }
                    const totalDetune2 = this.oscillators.osc2.detune + (this.oscillators.osc2.coarse * (1200 / this.currentTuning));
                    const freq2 = frequency * Math.pow(2, this.oscillators.osc2.octave + (totalDetune2 / 1200));
                    osc2.frequency.setValueAtTime(freq2, this.audioContext.currentTime);
                }
                
                // Set oscillator levels (master volume handled by this.gainNode)
                osc1Gain.gain.value = this.oscillators.osc1.level;
                osc2Gain.gain.value = this.oscillators.osc2.level;
                
                // Connect oscillators through their individual envelopes
                osc1.connect(osc1Gain);
                osc1Gain.connect(osc1Envelope);
                
                osc2.connect(osc2Gain);
                osc2Gain.connect(osc2Envelope);
                
                // Simple addition - both oscillators mixed
                osc1Envelope.connect(finalMixer);
                osc2Envelope.connect(finalMixer);
                console.log('Both oscillators mixed');
                
                const currentTime = this.audioContext.currentTime;
                
                // Create panner and apply panning based on mode (BEFORE reverb)
                const panner = this.audioContext.createStereoPanner();
                let panValue = 0; // Default center
                
                switch (this.panning.mode) {
                    case 'frequency':
                        // Pan based on frequency (low = left, high = right)
                        const logFreq = Math.log2(frequency / 220); // A3 as reference
                        panValue = Math.max(-1, Math.min(1, logFreq * 0.3)) * this.panning.width;
                        break;
                    case 'random':
                        // Random panning
                        panValue = (Math.random() * 2 - 1) * this.panning.width;
                        break;
                    case 'rotating':
                        // Rotating panning
                        this.panning.rotationAngle += 0.1;
                        panValue = Math.sin(this.panning.rotationAngle) * this.panning.width;
                        break;
                    case 'alternating':
                        // Alternating left/right
                        this.panning.alternateState = !this.panning.alternateState;
                        panValue = (this.panning.alternateState ? 1 : -1) * this.panning.width;
                        break;
                    default:
                        // Center
                        panValue = 0;
                        break;
                }
                
                panner.pan.setValueAtTime(panValue, currentTime);
                
                // Connect: finalMixer ? panner ? gainNode (gainNode routes to reverb)
                finalMixer.connect(panner);
                panner.connect(this.gainNode);
                
                // OSC 1 ADSR envelope (master ADSR)
                const osc1AttackTime = currentTime + this.envelope.attack;
                const osc1DecayTime = osc1AttackTime + this.envelope.decay;
                
                osc1Envelope.gain.setValueAtTime(0, currentTime);
                osc1Envelope.gain.linearRampToValueAtTime(1, osc1AttackTime); // Attack
                osc1Envelope.gain.linearRampToValueAtTime(this.envelope.sustain, osc1DecayTime); // Decay to sustain
                
                // OSC 2 ADSR envelope (separate OSC 2 ADSR)
                const osc2AttackTime = currentTime + this.osc2Envelope.attack;
                const osc2DecayTime = osc2AttackTime + this.osc2Envelope.decay;
                
                osc2Envelope.gain.setValueAtTime(0, currentTime);
                osc2Envelope.gain.linearRampToValueAtTime(1, osc2AttackTime); // Attack
                osc2Envelope.gain.linearRampToValueAtTime(this.osc2Envelope.sustain, osc2DecayTime); // Decay to sustain
                
                osc1.start();
                osc2.start();
                
                // If we applied piano-locked settings, restore the original synthesizer state immediately
                if (originalSettings) {
                    console.log('🎹 Restoring original settings (no UI change)');
                    
                    // Restore from the stored original settings
                    Object.assign(this.oscillators.osc1, originalSettings.osc1);
                    Object.assign(this.oscillators.osc2, originalSettings.osc2);
                    Object.assign(this.envelope, originalSettings.envelope);
                    Object.assign(this.osc2Envelope, originalSettings.osc2Envelope);
                    Object.assign(this.reverb, originalSettings.reverb);
                    Object.assign(this.panning, originalSettings.panning);
                    this.volume = originalSettings.volume;
                    this.masterVolume = originalSettings.masterVolume;
                    
                    // Update audio context nodes if available
                    if (this.wetGainNode && this.dryGainNode) {
                        this.wetGainNode.gain.value = this.reverb.wet;
                        this.dryGainNode.gain.value = 1.0 - this.reverb.wet;
                    }
                    if (this.reverbFilterNode) {
                        this.reverbFilterNode.frequency.value = this.reverb.filterCutoff;
                    }
                    if (typeof this.updateReverbRouting === 'function') this.updateReverbRouting();
                    if (this.gainNode) {
                        this.gainNode.gain.value = this.volume * this.masterVolume;
                    }
                }
                
                // Auto-release exactly at the end of decay to avoid infinite sustain on taps
                const endOfDecayTime = Math.max(osc1DecayTime, osc2DecayTime);
                const releaseDelayMs = Math.max(0, (endOfDecayTime - currentTime) * 1000);
                const releaseTimeout = setTimeout(() => {
                    this.stopFrequency(frequency, safeElement);
                }, releaseDelayMs);

                // Store oscillator data along with the exact ADSR values used at note start
                this.activeOscillators.set(frequency, { 
                    osc1, 
                    osc2, 
                    osc1Envelope,
                    osc2Envelope,
                    finalMixer,
                    panner,
                    osc1Gain,
                    osc2Gain,
                    releaseTimeout,
                    startTime: currentTime,
                    env1: {
                        attack: this.envelope.attack,
                        decay: this.envelope.decay,
                        sustain: this.envelope.sustain,
                        release: this.envelope.release
                    },
                    env2: {
                        attack: this.osc2Envelope.attack,
                        decay: this.osc2Envelope.decay,
                        sustain: this.osc2Envelope.sustain,
                        release: this.osc2Envelope.release
                    }
                });
                if (safeElement) {
                    safeElement.classList.add('active');
                    const core = safeElement.querySelector('.string-core');
                    if (core) {
                        const stepIndex = parseInt(safeElement.dataset.noteIndex||'0',10);
                        const period = this.computeVibrationPeriod(frequency, stepIndex);
                        core.style.setProperty('--vib-period', period + 'ms');
                        core.classList.add('vibrating');
                    }
                }
            }

            stopFrequency(frequency, element) {
                const osc = this.activeOscillators.get(frequency);
                if (!osc) return;
                
                const { osc1, osc2, osc1Envelope, osc2Envelope, releaseTimeout, env1, env2 } = osc;
                
                // Clear auto-release timeout
                if (releaseTimeout) {
                    clearTimeout(releaseTimeout);
                }
                
                // Remove from active oscillators immediately to prevent overlap
                this.activeOscillators.delete(frequency);
                
                try {
                    const currentTime = this.audioContext.currentTime;
                    
                    // Apply OSC 1 release envelope
                    osc1Envelope.gain.cancelScheduledValues(currentTime);
                    osc1Envelope.gain.setValueAtTime(osc1Envelope.gain.value, currentTime);
                    osc1Envelope.gain.linearRampToValueAtTime(0, currentTime + Math.max(0, env1?.release ?? this.envelope.release));
                    
                    // Apply OSC 2 release envelope
                    osc2Envelope.gain.cancelScheduledValues(currentTime);
                    osc2Envelope.gain.setValueAtTime(osc2Envelope.gain.value, currentTime);
                    osc2Envelope.gain.linearRampToValueAtTime(0, currentTime + Math.max(0, env2?.release ?? this.osc2Envelope.release));
                    
                    // Stop oscillators after the longer of the two release times (based on the values used at note start)
                    const maxReleaseTime = Math.max(Math.max(0, env1?.release ?? this.envelope.release), Math.max(0, env2?.release ?? this.osc2Envelope.release));
                    osc1.stop(currentTime + maxReleaseTime);
                    osc2.stop(currentTime + maxReleaseTime);
                    
                    console.log('Note stopped with', maxReleaseTime, 'second release time');
                    
                    // Clean up visual indicator
                    setTimeout(() => {
                        if (element) {
                            element.classList.remove('active');
                            const core = element.querySelector('.string-core');
                            if (core) core.classList.remove('vibrating');
                        }
                    }, maxReleaseTime * 1000 + 50);
                } catch (error) {
                    console.warn('Error stopping oscillator:', error);
                    if (element) {
                        element.classList.remove('active');
                        const core = element.querySelector('.string-core');
                        if (core) core.classList.remove('vibrating');
                    }
                }
            }

            stopAllStrings() {
                // Stop all currently playing oscillators with proper release
                for (const [frequency, oscData] of this.activeOscillators) {
                    const { osc1, osc2, osc1Envelope, osc2Envelope, releaseTimeout } = oscData;
                    
                    if (releaseTimeout) {
                        clearTimeout(releaseTimeout);
                    }
                    
                    try {
                        const currentTime = this.audioContext.currentTime;
                        
                        // Apply OSC 1 release envelope
                        osc1Envelope.gain.cancelScheduledValues(currentTime);
                        osc1Envelope.gain.setValueAtTime(osc1Envelope.gain.value, currentTime);
                        osc1Envelope.gain.linearRampToValueAtTime(0, currentTime + this.envelope.release);
                        
                        // Apply OSC 2 release envelope
                        osc2Envelope.gain.cancelScheduledValues(currentTime);
                        osc2Envelope.gain.setValueAtTime(osc2Envelope.gain.value, currentTime);
                        osc2Envelope.gain.linearRampToValueAtTime(0, currentTime + this.osc2Envelope.release);
                        
                        // Stop oscillators after the longer of the two release times
                        const maxReleaseTime = Math.max(this.envelope.release, this.osc2Envelope.release);
                        osc1.stop(currentTime + maxReleaseTime);
                        osc2.stop(currentTime + maxReleaseTime);
                    } catch (error) {
                        console.warn('Error stopping oscillator:', error);
                    }
                }
                
                // Clear all tracking
                this.activeOscillators.clear();
                this.triggeredStrings.clear();
                
                // Remove visual indicators
                document.querySelectorAll('.string.active').forEach(el => {
                    el.classList.remove('active');
                });
            }

            // Tutorial System
            initTutorial() {
                this.tutorialStep = 0;
                this.tutorialSteps = [
                    {
                        title: "Welcome to OMGnichord",
                        text: "This is a microtonal omnichord that lets you explore different tuning systems and create awesome harmonic textures. You start with a Major chord ready to play!",
                        highlight: null
                    },
                    {
                        title: "Initial Setup",
                        text: "You can freely change the tuning system and root note before creating new chords. Enter the number of notes per octave (2/1) or use other ratios for things like Bohlen Pierce.",
                        highlight: "#tuningSelector"
                    },
                    {
                        title: "Playing Chords",
                        text: "The Major chord is ready to play! Click and drag vertically on the column to strum the strings. Each column represents a different chord type.",
                        highlight: "#extensionColumns"
                    },
                    {
                        title: "Creating New Chords",
                        text: "Click 'New Chord' to enter chord creation mode. You'll build custom chords by selecting intervals on the top row of the screen.",
                        highlight: "[data-action='newChord']"
                    },
                    {
                        title: "Piano Lock System",
                        text: "Click the piano icon (🎹) on any chord header to 'piano lock' it - this saves the current synthesizer settings (oscillators + effects) specifically for that chord. Each chord gets its own unique sound preset!",
                        highlight: "#extensionColumns"
                    },
                    {
                        title: "Master Controls",
                        text: "Control the overall volume and mix of your sound here. The Master Volume affects everything, and you can adjust the overall stereo balance.",
                        highlight: "#masterSection"
                    },
                    {
                        title: "Effects Section",
                        text: "Add reverb and control stereo panning. Piano-locked chords preserve their individual effect settings while still responding to master controls.",
                        highlight: "#effectsSection"
                    },
                    {
                        title: "Oscillators",
                        text: "Each oscillator has waveform selection, volume, coarse tuning, and ADSR envelope controls. Piano-locked chords remember their oscillator settings. Use the dice button to randomize for inspiration!",
                        highlight: "#oscillatorsSection"
                    },
                    {
                        title: "Saving & Loading",
                        text: "Use 'Save .OMG' to save your complete session - all chords, piano locks, and synthesizer presets. Loading an OMG file restores everything and leaves you ready to create more chords!",
                        highlight: "#saveSessionBtn"
                    },
                    {
                        title: "Advanced Features",
                        text: "Each chord supports per-chord transpose (▲▼) and piano-lock (🎹) for oscillator/effect presets. Piano locks work across all root notes until manually unlocked.",
                        highlight: "#extensionColumns"
                    }
                ];

                document.getElementById('tutorialButton').addEventListener('click', () => {
                    this.startTutorial();
                });

                document.getElementById('tutorialNext').addEventListener('click', () => {
                    this.nextTutorialStep();
                });

                document.getElementById('tutorialPrev').addEventListener('click', () => {
                    this.prevTutorialStep();
                });

                document.getElementById('tutorialSkip').addEventListener('click', () => {
                    this.endTutorial();
                });

                // Initialize escape mechanisms
                this.initTutorialEscapes();
            }

            startTutorial() {
                this.tutorialStep = 0;
                document.getElementById('tutorialOverlay').style.display = 'block';
                this.showTutorialStep();
                this.greyOutAll();
                
                // Add escape mechanisms
                document.addEventListener('keydown', this.tutorialEscapeHandler);
            }

            showTutorialStep() {
                const step = this.tutorialSteps[this.tutorialStep];
                document.getElementById('tutorialTitle').textContent = step.title;
                document.getElementById('tutorialText').textContent = step.text;

                // Update button states
                document.getElementById('tutorialPrev').style.display = this.tutorialStep > 0 ? 'inline-block' : 'none';
                document.getElementById('tutorialNext').textContent = this.tutorialStep < this.tutorialSteps.length - 1 ? 'Next' : 'Finish';

                // Position tutorial box
                this.positionTutorialBox(step.highlight);

                // Highlight current element
                this.highlightElement(step.highlight);
            }

            positionTutorialBox(selector) {
                const tutorialBox = document.getElementById('tutorialBox');
                
                if (selector) {
                    const element = document.querySelector(selector);
                    if (element) {
                        const rect = element.getBoundingClientRect();
                        const boxWidth = 400;
                        const boxHeight = 250;
                        
                        // Try to position next to the element
                        let left = rect.right + 20;
                        let top = rect.top;
                        
                        // Keep box on screen
                        if (left + boxWidth > window.innerWidth) {
                            left = rect.left - boxWidth - 20;
                        }
                        if (left < 20) {
                            left = 20;
                        }
                        
                        if (top + boxHeight > window.innerHeight) {
                            top = window.innerHeight - boxHeight - 20;
                        }
                        if (top < 20) {
                            top = 20;
                        }
                        
                        tutorialBox.style.left = `${left}px`;
                        tutorialBox.style.top = `${top}px`;
                        tutorialBox.style.transform = 'none';
                    } else {
                        // Center if element not found
                        tutorialBox.style.left = '50%';
                        tutorialBox.style.top = '50%';
                        tutorialBox.style.transform = 'translate(-50%, -50%)';
                    }
                } else {
                    // Center the box
                    tutorialBox.style.left = '50%';
                    tutorialBox.style.top = '50%';
                    tutorialBox.style.transform = 'translate(-50%, -50%)';
                }
            }

            highlightElement(selector) {
                // Remove previous highlights
                document.querySelectorAll('.tutorial-highlight').forEach(el => {
                    el.classList.remove('tutorial-highlight');
                    el.style.position = '';
                    el.style.zIndex = '';
                    el.style.filter = '';
                });

                if (selector) {
                    const element = document.querySelector(selector);
                    if (element) {
                        element.classList.add('tutorial-highlight');
                        element.style.position = 'relative';
                        element.style.zIndex = '2100';
                        element.style.filter = 'brightness(1.5) contrast(1.2)';
                    }
                }
            }

            greyOutAll() {
                // Create overlay instead of using filter to avoid breaking highlighting
                const overlay = document.createElement('div');
                overlay.id = 'tutorialGreyOverlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    z-index: 1900;
                    pointer-events: none;
                `;
                document.body.appendChild(overlay);
            }

            ungreyAll() {
                const overlay = document.getElementById('tutorialGreyOverlay');
                if (overlay) {
                    overlay.remove();
                }
                // Also remove any filters that might have been applied
                document.body.style.filter = '';
            }

            nextTutorialStep() {
                if (this.tutorialStep < this.tutorialSteps.length - 1) {
                    this.tutorialStep++;
                    this.showTutorialStep();
                } else {
                    this.endTutorial();
                }
            }

            prevTutorialStep() {
                if (this.tutorialStep > 0) {
                    this.tutorialStep--;
                    this.showTutorialStep();
                }
            }

            endTutorial() {
                document.getElementById('tutorialOverlay').style.display = 'none';
                this.ungreyAll();
                this.highlightElement(null);
                
                // Remove any event listeners that might interfere
                document.removeEventListener('keydown', this.tutorialEscapeHandler);
            }

            // Add escape key handler and click-to-close functionality
            initTutorialEscapes() {
                // ESC key to close tutorial
                this.tutorialEscapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.endTutorial();
                    }
                };

                // Click outside tutorial box to close
                document.getElementById('tutorialOverlay').addEventListener('click', (e) => {
                    if (e.target.id === 'tutorialOverlay') {
                        this.endTutorial();
                    }
                });
            }

            // Random Dice System
            initRandomDice() {
                document.getElementById('randomDiceButton').addEventListener('click', () => {
                    this.randomizeEverything();
                });
            }

            randomizeEverything() {
                // 🎹 PROTECTION: Store all piano-locked settings AND preloaded presets before randomization
                const protectedPianoLocks = new Map();
                const protectedPresets = new Map();
                
                if (this.pianoLockedChords && this.pianoLockedChords.size > 0) {
                    
                    // Create deep copies of all piano lock data
                    this.pianoLockedChords.forEach((lockData, key) => {
                        protectedPianoLocks.set(key, {
                            ...lockData,
                            presetId: lockData.presetId, // Preserve preset ID
                            osc1: { ...lockData.osc1 },
                            osc2: { ...lockData.osc2 },
                            envelope: { ...lockData.envelope },
                            osc2Envelope: { ...lockData.osc2Envelope },
                            reverb: { ...lockData.reverb },
                            panning: { ...lockData.panning },
                            volume: { ...lockData.volume }
                        });
                    });
                    
                    // Also protect preloaded presets
                    this.preloadedPresets.forEach((presetData, presetId) => {
                        protectedPresets.set(presetId, {
                            ...presetData,
                            osc1: { ...presetData.osc1 },
                            osc2: { ...presetData.osc2 },
                            envelope: { ...presetData.envelope },
                            osc2Envelope: { ...presetData.osc2Envelope },
                            reverb: { ...presetData.reverb },
                            panning: { ...presetData.panning },
                            volume: { ...presetData.volume }
                        });
                    });
                } else {
                    
                }
                
                // Animate the dice button
                const diceBtn = document.getElementById('randomDiceButton');
                diceBtn.style.transform = 'rotate(720deg)';
                setTimeout(() => {
                    diceBtn.style.transform = '';
                }, 600);

                // Focus purely on oscillator sound design - no tuning/chord changes
                this.randomizeOscillator(1);
                this.randomizeOscillator(2);

                // Randomize effects for sonic variety
                this.randomizeEffects();

                // 🎹 RESTORE: Put back all piano-locked settings and presets after randomization
                if (protectedPianoLocks.size > 0) {
                    this.pianoLockedChords = protectedPianoLocks;
                    
                    // Restore preloaded presets
                    this.preloadedPresets = protectedPresets;
                    
                    // Also restore the UI button states for piano locks
                    setTimeout(() => {
                        this.restorePianoLockStates();
                        // Warm all currently piano-locked columns (use markers or backend flags)
                        try {
                            document.querySelectorAll('.extension-column.piano-locked-col').forEach(col => { try { this.preloadPianoLockedChord(col); } catch(_){} });
                            document.querySelectorAll('.extension-column').forEach(col => {
                                try {
                                    const hdr = col.querySelector('.extension-header');
                                    const cd = (typeof this.getChordDataFromColumn === 'function') ? this.getChordDataFromColumn(col, hdr) : null;
                                    if (cd && cd.isPianoLocked) { try { this.preloadPianoLockedChord(col); } catch(_){} }
                                } catch(_){}
                            });
                        } catch(_) {}
                    }, 100);
                }
            }

            // Create a tiny, near-silent tick through the full chain to wake up the audio graph/IR
            async warmUpAudioGraph(durationMs = 18) {
                try {
                    const ok = await this.ensureAudioContext();
                    if (!ok || !this.audioContext || !this.gainNode) return;
                    // Short sine pip at -60dB to exercise convolver/panner/gain path without being audible
                    const osc = this.audioContext.createOscillator();
                    const g = this.audioContext.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(440, this.audioContext.currentTime);
                    g.gain.setValueAtTime(0.001, this.audioContext.currentTime); // ~-60 dB
                    osc.connect(g);
                    g.connect(this.gainNode);
                    const t0 = this.audioContext.currentTime;
                    osc.start(t0);
                    osc.stop(t0 + Math.max(0.001, durationMs/1000));
                } catch(_) { /* ignore */ }
            }

            // Preload/warm a piano-locked chord's preset and current notes for instant playback
            async preloadPianoLockedChord(columnElement) {
                if (!columnElement) return;
                try {
                    const relSteps = this.getChordStepsForColumn(columnElement);
                    const chordData = { intervals: Array.isArray(relSteps) ? relSteps : [] };
                    const pianoLockedData = this.findPianoLockData(chordData);
                    if (!pianoLockedData) return;
                    // Build a warmup key that changes with preset and transpositions
                    const lt = String(+columnElement.dataset.localTranspose || 0);
                    const gt = String(this.transposeDelta || 0);
                    const warmKey = `${pianoLockedData.lockKey || pianoLockedData.presetId}:${lt}:${gt}`;
                    if (this.preloadedChordWarmups.has(warmKey)) return; // already warm
                    this.preloadedChordWarmups.add(warmKey);

                    // Snapshot current synth state, apply preset briefly, warm audio, then restore
                    const originalSettings = {
                        osc1: { ...this.oscillators.osc1 },
                        osc2: { ...this.oscillators.osc2 },
                        envelope: { ...this.envelope },
                        osc2Envelope: { ...this.osc2Envelope },
                        volume: this.volume,
                        masterVolume: this.masterVolume
                    };
                    this.applyPianoLockedSettings(pianoLockedData);
                    await this.warmUpAudioGraph(18);
                    // Touch current string frequencies to ensure datasets are present (no audio triggered)
                    try {
                        const strings = columnElement.querySelectorAll('.string');
                        strings.forEach(el => { void el.dataset.frequency; });
                    } catch(_) { }
                    // Restore original state (no UI change)
                    Object.assign(this.oscillators.osc1, originalSettings.osc1);
                    Object.assign(this.oscillators.osc2, originalSettings.osc2);
                    Object.assign(this.envelope, originalSettings.envelope);
                    Object.assign(this.osc2Envelope, originalSettings.osc2Envelope);
                    this.volume = originalSettings.volume;
                    this.masterVolume = originalSettings.masterVolume;
                    // Reverb/panning untouched
                    if (this.gainNode) this.gainNode.gain.value = this.volume * this.masterVolume;
                } catch(_) { /* no-op */ }
            }

            randomizeOscillator(oscNum) {
                const waveforms = ['sine', 'sawtooth', 'square', 'triangle', 'pulse', 'fullrect', 'halfrect', 'trapezoid', 'parabolic', 'stair'];
                const randomWave = waveforms[Math.floor(Math.random() * waveforms.length)];
                
                // Set waveform by updating the buttons
                const waveButtons = document.querySelectorAll(`[data-wave][data-osc="${oscNum}"]`);
                waveButtons.forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.wave === randomWave) {
                        btn.classList.add('active');
                    }
                });
                this.oscillators[`osc${oscNum}`].type = randomWave;
                const pwContainer = document.querySelector(`.pulse-width-container[data-osc="${oscNum}"]`);
                if (randomWave === 'pulse') {
                    const pw = 5 + Math.floor(Math.random() * 90);
                    const pwSlider = document.getElementById(`osc${oscNum}PulseWidth`);
                    const pwValue = document.getElementById(`osc${oscNum}PulseWidthValue`);
                    this.oscillators[`osc${oscNum}`].pulseWidth = pw / 100;
                    if (pwSlider) pwSlider.value = String(pw);
                    if (pwValue) pwValue.textContent = `${pw}%`;
                    if (pwContainer) pwContainer.style.display = 'block';
                } else if (pwContainer) {
                    pwContainer.style.display = 'none';
                }

                // Skip volume, coarse, fine, octave randomization to maintain tuning
                // Only randomize ADSR controls within their actual slider ranges
                
                // Use correct slider IDs - OSC1 has no prefix, OSC2 has "osc2" prefix
                const attackSliderID = oscNum === 1 ? 'attackSlider' : 'osc2AttackSlider';
                const decaySliderID = oscNum === 1 ? 'decaySlider' : 'osc2DecaySlider';
                const sustainSliderID = oscNum === 1 ? 'sustainSlider' : 'osc2SustainSlider';
                const releaseSliderID = oscNum === 1 ? 'releaseSlider' : 'osc2ReleaseSlider';
                
                const attackValueID = oscNum === 1 ? 'attackValue' : 'osc2AttackValue';
                const decayValueID = oscNum === 1 ? 'decayValue' : 'osc2DecayValue';
                const sustainValueID = oscNum === 1 ? 'sustainValue' : 'osc2SustainValue';
                const releaseValueID = oscNum === 1 ? 'releaseValue' : 'osc2ReleaseValue';

                const attackSlider = document.getElementById(attackSliderID);
                const decaySlider = document.getElementById(decaySliderID);
                const sustainSlider = document.getElementById(sustainSliderID);
                const releaseSlider = document.getElementById(releaseSliderID);
                
                // Get the actual slider min/max values for proper randomization
                let attackMin = 5; // default minimum
                let attackMax = 1000; // default for OSC1
                if (attackSlider) {
                    attackMin = Math.max(5, parseInt(attackSlider.min)); // Ensure minimum 5ms
                    attackMax = parseInt(attackSlider.max);
                }
                
                // Randomize ADSR parameters within proper ranges
                const attack = attackMin + Math.random() * (attackMax - attackMin); // Within slider range
                const decay = Math.random() * 1000; // 0-1000ms
                const sustain = Math.random() * 0.5; // 0-50%
                const release = Math.random() * 1000; // 0-1000ms (cap)

                if (attackSlider) {
                    attackSlider.value = attack;
                    const attackValue = document.getElementById(attackValueID);
                    if (attackValue) attackValue.textContent = `${Math.round(attack)}ms`;
                    // Update internal ADSR
                    if (oscNum === 1 && this.envelope) {
                        this.envelope.attack = attack / 1000;
                    } else if (oscNum === 2 && this.osc2Envelope) {
                        this.osc2Envelope.attack = attack / 1000;
                    }
                    console.log(`?? OSC${oscNum} Attack set to ${Math.round(attack)}ms`);
                }
                if (decaySlider) {
                    decaySlider.value = decay;
                    const decayValue = document.getElementById(decayValueID);
                    if (decayValue) decayValue.textContent = `${Math.round(decay)}ms`;
                    // Update internal ADSR
                    if (oscNum === 1 && this.envelope) {
                        this.envelope.decay = decay / 1000;
                    } else if (oscNum === 2 && this.osc2Envelope) {
                        this.osc2Envelope.decay = decay / 1000;
                    }
                    console.log(`?? OSC${oscNum} Decay set to ${Math.round(decay)}ms`);
                }
                if (sustainSlider) {
                    sustainSlider.value = sustain * 100;
                    const sustainValue = document.getElementById(sustainValueID);
                    if (sustainValue) sustainValue.textContent = `${Math.round(sustain * 100)}%`;
                    // Update internal ADSR
                    if (oscNum === 1 && this.envelope) {
                        this.envelope.sustain = sustain;
                    } else if (oscNum === 2 && this.osc2Envelope) {
                        this.osc2Envelope.sustain = sustain;
                    }
                    console.log(`?? OSC${oscNum} Sustain set to ${Math.round(sustain * 100)}%`);
                }
                if (releaseSlider) {
                    releaseSlider.value = release;
                    const releaseValue = document.getElementById(releaseValueID);
                    if (releaseValue) releaseValue.textContent = `${Math.round(release)}ms`;
                    // Update internal ADSR
                    if (oscNum === 1 && this.envelope) {
                        this.envelope.release = Math.min(1, release / 1000);
                    } else if (oscNum === 2 && this.osc2Envelope) {
                        this.osc2Envelope.release = Math.min(1, release / 1000);
                    }
                    console.log(`?? OSC${oscNum} Release set to ${Math.round(release)}ms`);
                }

                // Update ADSR values in the internal structure (backup)
                if (this.adsrSettings && this.adsrSettings[`osc${oscNum}`]) {
                    this.adsrSettings[`osc${oscNum}`].attack = attack / 1000;
                    this.adsrSettings[`osc${oscNum}`].decay = decay / 1000;
                    this.adsrSettings[`osc${oscNum}`].sustain = sustain;
                    this.adsrSettings[`osc${oscNum}`].release = release / 1000;
                }
                
                console.log(`?? Randomized OSC${oscNum}: ${randomWave} wave, A:${Math.round(attack)} D:${Math.round(decay)} S:${Math.round(sustain*100)}% R:${Math.round(release)}`);
            }

            randomizeEffects() {
                // Random reverb settings with wider ranges
                const reverbWet = Math.random() * 0.9; // 0-90% wet
                const reverbDecay = 0.3 + Math.random() * 5.7; // 0.3-6 seconds
                const reverbCut = 800 + Math.random() * 19200; // 800Hz-20kHz

                const reverbWetSlider = document.getElementById('reverbWet');
                const reverbDecaySlider = document.getElementById('reverbDecay');
                const reverbCutSlider = document.getElementById('reverbFilterCutoff');

                if (reverbWetSlider) {
                    reverbWetSlider.value = reverbWet * 10; // slider is 0-10 scale
                    if (this.reverb) this.reverb.wet = reverbWet;
                    if (this.wetGainNode && this.dryGainNode) {
                        this.wetGainNode.gain.value = reverbWet;
                        this.dryGainNode.gain.value = 1 - reverbWet;
                    }
                    if (typeof this.updateReverbRouting === 'function') this.updateReverbRouting();
                    const reverbWetValue = document.getElementById('reverbWetValue');
                    if (reverbWetValue) reverbWetValue.textContent = `${Math.round(reverbWet * 100)}%`;
                }
                if (reverbDecaySlider) {
                    reverbDecaySlider.value = reverbDecay;
                    if (this.reverb) this.reverb.decay = reverbDecay;
                    const reverbDecayValue = document.getElementById('reverbDecayValue');
                    if (reverbDecayValue) reverbDecayValue.textContent = `${reverbDecay.toFixed(1)}s`;
                }
                if (reverbCutSlider) {
                    reverbCutSlider.value = reverbCut;
                    if (this.reverbFilterNode) this.reverbFilterNode.frequency.value = reverbCut;
                    const reverbCutValue = document.getElementById('reverbFilterCutoffValue');
                    if (reverbCutValue) reverbCutValue.textContent = `${Math.round(reverbCut)}Hz`;
                }

                // Random panning mode and width
                const panModes = ['center', 'random', 'frequency', 'rotating', 'alternating', 'wide'];
                const panMode = panModes[Math.floor(Math.random() * panModes.length)];
                const panWidth = 0.2 + Math.random() * 0.8; // 20-100% width
                
                const panSelector = document.getElementById('panningMode');
                const panWidthSlider = document.getElementById('panningWidth');
                
                if (panSelector) {
                    panSelector.value = panMode;
                    this.panning.mode = panMode;
                }
                if (panWidthSlider) {
                    panWidthSlider.value = panWidth * 100;
                    this.panning.width = panWidth;
                    const panWidthValue = document.getElementById('panningWidthValue');
                    if (panWidthValue) panWidthValue.textContent = `${Math.round(panWidth * 100)}%`;
                }
                
                console.log(`??? Randomized effects: ${panMode} panning (${Math.round(panWidth * 100)}%), ${reverbDecay.toFixed(1)}s reverb`);
            }
        }

        // Initialize the instrument when the page loads
        let omnichord;
    window.addEventListener('load', () => {
            omnichord = new MicrotonalOmnichord();
            window.omnichord = omnichord; // Make it globally accessible

            // Also expose adjustKeyboardForLogo for resize events
            window.PianoApp = window.PianoApp || {};
            window.PianoApp.adjustKeyboardForLogo = () => {
                if (omnichord && typeof omnichord.adjustKeyboardForLogo === 'function') {
                    omnichord.adjustKeyboardForLogo();
                }
            };
            // Initial adjustment on load
            if (window.PianoApp.adjustKeyboardForLogo) window.PianoApp.adjustKeyboardForLogo();
            
            // Initialize new features
            omnichord.initTutorial();
            omnichord.initRandomDice();
            // Wire bottom bar Save/Import/Export
            const bottomSave = document.getElementById('bottomSaveSeqBtn');
            if (bottomSave) bottomSave.addEventListener('click', () => {
                try {
                    const text = omnichord.buildCurrentSequenceString(true);
                    if (!text) return;
                    const name = prompt('Preset name?', 'My Sequence');
                    if (!name) return;
                    omnichord.saveSequencePreset(`${text} (${name})`);
                    // Refresh presets dropdown immediately if open
                    const sel = document.getElementById('seqPresetSelect');
                    if (sel) omnichord.populateSeqPresetDropdown(sel, omnichord.getSequencePresets());
                } catch {}
            });
            const bottomExport = document.getElementById('bottomExportOMGBtn');
            if (bottomExport) bottomExport.addEventListener('click', () => { try { omnichord.saveSessionAsOMG(); } catch {} });
            const bottomImport = document.getElementById('bottomImportOMGBtn');
            if (bottomImport) bottomImport.addEventListener('click', () => {
                const input = document.getElementById('loadSessionInput');
                if (input) input.click();
            });
            
            // Add event handler for chord name saving (ensure no root names are saved)
            const saveChordNameBtn = document.getElementById('saveChordName');
            if (saveChordNameBtn) {
                saveChordNameBtn.addEventListener('click', () => {
                    if (omnichord) {
                        omnichord.saveNewChord();
                    }
                });
            }

            // Ensure startup EDO is 24 and seed a single C major chord (no extra blank column)
            try {
                const edoPanel = document.getElementById('edoDivisions');
                const edoQuick = document.getElementById('edoQuickInput');
                if (edoPanel) edoPanel.value = '24';
                if (edoQuick) edoQuick.value = '24';
                if (omnichord && typeof omnichord.updateTuningSystem === 'function') omnichord.updateTuningSystem(24);
            } catch {}
            try {
                // Prefill [0,4,7] mapped to current EDO and finalize directly as a single chord
                const edo = omnichord.currentTuning || 24;
                const triadSteps = [0, omnichord.mapIntervalToEDO(4, edo), omnichord.mapIntervalToEDO(7, edo)];
                omnichord.selectedIntervals = triadSteps;
                // Finalize directly (no preview/blank column), creating exactly one chord
                omnichord.finalizePreviewChord('C');
                // Set the last column (newly added) as active and arm keyboard editing
                const cols = document.querySelectorAll('.extension-column');
                const lastCol = cols && cols.length ? cols[cols.length - 1] : null;
                if (lastCol) {
                    omnichord.currentActiveColumnEl = lastCol;
                    omnichord.highlightKeyboardForColumn(lastCol);
                }
                omnichord.editArmed = true;
            } catch {}
        });
        
        // Add exit prompt for saving to OMG file
        window.addEventListener('beforeunload', (e) => {
            if (omnichord && (omnichord.chordExtensions.length > 0 || omnichord.lockedChords?.size > 0)) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Would you like to save your session to an OMG file?';
                return e.returnValue;
            }
        });
             // Bottom bar panel toggling (uses existing migrated panel-content elements)
             (function(){
                 const bar=document.getElementById('bottomBar');
                 const host=document.getElementById('panelHost');
                 if(!bar||!host) return;
                 const panels=[...host.querySelectorAll('.panel-content')];
                 let open=null;
                 function show(id){
                     panels.forEach(p=>{p.style.display = (p.dataset.panel===id)?'grid':'none';});
                     host.style.display='block';
                 }
                 function close(){ host.style.display='none'; panels.forEach(p=>p.style.display='none'); open=null; bar.querySelectorAll('.panel-btn').forEach(b=>b.classList.remove('active')); }
                 // Expose programmatic closer on the main controller if available
                 if (window.omnichord) {
                     window.omnichord.closeBottomPanel = close;
                 } else {
                     // If not yet initialized, defer until DOMContentLoaded listeners create it
                     document.addEventListener('omnichord-ready', ()=>{ if (window.omnichord) window.omnichord.closeBottomPanel = close; }, { once:true });
                 }
                 // Only toggle panels for buttons that explicitly declare a data-panel target.
                 bar.addEventListener('click',e=>{
                     const btn = e.target.closest('.panel-btn[data-panel]');
                     if(!btn) return; // Ignore non-panel buttons like "+" and "SEQUENCE"
                     const id = btn.dataset.panel;
                     if(!id) return;
                     if(open===id){ close(); return; }
                     open = id;
                     show(id);
                     bar.querySelectorAll('.panel-btn').forEach(b=>b.classList.toggle('active',b===btn));
                 });
                 window.addEventListener('keydown',e=>{ if(e.key==='Escape') close(); });
                 window.addEventListener('click',e=>{ if(open && !host.contains(e.target) && !bar.contains(e.target)) close(); });
             })();
    </script>
</body>
</html>




